正课:
1.什么是类？什么是对象？
  1)现实世界是由很多对象组成的
    基于对象抽出类
  2)对象:真实存在的单个的个体
    类:类型/类别，代表一类个体
  3)类中可以包含:
    3.1)所有对象所共有的属性/特征----------------成员变量
	3.2)所有对象所共有的行为---------------------方法
  4)一个类可以创建多个对象，
    同一类型的多个对象，结构相同，数据不同
  5)类是对象的模板，对象是类的具体的实例
2.如何创建类？如何创建对象？如何访问成员？

笔记:
1.方法的重载(Overload):
  1)发生在一个类中，方法名称相同，参数列表不同
  2)编译器在编译时会根据方法的签名自动绑定调用的方法
2.构造方法:构造函数、构造器，构建器
  1)给成员变量赋初值
  2)与类同名、没有返回值类型
  3)在创建(new)对象时被自动调用
  4)若自己不写构造方法，则编译器默认一个无参构造方法，
    若自己写了构造方法，则不再默认提供
  5)构造方法可以重载
3.this:指代当前对象，哪个对象调用方法指的就是哪个对象
       只能用在方法体中，方法中访问成员变量之前默认有个this.
  this的用法:
   1)this.成员变量名--------------访问成员变量
   2)this.方法名()----------------调用方法(几乎不用)
   3)this()-----------------------调用构造方法

笔记:
1.引用类型数组:
  1)Student[] stus = new Student[3];
    stus[0] = new Student();
	stus[1] = new Student();
	stus[2] = new Student();
	stus[1].age = 25; //给第2个学生的年龄赋值给25
  2)Student[] stus = new Student[]{
      new Student(),
	  new Student(),
	  new Student()
    };
  3)int[][] arr = new int[3][];------------数组的数组
    arr[0] = new int[2];
    arr[1] = new int[3];
	arr[2] = new int[2];
    arr[1][0] = 100; //给arr第2个元素中的第1个元素赋值为100
  4)int[][] arr = new int[3][4];
    for(int i=0;i<arr.length;i++){
	  for(int j=0;j<arr[i].length;j++){
	    arr[i][j] = 100;
	  }
	}
2.继承:
  1)作用:代码复用
  2)通过extends来实现继承
  3)超类:所有派生类所共有的属性和行为
    派生类:派生类所特有的属性和行为
  4)派生类继承超类后，派生类具有:派生类的+超类的
  5)一个超类可以有多个派生类
    一个派生类只能有一个超类-----------单一继承
  6)继承具有传递性
  7)java规定:构造派生类之前必须构造超类
    在派生类的构造方法中，若自己不调用超类的构造方法
	--------------则默认super()调用超类的无参构造方法
    在派生类的构造方法中，若自己调用了超类的构造方法
	--------------则不再默认提供
	super()调用超类的构造必须位于派生类构造中的第一行
3.super:指代当前对象的超类对象
  super的用法:
    super.成员变量名---------访问超类的成员变量
	super.方法名()-----------调用超类的方法---------下次课讲
	super()------------------调用超类的构造方法
4.null:空，没有指向任何对象
       若引用的值为null，则该引用不能进行任何操作
	   若操作则发生NullPointerException空指针异常

笔记:
1.向上造型:
  1)超类型的引用指向派生类的对象
  2)能点出来什么，看引用的类型
2.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
  3)遵循"两同两小一大"原则:-----------了解
    3.1)两同:
	    3.1.1)方法名称相同
		3.1.2)参数列表相同
	3.2)两小:
	    3.2.1)派生类方法的返回值类型小于或等于超类方法的
		      1)void时，必须相等
			  2)基本类型时，必须相等
			  3)引用类型时，小于或等于
		3.2.2)派生类方法抛出的异常小于或等于超类方法的-----异常之后
	3.3)一大:
	    3.3.1)派生类方法的访问权限大于或等于超类方法的-----明天讲
3.重写与重载的区别:---------常见面试题
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)遵循"运行期"绑定，看对象的类型来调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)遵循"编译期"绑定，看参数/引用的类型来绑定方法

笔记:
1.package:
  1)作用:避免类的命名冲突
  2)类的全称: 包名.类名
  3)包名可以有层次结构
  4)建议:包名所有字母都小写
  import:
  1)同包中的类可以直接访问，
    不同包中的类不能直接访问，想访问有如下两种方式:
	1.1)先import声明类，再直接访问类-----建议
	1.2)类的全称-------------------------太繁琐，不建议
2.访问控制修饰符:
  1)public:公开的，任何类
  2)protected:受保护的，本类、子类、同包类
  3)默认的:什么也不写，本类、同包类
  4)private:私有的，本类
  说明:
    1)类的访问修饰符只能是public或默认的
	2)类中成员的访问修饰符如上4种都可以
3.final:最终的、不可改变的-------应用率低
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
4.static:静态的
  1)静态变量:
    1.1)由static修饰
	1.2)属于类的，存储在方法区中，只有一份
	1.3)常常通过类名点来访问
	1.4)何时用:所有对象所共享的数据(图片、音频、视频等)
  2)静态方法:
    2.1)由static修饰
	2.2)属于类的，存储在方法区中，只有一份
	2.3)常常通过类名点来访问
	2.4)静态方法没有隐式的this传递，
	    所以在静态方法中不能直接访问实例成员
	2.5)何时用:方法的操作仅与参数相关而与对象无关
  3)静态块:
    3.1)属于类的，在类被加载期间自动执行的，
	    因类只被加载一次，所以静态块也只执行一次
	3.2)何时用:初始化/加载静态资源(图片、音频、视频等)
5.static final常量: 明天讲

正课:
1.static final常量: 应用率高
  1)必须声明同时初始化
  2)通过类名点来访问，常量不能被改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时将常量自动替换为具体的值，效率高
  5)何时用:数据经常使用，并且永远不变
2.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有方法的具体实现(连{}都没有)
3.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类-------我乐意
  3)不能被实例化
  4)抽象类是需要被继承的，派生类:
    4.1)重写抽象类中的所有抽象方法-----变不完整为完整
	4.2)也声明为抽象类-----------------不常用
  5)抽象类的意义:
    5.1)封装派生类所共有的属性和行为--------代码复用
	5.2)为所有派生类提供一种统一的类型------向上造型
	5.3)可以包含抽象方法，为所有派生类提供统一的入口，
	    派生类的具体行为不同，但入口是一致的
设计规则:
1)将所有派生类所共有的属性和行为，抽到超类中-------抽共性
2)所有派生类的行为都一样，设计为普通方法
  所有派生类的行为都不一样，设计为抽象方法
3)
1)获取图片(前三步)
  1.1)超类抽象方法getImage()
  1.2)超类LIFE、DEAD、REMOVE，state当前状态
          isLife()、isDead()、isRemove()
  1.3)派生类中重写getImage()
2)画图片(中间两步)
  2.1)超类普通方法paintObject()
  2.2)天空Sky重写paintObject()
3)窗口调(最后一步)
  3.1)World中重写paint()

正课:
1.成员内部类: 应用率低
  1)类中套类，外面的称为Outer外部类，里面的称为Inner内部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类对象通常是在外部类中创建的
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有个隐式的引用指向了创建它的外部类对象
	  外部类名.this
2.匿名内部类:
  1)若想创建一个类的对象，并且对象只被创建一次，
    此时该类不必命名，称之为匿名内部类
  2)匿名内部类中访问外面的变量，该变量在jdk1.8以前必须是final的

常见面试题:
问:内部类有独立的.class吗?
答:有

正课:
1.敌人入场
2.子弹入场
3.飞行物移动
4.英雄机随着鼠标动
5.删除越界的飞行物


做功能的步骤:
1.先写行为:
  1)某个对象所特有的行为，就将方法写在特定的类中
  2)所有对象所共有的行为，就将方法写在超类FlyingObject中
2.页面调用:
  1)定时发生的，在定时器中调用
  2)事件触发的，在侦听器中调用
  3)画出来的，在paint中调用

笔记:
1.接口:
  1)是引用数据类型
  2)由interface定义
  3)只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现/继承的，实现类/派生类:
      必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，应先继承后实现
  7)接口可以继承接口
2.多态:
  1)意义:
    1.1)同一类型的引用在指向不同的对象时，有不同的实现
	    ------行为的多态:cut(),run(),step()...
	1.2)同一个对象被造型为不同的类型时，有不同的功能
	    ------对象的多态:我，水...
  2)向上造型:
    2.1)超类型的引用指向派生类的对象
	2.2)能造型成为的类型有: 超类+所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件只有如下两种:
    3.1)引用所指向的对象，就是该类型
	3.2)引用所指向的对象，实现了该接口/继承了该类
  4)强转若不符合如上两个条件，则发生ClassCastException类型转换异常，
    建议:强转之前instanceof判断引用指向的对象是否是该类型


设计规则:
1)将所有派生类所共有的属性和行为，设计在超类中
2)所有派生类行为都一样，设计为普通方法
  所有派生类行为都不一样，设计为抽象方法
3)将部分派生类所共有的行为，设计在接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展----------实现多继承

面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性的行为
  2)方法:封装一段特定的业务逻辑功能
  3)访问控制修饰符:封装的是具体的访问权限
2.继承:
  1)作用:代码复用
  2)超类:所有派生类所共有的属性和行为
    接口:部分派生类所共有的行为
	派生类:派生类所特有的属性和行为
  3)单一继承、多接口实现，传递性
3.多态:
  1)行为多态(所有抽象方法都是多态的)
    对象多态(所有对象都是多态的)
  2)向上造型、强制类型转换、instanceof
  3)多态的表现形式:
    3.1)重写:根据对象的不同来多态
	3.2)重载:根据参数的不同来多态
