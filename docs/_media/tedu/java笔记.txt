自定义java代码模板:window-preferences-java-Editor-Templates-new
题库:
http://qwserver.tmooc.cn/web/tm_exam.html?sessionId=38BD5DBC46F34D6AAA0E3FCC7A22ED70
-------------------------------Basic------------------------------------

王克晶(WKJ)
qq:1945019382
phone:18611791210
email:wangkj@tedu.cn
weibo:王克晶WKJ
学习Java的窍门?
  1)多想
  2)多练
--------------------------------day01------------------------------------
笔记:
1.JAVA开发环境:
	1)java编译运行过程:-------------常见面试题
		1.1)编译期:.java源文件，经过编译，生成.class字节码文件
		1.2)运行期:JVM加载.class并运行.class
		特点:跨平台、一次编程到处使用
	2)名词解释:-----------------常见面试题
		2.1)JVM:java虚拟机,加载.class并运行.class
		2.2)JRE:java运行环境,除了包含JVM以外还包含了运行java程序所必须的环境
			RE=JVM+java系统类库(小零件),运行java程序的最小环境为JRE
		2.3)JDK:java开发工具包.除了包含JRE以外还包含了开发java程序所必须的命令工具
			JDK=JRE+编译、运行等命令工具,开发java程序的最小环境为JDK
  	3)配置环境变量-----------------了解
		3.1)JAVA_HOME:指向jdk的安装目录
		3.2)CLASSPATH:表示类的搜索路径，一般简写为.
		3.3)PATH:指向jdk下的bin目录
2.Eclipse:
	1)IBM、开源的、免费的、不需要安装仅需要解压即可
	2)开发步骤:
		2.1)新建Java项目/工程-------------------小区
		2.2)新建Java包--------------------------楼号+单元号
		2.3)新建Java类--------------------------房子
	3)注释:解释性文本
		3.1)单行注释://
		3.2)多行注释:/* */
		3.3)文档注释:/** */

--------------------------------day02------------------------------------
笔记:
1.变量:存数的
	1)声明:
		int a; //声明一个整型的变量，名为a
		int b,c,d; //声明三个整型的变量，名为b,c,d
	2)初始化:第一次赋值
		2.1)声明的同时初始化
		2.2)先声明后初始化
	3)使用:
		3.1)对变量,就是对它所存的那个数的操作
			  int a = 5;
			  int b = a+10; //取出a的值5，加10后，再赋值给整型变量b
			  System.out.println(b);   //输出变量b的值15
			  System.out.println("b"); //输出b，双引号中的原样输出
			  a = a+10; //取出a的值5，加10后，再赋值给a
				        //在a本身基础之上增10
			  System.out.println(a); //15
		3.2)变量的操作必须与数据类型匹配
			 int a = 3.14; //编译错误，数据类型不匹配
		3.3)变量在用之前必须声明并初始化
	      System.out.println(m); //编译错误，m未声明
		   int m;
		   System.out.println(m); //编译错误，m未初始化
	4)命名:
		4.1)只能包含字母、数字、_和$符，并且不能以数字开头
		4.2)严格区分大小写
		4.3)不能使用关键字
		4.4)可以中文命名，但不建议
	    建议:"英文的见名知意"、"驼峰命名法"
2.基本数据类型:
	1)int:整型，4个字节，-21个多亿到21个多亿
		1.1)整数直接量默认为int型，不能超出范围，超出范围则编译错误
		1.2)两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入)
		1.3)整数运算时超出范围，则发生溢出(需要避免的)
	2)long:长整型，8个字节，很大很大很大
		2.1)长整型直接量需在数字后加L或l
		2.2)运算时若有可能溢出，建议在第1个数字后加L
		2.3)System.currentTimeMillis()用于获取自
			1970.1.1零时到此时此刻的毫秒数-------用途下周四讲
	3)double:浮点型，8个字节，很大很大很大
		3.1)浮点数直接量默认为double型，表示float需在数字后加F或f
		3.2)浮点型数据在运算时，有可能会出现舍入误差
	4)boolean:布尔型，1个字节,只能取值为true和false
  	5)char:字符型，2个字节
		5.1)采用的是Unicode字符集编码格式，
			每个字符都有一个对应的码(0到65535之间)
			表现的形式的是字符char，实质上是码int
			ASCII码('a'--97  'A'--65  '0'--48)
		5.2)字符直接量必须放在单引号中，只能有一个
		5.3)特殊符号需通过\来转义
		
3.基本数据类型间的转换:
    	数据类型从小到大依次为:
	 	 byte,short,int,float,long,double
	     	   char
			   boolean
	1)两种方式:
		1.1)自动类型转换:从小类型到大类型
		1.2)强制类型转换:从大类型到小类型
			  语法: (要转换成为的数据类型)变量
			  强转有可能会溢出或丢失精度
	2)两点规则:
		2.1)整数直接量可以直接赋值给byte,short,char，但不能超出范围
		2.2)byte,short,char型数据参与运算时，先一律转换为int再运算
4.Scanner接收用户的输入:
	1)在package下:
      import java.util.Scanner;
	2)在main方法中:
      Scanner scan = new Scanner(System.in);
	3)在第2步之下:
    	System.out.println("请输入年龄:");
	   int age = scan.nextInt();
    	System.out.println("请输入价格:");
    	double price = scan.nextDouble()

--------------------------------day03------------------------------------
笔记:
1.运算符:
  1)算术:+,-,*,/,%,++,--
  2)关系:>,<,>=,<=,==,!= boolean
  3)逻辑:&&,||,! boolean
  4)赋值:=,+=,-=,*=,/=,%=
  5)字符串连接:+
  6)条件/三目:boolean?数1:数2
2.分支结构:
  1)if结构:1条路
  2)if...else结构:2条路
  3)if...else if结构:多条路
  4)switch...case结构:多条路
    优点:效率高、结构清晰
	缺点:整数、相等
	break:跳出switch

--------------------------------day04------------------------------------
笔记:
2.循环:反复执行一段相同或相似的代码
3.循环三要素:
  1)循环变量的初始化
  2)循环的条件(以循环变量为基础)
  3)循环变量的改变(向着循环的结束变)
  循环变量:在整个循环过程中所反复改变的那个数
4.循环结构:
  1)while:先判断后执行，有可能一次都不执行
  2)do...while:先执行后判断，至少执行一次
       要素1与要素3相同时，首选do...while
  3)for:应用率高

Math.random()-----------0.0到0.999999999999999999...
*1000-------------------0.0到999.9999999999999999...
+1----------------------1.0到1000.999999999999999...
(int)-------------------1到1000

1)顺序结构:从上往下逐行执行，每句必走
2)分支结构:有条件的执行某语句一次，并非每句必走
3)循环结构:有条件的执行某语句多次，并非每句必走

一目:++,--,!
二目:其余都是
三目:boolean?数1:数2

--------------------------------day05------------------------------------
笔记:
2.break:跳出循环
  continue:跳过循环体中剩余语句而进入下一次循环
3.三种循环结构的更佳适用情况:
  1)while:不固定次数
		要素1与要素3不同时，首选while
  2)do...while:不固定次数
		要素1与要素3相同时，首选do...while
  3)for:应用率最高，固定次数循环
4.嵌套循环:
  1)循环中套循环，一般多行多列时使用，外层控制行，内层控制列
  2)执行过程:外层走一次，内层走所有次
  3)建议:循环层数越少越好，能用一层就不用两层，能用两层就不用三层
       若业务必须通过三层以上的循环来解决，说明你的设计有问题
  4)break只能跳出一层循环
5.程序=算法+数据结构
  1)算法:解决问题的流程/步骤(顺序、分支、循环)
  2)数据结构:将数据按照某种特定的结构来保存
             数怎么存
	设计良好的/合理的数据结构会导致好的算法
6.数组:
  1)是一种数据类型(引用类型)
  2)相同数据类型元素的集合
  3)数组的定义:
      int[] arr = new int[10];
  4)数组的初始化:
      int[] arr = new int[3]; //0,0,0
	  int[] arr = {1,4,7}; //1,4,7
	  int[] arr = new int[]{1,4,7}; //1,4,7
	  int[] arr;
      arr = {1,4,7}; //编译错误，此方式只能声明同时初始化
	  arr = new int[]{1,4,7}; //正确
  5)数组的访问:
    5.1)通过数组名.length来获取数组的长度(元素的个数)
	      int[] arr = new int[10];
		  System.out.println(arr.length); //10
	5.2)通过下标/索引来访问元素
	    下标从0开始，最大到(数组的长度-1)
		  int[] arr = new int[3];
		  arr[0] = 10;
		  arr[1] = 20;
		  arr[2] = 30;
		  arr[3] = 40; //数组下标越界异常
		  System.out.println(arr[arr.length-1]);
  6)数组的遍历:
      int[] arr = new int[10];
	  for(int i=0;i<arr.length;i++){
	    arr[i] = 100;
	  }
	  for(int i=0;i<arr.length;i++){
	    System.out.println(arr[i]);
	  }
	  for(int i=arr.length-1;i>=0;i--){
	    System.out.println(arr[i]);
	  }


练习:----------------------每人两遍
1)完成随机加法运算器
2)完成九九乘法表
3)完成求数组元素的最大值--------day06包中

int[] arr = {23,45,78,4};
找最大值的算法:
1)假设第1个元素为最大值:
    int max = arr[0];
2)遍历剩余元素，将剩余元素与max比较，
  若剩余元素大于max，则修改max为较大的
    for(int i=1;i<arr.length;i++){
	  if(arr[i]>max){
	    max=arr[i];
	  }
	}

\t:水平制表位，固定占8位


--------------------------------day06------------------------------------
笔记:
1.数组:
  7)数组的复制:
    7.1)System.arraycopy(a,1,a1,0,4);
	7.2)int[] a1 = Arrays.copyOf(a,6);
	    a = Arrays.copyOf(a,a.length+1); //数组的扩容
  8)数组的排序:
    8.1)Arrays.sort(arr); //升序
	8.2)冒泡排序:
	    8.2.1)五个数冒四轮
		8.2.2)每一轮都是从第1个元素开始冒
		      每一次都是和它的下一个元素比
		8.2.3)冒出来的就不带它玩了
2.方法:
  1)封装一段特定的业务逻辑功能
  2)方法尽可能的独立，只干一件事
  3)方法可以被反复多次的调用
  4)减少代码重复，有利于代码的维护，有利于团队的协作开发
3.方法的定义:
    修饰词 返回值类型 方法名(参数列表){
	  方法体
	}
4.方法的调用:
  1)无返回值: 方法名(有参传参);
  2)有返回值: 数据类型 变量 = 方法名(有参传参);
5.return的用法:
  1)return 值; //1.1)结束方法的执行  1.2)返回结果给调用方
  2)return;    //2.1)结束方法的执行


练习:-------------每人至少两次
1)将数组元素最大值放在最后一个元素的下一个位置MaxOfArray
2)冒泡排序BubbleSort
3)运行Guessing了解明天项目的需求


int[] arr = {67,23,45,1}; //升序(1,23,45,67)
for(int i=0;i<arr.length-1;i++){ //控制轮数
  for(int j=0;j<arr.length-1-i;j++){ //控制次数
    if(arr[j]>arr[j+1]){
	  int t = arr[j];
	  arr[j] = arr[j+1];
	  arr[j+1] = t;
	}
  }
}

BubbleSort冒泡排序
i=0
  j=0 67和23比，换，23,67,45,1
  j=1 67和45比，换，23,45,67,1
  j=2 67和1比，换，23,45,1,67-------67出来了
i=1
  j=0 23和45比，不换
  j=1 45和1比，换，23,1,45,67-------45出来了
i=2
  j=0 23和1比，换，1,23,45,67-------23出来了

第一轮:
  67和23比，换，23,67,45,1
  67和45比，换，23,45,67,1
  67和1比，换，23,45,1,67-------------67冒出来了
第二轮:
  23和45比，不换
  45和1比，换，23,1,45,67-------------45冒出来了
第三轮:
  23和1比，换，1,23,45,67-------------23冒出来了

1)不同的数据用不同的排序算法，优劣也是不同的
    这30万个数据-----------------插入排序最快
	另30万个数据-----------------冒泡排序最快
	另30万个数据-----------------快速排序最快
2)有一种排序方式一直是最最快的
    Arrays.sort(arr); //升序    


--------------------------------day07------------------------------------
正课:
一.猜字符小游戏:
   1.设计数据结构:变量
     1)char[] chs;   //随机字符数组
	 2)char[] input; //用户输入的字符数组
	 3)int[] result; //对比结果
	 4)int score;    //得分
   2.设计程序结构:方法
     1)主方法:
	   public static void main(String[] args){
	     //...
	   }
	 2)生成随机字符数组chs:
	   public static char[] generate(){
	     char[] chs = new char[5];
		 //...
         return chs;
	   }
	 3)对比:随机字符数组chs与用户输入的字符数组input
	   public static int[] check(char[] chs,char[] input){
	     int[] result = new int[2];
		 //...
		 return result;
	   }
   3.设计算法:方法体


练习:
1.独立完成猜字符小游戏

1.藏起来一个数chs
2.猜吧!接收用户输入的数input
3.对比:
  1)猜对了，则算分结束
  2)猜错了，提示，并继续第2步


--------------------------------------OOP---------------------------------
面向对象课程安排:
第一天:
  1.知识点:
    1)什么是类？什么是对象？
	2)如何创建类？如何创建对象？如何访问成员？
  2.项目:
    1)创建6个对象类，并创建World类测试
第二天:
  1.知识点:
	1)方法的重载
	2)构造方法
	3)this
	4)null和NullPointerException
	5)引用类型之间画等号
  2.项目:
    1)给6个对象类添加构造方法，并测试
第三天:
  1.知识点:
    1)引用类型数组
	2)继承
	3)super
  2.项目:
    1)设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
	2)设计超类FlyingObject，6个对象类分别继承，并测试
	3)给FlyingObject设计两个构造方法，6个对象类分别调用超类的构造方法
第四天:
  1.知识点:
    1)向上造型
	2)重写、重写与重载的区别
  2.项目:
    1)将小敌机、大敌机、小蜜蜂数组合为FlyingObject数组
	2)重写超类FlyingObject的step()方法
	3)画窗口
第五天:
  1.知识点:
    1)package和import
	2)访问控制修饰符
	3)final,static,static final
  2.项目:
    1)将类中的所有成员添加访问控制修饰符
	2)给6个对象类添加图片属性
	3)设计窗口的宽和高为常量，适当地方做修改
第六天:
  1.知识点:
    1)抽象方法
	2)抽象类
  2.项目:
    1)画对象
第七天:
  1.知识点:
    1)成员内部类
	2)匿名内部类
  2.项目:
    1)敌人入场
	2)子弹入场
	3)飞行物移动
第八天:
  1.知识点:
    1)接口
  2.项目:
    1)英雄机随着鼠标移动
	2)删除越界的飞行物
	3)设计Enemy和Award接口，小敌机、大敌机、小蜜蜂分别实现接口
第九天:
  1.知识点:
    1)多态:意义、向上造型、强制类型转换、instanceof
  2.项目:
    1)子弹与敌人的碰撞
	2)画分和画命
第十天:
  1.知识点:
    1)内存管理:堆、栈、方法区
  2.项目:
    1)英雄机与敌人的碰撞
	2)检测游戏结束
	3)画状态

--------------------------------------day01---------------------------------
笔记:
1.什么是类？什么是对象？
  1)现实世界是由很多对象组成的
    基于对象抽出了类
  2)对象:真实存在的单个个体
    类:类型/类别，代表一类个体
  3)类中可以包含:
    3.1)所有对象所共有的属性/特征----------------成员变量
	3.2)所有对象所共有的行为---------------------方法
  4)一个类可以创建多个对象
    同一类型所创建出来的对象，结构相同，数据不同
  5)类是对象的模板，对象是类具体的实例
2.如何创建类？如何创建对象？如何访问成员？

面向过程的结构化程序设计弊端:
1)缺乏对数据的封装
2)数据与方法(操作数据)的分离

#高质量的代码:
  复用性好、扩展性好、维护性好、
  可移植性好、健壮性好、可读性好、效率好...

面向对象:OO
面向对象分析------OOA
面向对象设计------OOD
面向对象分析与设计-----OOAD
面向对象编程------OOP--------------你们所参与的

--------------------------------------day02---------------------------------
笔记:
0.方法的签名:方法名+参数列表
1.方法的重载(Overload):
  1)发生在一个类中，方法名称相同，参数列表不同
  2)编译器在编译时会根据方法的签名自动绑定调用的方法
2.构造方法:
  1)常常给成员变量赋初值
  2)与类同名，没有返回值类型
  3)在创建(new)对象时被自动调用
  4)若自己不写构造方法，则编译器默认一个无参构造方法，
    若自己写了构造方法，则不再默认提供
  5)构造方法可以重载
3.this:指代当前对象，哪个对象调用方法指的就是哪个对象
	只能用在方法中，方法中访问成员变量之前默认有个this.
  this的用法:
	1)this.成员变量名-----------------访问成员变量
	2)this.方法名()-------------------调用方法(一般不用)
	3)this()--------------------------调用构造方法
4.null:空，没有指向任何对象
	若引用的值为null，则该引用不能再进行任何操作了，
	否则会发生NullPointerException空指针异常
5.引用类型变量之间画等号:
	1)指向同一个对象
	)通过一个引用对数据的修改会影响另一个引用对数据的访问
	eg: 房子钥匙
	基本类型变量之间画等号:
	1)赋值
	2)对一个变量的修改不会影响另一个变量的值

内存管理:由JVM来管理的
1)堆:所有new出来的对象(包括成员变量)
2)栈:所有的局部变量
3)方法区:.class字节码文件(包括方法)

成员变量和局部变量是可以同名的，用时采用就近原则
成员变量和局部变量同名时，this不能省略

--------------------------------------day03---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

笔记:
1.引用类型数组:
  1)Student[] stus = new Student[3];
    stus[0] = new Student("zhangsan",25,"LF");
	stus[1] = new Student("lisi",26,"JMS");
	stus[2] = new Student("wangwu",27,"SD");
    stus[1].age = 36; //给stus中第2个元素的年龄赋值为36
  2)Student[] stus = new Student[]{
      new Student("zhangsan",25,"LF"),
      new Student("lisi",26,"JMS"),
      new Student("wangwu",27,"SD")
    };
  3)int[][] arr = new int[3][];----------数组的数组
    arr[0] = new int[2];
	arr[1] = new int[3];
	arr[2] = new int[2];
	arr[1][0] = 100; //给arr中第2个元素中的第1个元素赋值为100
  4)int[][] arr = new int[3][4];
    for(int i=0;i<arr.length;i++){
	  for(int j=0;j<arr[i].length;j++){
	    arr[i][j] = 100;
	  }
	}
2.继承:
  1)作用:代码复用
  2)通过extends来实现继承
  3)超类:所有派生类所共有的属性和行为
    派生类:派生类所特有的属性和行为
  4)派生类继承超类后，派生类具有:超类的+派生类的
  5)一个超类可以有多个派生类
    一个派生类只能有一个超类-------单一继承
  6)继承具有传递性
  7)java规定:构造派生类之前必须先构造超类
    在派生类的构造方法中若没有调用超类的构造方法
	----------则默认super()调用超类的无参构造方法
	在派生类的构造方法中若调用了超类的构造方法
	----------则不再默认提供
	super()调用超类构造方法，必须位于派生类构造的第1句
3.super:指代当前对象的超类对象
  super的用法:
    1)super.成员变量名-----------------访问超类的成员变量
	2)super.方法名()-------------------调用超类的方法(明天下午讲)
	3)super()--------------------------调用超类的构造方法


--------------------------------------day04---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

笔记:
1.向上造型:
  1)超类型的引用指向派生类对象
  2)能点出来什么，看引用的类型
2.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
  3)重写遵循"两同两小一大"原则:
	3.1)两同:
	    3.1.1)方法名相同
		3.1.2)参数列表相同
	3.2)两小:
	    3.2.1)派生类方法的返回值类型小于或等于超类方法的
		      3.2.1.1)void时，必须相等
			  3.2.1.2)基本类型时，必须相等
			  3.2.1.3)引用类型时，小于或等于
		3.2.2)派生类方法抛出的异常小于或等于超类方法的------API讲异常时
	3.3)一大:
	    3.3.1)派生类方法的访问权限大于或等于超类方法的------明天讲
3.重写与重载的区别:---------常见面试题
  1)重写:
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)遵循"运行期绑定"，看对象的类型来调用方法
  2)重载:
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)遵循"编译期绑定"，看引用/参数的类型来绑定方法

swing相关:
1)JFrame:框架(相框)
2)JPanel:面板(相板)


--------------------------------------day05---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

笔记:
1.package:
  1)作用:避免类名冲突
  2)包名可以有层次结构
  3)类的全称为: 包名.类名
  4)建议:包名所有字母都小写
  import:
  1)同包中的类可以直接访问，
    不同包中的类不能直接访问，想访问只有如下两种方式:
	1.1)先import声明类再使用类----建议
	1.2)类的全称------------------太繁琐，不建议
2.访问控制修饰符:
  1)public:公开的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
  说明:
    1)类的访问修饰只能是public和默认的
	2)类中成员的访问修饰如上四种都可以
3.final:最终的、不可改变的---------------应用率低
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
4.static:静态的
  1)静态变量:
    1.1)由static修饰
	1.2)属于类，存储在方法区中，只有一份
	1.3)常常通过类名点来访问
	1.4)何时用:所有对象所共享的数据(图片、音频、视频等)
  2)静态方法:
    2.1)由static修饰
	2.2)属于类，存储在方法区中，只有一份
	2.3)常常通过类名点来访问
	2.4)静态方法中没有隐式的this传递，
	    静态方法中不能直接访问实例成员
	2.5)何时用:方法的操作仅与参数相关而与对象无关
  3)静态块:
    3.1)属于类，在类被加载期间自动执行，
	    因类只加载一次，所以静态块也只执行一次
	3.2)何时用:加载/初始化静态资源(图片、音频、视频等)
5.static final常量:------今天自学，明天讲

成员变量:
1)实例变量:没有static，属于对象的，存储在堆中，
           通过对象名点来访问
2)静态变量:由static修饰，属于类的，存储在方法区中，
           只有一份 通过类名点来访问

堆:new出来的对象(包括实例变量)
栈:局部变量
方法区:.class字节码文件(包括方法、静态变量)

建议:
  域名反写   . 项目名称 . 模块名称        . 类名
  cn.tedu    . aproject . stumanager      .
  cn.tedu    . aproject . teachermanager  .


--------------------------------------day06---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

Shoot射击游戏第六天:
1.画对象:
  1)想画对象，得先去获取对象的图片，
    每个对象都得获取图片，意味着获取图片行为为共有的行为，
	  所以需要将获取图片的行为设计在FlyingObject超类中，
    每个对象获取图片的行为都是不一样的，
      所以获取图片的行为设计为抽象方法
	--------在FlyingObject类中设计抽象方法getImage()
  2)在获取对象的图片时，需要去考虑对象的状态(生命周期)，
    状态分三种(活着的、死了的(未删除)、删除的)，
	在实际应用中，状态都应设计为常量，
	每个对象都有状态，所以将状态设计在FlyingObject超类中，
	--------在FlyingObject类中设计三个常量和变量(存储当前状态)
    在获取图片时，需要去判断每个对象的状态，用于获取不同的图片，
	所以对象状态判断的行为为共有的行为，设计在FlyingObject超类中，
	每个对象判断状态的行为都是一样的，设计为普通方法
	--------在FlyingObject类中设计isLife()/isDead()/isRemove()
  3)在派生类中重写getImage()用于在不同状态下获取不同的图片
    3.1)Sky天空，直接返回image
	3.2)Bullet子弹:
	    3.2.1)若活着的，直接返回image
		3.2.2)若死了的，就删除
    3.3)Airplane小敌机:
        3.3.1)若活着呢，返回第1张图片
        3.3.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.4)Airplane小敌机:
        3.4.1)若活着呢，返回第1张图片
        3.4.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
	3.5)Airplane小敌机:
        3.5.1)若活着呢，返回第1张图片
        3.5.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.6)Hero英雄机:
	    3.6.1)若活着呢，返回2张图片的切换
  4)图片有了，就可以开画了，6个对象都可开画，属于共有的行为，
      所以将画的行为设计在FlyingObject超类中，
	所有对象画的行为都是一样的，所以设计为普通方法
	--------在FlyingObject超类中设计普通方法paintObject()画对象
  5)因为Sky天空是两张图，所以需要重写超类的paintObject()
    --------在Sky类中重写paintObject()
  6)画的行为完以后，只需要在窗口上调用即可
    --------在World类中重写paint()，而后调用paintObject()

正课:
1.static final常量:
  1)必须声明同时初始化
  2)通过类名点来访问，不能被改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时将常量直接替换为具体的值，效率高
  5)何时用:数据永远不变，并且经常使用
2.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有具体的实现(连{}都没有)
3.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类-------我乐意
  3)抽象类不能被实例化
  4)抽象类都是需要被继承的，派生类:
    4.1)重写抽象类中的所有抽象方法-----变不完整为完整
	4.2)也声明为抽象类-----------------一般不这么做
  5)抽象类的意义:
    5.1)封装派生类所共有的属性和行为-----------代码复用
	5.2)为所有派生类提供统一的类型-------------向上造型
	5.3)可以包含抽象方法，为所有派生类提供统一的入口
	    派生类的具体实现不同，但入口是一致的

设计规则:
1)将所有派生类所共有的属性和行为，抽到超类中-------抽共性
2)所有派生类的行为都一样，设计为普通方法
  所有派生类的行为都不一样，设计为抽象方法


--------------------------------------day07---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

Shoot射击游戏第六天:
1.画对象:
  1)想画对象，得先去获取对象的图片，
    每个对象都得获取图片，意味着获取图片行为为共有的行为，
	  所以需要将获取图片的行为设计在FlyingObject超类中，
    每个对象获取图片的行为都是不一样的，
      所以获取图片的行为设计为抽象方法
	--------在FlyingObject类中设计抽象方法getImage()
  2)在获取对象的图片时，需要去考虑对象的状态(生命周期)，
    状态分三种(活着的、死了的(未删除)、删除的)，
	在实际应用中，状态都应设计为常量，
	每个对象都有状态，所以将状态设计在FlyingObject超类中，
	--------在FlyingObject类中设计三个常量和变量(存储当前状态)
    在获取图片时，需要去判断每个对象的状态，用于获取不同的图片，
	所以对象状态判断的行为为共有的行为，设计在FlyingObject超类中，
	每个对象判断状态的行为都是一样的，设计为普通方法
	--------在FlyingObject类中设计isLife()/isDead()/isRemove()
  3)在派生类中重写getImage()用于在不同状态下获取不同的图片
    3.1)Sky天空，直接返回image
	3.2)Bullet子弹:
	    3.2.1)若活着的，直接返回image
		3.2.2)若死了的，就删除
    3.3)Airplane小敌机:
        3.3.1)若活着呢，返回第1张图片
        3.3.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.4)Airplane小敌机:
        3.4.1)若活着呢，返回第1张图片
        3.4.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
	3.5)Airplane小敌机:
        3.5.1)若活着呢，返回第1张图片
        3.5.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.6)Hero英雄机:
	    3.6.1)若活着呢，返回2张图片的切换
  4)图片有了，就可以开画了，6个对象都可开画，属于共有的行为，
      所以将画的行为设计在FlyingObject超类中，
	所有对象画的行为都是一样的，所以设计为普通方法
	--------在FlyingObject超类中设计普通方法paintObject()画对象
  5)因为Sky天空是两张图，所以需要重写超类的paintObject()
    --------在Sky类中重写paintObject()
  6)画的行为完以后，只需要在窗口上调用即可
    --------在World类中重写paint()，而后调用paintObject()

Shoot射击游戏第七天:
1.敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，在run()中调用enterAction()实现敌人入场
    在enterAction()中:
	  每400毫秒调用nextOne()获取敌人，enemies扩容，装在最后一个元素上
2.子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，在run()中调用shootAction()实现子弹入场
    在shootAction()中:
	  每300毫秒调用hero的shoot()获取子弹，bullets扩容，数组追加
3.飞行物移动:
  1)移动是所有对象所共有的行为，并且每个对象移动的形为都是不一样的，
    所以在超类FlyingObject中设计了抽象方法step()，派生类重写step()
  2)飞行物移动为定时发生的，在run()中调用stepAction()实现飞行物移动
    在stepAction()中:
	  天空动，遍历敌人而后敌人动，遍历子弹而后子弹动

正课:
1.成员内部类: 应用率低
  1)类中套类，里面的称为Inner内部类，外面的称为Outer外部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类通常是在外部类中创建的
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有一个隐式的引用指向了创建它的外部类对象
      eg: 外部类名.this.
2.匿名内部类:
  1)若想创建一个类的对象，并且对象只被创建一次，
    此时该类不必命名，称之为匿名内部类
  2)jdk1.7(含)版本之前，匿名内部类中想访问外面的变量，
    要求该变量必须是final的

常见面试题:
  问:内部类有独立的.class吗?
  答:有


功能实现步骤:
1.先写行为(方法):
  1)若是某个对象特有的行为，则将行为设计在派生类中
    若是所有对象共有的行为，则将行为设计在超类中
	1.1)所有派生类行为都一样，设计为普通方法
	1.2)所有派生类行为都不一样，设计为抽象方法，而后派生类重写
2.窗口调用:
  1)定时触发的，在run()中调用
  2)事件触发的，在侦听器中调用
  3)画出来的，在paint()中调用


--------------------------------------day08---------------------------------

Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

Shoot射击游戏第六天:
1.画对象:
  1)想画对象，得先去获取对象的图片，
    每个对象都得获取图片，意味着获取图片行为为共有的行为，
	  所以需要将获取图片的行为设计在FlyingObject超类中，
    每个对象获取图片的行为都是不一样的，
      所以获取图片的行为设计为抽象方法
	--------在FlyingObject类中设计抽象方法getImage()
  2)在获取对象的图片时，需要去考虑对象的状态(生命周期)，
    状态分三种(活着的、死了的(未删除)、删除的)，
	在实际应用中，状态都应设计为常量，
	每个对象都有状态，所以将状态设计在FlyingObject超类中，
	--------在FlyingObject类中设计三个常量和变量(存储当前状态)
    在获取图片时，需要去判断每个对象的状态，用于获取不同的图片，
	所以对象状态判断的行为为共有的行为，设计在FlyingObject超类中，
	每个对象判断状态的行为都是一样的，设计为普通方法
	--------在FlyingObject类中设计isLife()/isDead()/isRemove()
  3)在派生类中重写getImage()用于在不同状态下获取不同的图片
    3.1)Sky天空，直接返回image
	3.2)Bullet子弹:
	    3.2.1)若活着的，直接返回image
		3.2.2)若死了的，就删除
    3.3)Airplane小敌机:
        3.3.1)若活着呢，返回第1张图片
        3.3.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.4)Airplane小敌机:
        3.4.1)若活着呢，返回第1张图片
        3.4.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
	3.5)Airplane小敌机:
        3.5.1)若活着呢，返回第1张图片
        3.5.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.6)Hero英雄机:
	    3.6.1)若活着呢，返回2张图片的切换
  4)图片有了，就可以开画了，6个对象都可开画，属于共有的行为，
      所以将画的行为设计在FlyingObject超类中，
	所有对象画的行为都是一样的，所以设计为普通方法
	--------在FlyingObject超类中设计普通方法paintObject()画对象
  5)因为Sky天空是两张图，所以需要重写超类的paintObject()
    --------在Sky类中重写paintObject()
  6)画的行为完以后，只需要在窗口上调用即可
    --------在World类中重写paint()，而后调用paintObject()

Shoot射击游戏第七天:
1.敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，在run()中调用enterAction()实现敌人入场
    在enterAction()中:
	  每400毫秒调用nextOne()获取敌人，enemies扩容，装在最后一个元素上
2.子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，在run()中调用shootAction()实现子弹入场
    在shootAction()中:
	  每300毫秒调用hero的shoot()获取子弹，bullets扩容，数组追加
3.飞行物移动:
  1)移动是所有对象所共有的行为，并且每个对象移动的形为都是不一样的，
    所以在超类FlyingObject中设计了抽象方法step()，派生类重写step()
  2)飞行物移动为定时发生的，在run()中调用stepAction()实现飞行物移动
    在stepAction()中:
	  天空动，遍历敌人而后敌人动，遍历子弹而后子弹动

Shoot射击游戏第八天:
1.英雄机随着鼠标移动:
  1)英雄机移动是英雄机的行为，所以在Hero中设计moveTo(x,y)实现英雄机随着鼠标移动
  2)英雄机随着鼠标移动是事件触发的，在侦听器中重写mouseMoved()鼠标移动事件
    在mouseMoved()中:
	  获取鼠标的x和y坐标，而后英雄机随着动
2.删除越界的飞行物:
  1)越界检查为所有飞行物都具备的行为，只是每个对象的具体行为不一样，
    在超类FlyingObject中设计抽象方法outOfBounds()，6个派生类中分别重写
  2)删除越界飞行物为定时发生的，所以在run()中调用outOfBoundsAction()
    在outOfBoundsAction()中:
	  声明不越界敌人/子弹数组，遍历enemies/bullets，获取每个敌人或子弹
	  判断若不越界，则将对象添加到不越界敌人/子弹数组中，
	  将不越界敌人/子弹数组复制到enemies/bullets中
3.设计Enemy得分接口，而后Airplane和BigAirplane实现接口
  设计Award奖励接口，而后Bee实现接口

笔记:
1.接口:
  1)是一种数据类型(引用类型)
  2)由interface定义的
  3)只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现/继承的，实现类/派生类:
       必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，应先继承后实现
  7)接口可以继承接口


设计规则:
1)将所有派生类所共有的属性和行为，抽到超类中---------抽共性
2)所有派生类的行为都一样，设计为普通方法
  所有派生类的行为都不一样，设计为抽象方法
3)将部分派生类所共有的行为，抽到接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展-------------实现多继承


类和类-------------------继承extends
接口和接口---------------继承extends
类和接口-----------------实现implements


--------------------------------------day09---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

Shoot射击游戏第六天:
1.画对象:
  1)想画对象，得先去获取对象的图片，
    每个对象都得获取图片，意味着获取图片行为为共有的行为，
	  所以需要将获取图片的行为设计在FlyingObject超类中，
    每个对象获取图片的行为都是不一样的，
      所以获取图片的行为设计为抽象方法
	--------在FlyingObject类中设计抽象方法getImage()
  2)在获取对象的图片时，需要去考虑对象的状态(生命周期)，
    状态分三种(活着的、死了的(未删除)、删除的)，
	在实际应用中，状态都应设计为常量，
	每个对象都有状态，所以将状态设计在FlyingObject超类中，
	--------在FlyingObject类中设计三个常量和变量(存储当前状态)
    在获取图片时，需要去判断每个对象的状态，用于获取不同的图片，
	所以对象状态判断的行为为共有的行为，设计在FlyingObject超类中，
	每个对象判断状态的行为都是一样的，设计为普通方法
	--------在FlyingObject类中设计isLife()/isDead()/isRemove()
  3)在派生类中重写getImage()用于在不同状态下获取不同的图片
    3.1)Sky天空，直接返回image
	3.2)Bullet子弹:
	    3.2.1)若活着的，直接返回image
		3.2.2)若死了的，就删除
    3.3)Airplane小敌机:
        3.3.1)若活着呢，返回第1张图片
        3.3.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.4)Airplane小敌机:
        3.4.1)若活着呢，返回第1张图片
        3.4.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
	3.5)Airplane小敌机:
        3.5.1)若活着呢，返回第1张图片
        3.5.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.6)Hero英雄机:
	    3.6.1)若活着呢，返回2张图片的切换
  4)图片有了，就可以开画了，6个对象都可开画，属于共有的行为，
      所以将画的行为设计在FlyingObject超类中，
	所有对象画的行为都是一样的，所以设计为普通方法
	--------在FlyingObject超类中设计普通方法paintObject()画对象
  5)因为Sky天空是两张图，所以需要重写超类的paintObject()
    --------在Sky类中重写paintObject()
  6)画的行为完以后，只需要在窗口上调用即可
    --------在World类中重写paint()，而后调用paintObject()

Shoot射击游戏第七天:
1.敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，在run()中调用enterAction()实现敌人入场
    在enterAction()中:
	  每400毫秒调用nextOne()获取敌人，enemies扩容，装在最后一个元素上
2.子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，在run()中调用shootAction()实现子弹入场
    在shootAction()中:
	  每300毫秒调用hero的shoot()获取子弹，bullets扩容，数组追加
3.飞行物移动:
  1)移动是所有对象所共有的行为，并且每个对象移动的形为都是不一样的，
    所以在超类FlyingObject中设计了抽象方法step()，派生类重写step()
  2)飞行物移动为定时发生的，在run()中调用stepAction()实现飞行物移动
    在stepAction()中:
	  天空动，遍历敌人而后敌人动，遍历子弹而后子弹动

Shoot射击游戏第八天:
1.英雄机随着鼠标移动:
  1)英雄机移动是英雄机的行为，所以在Hero中设计moveTo(x,y)实现英雄机随着鼠标移动
  2)英雄机随着鼠标移动是事件触发的，在侦听器中重写mouseMoved()鼠标移动事件
    在mouseMoved()中:
	  获取鼠标的x和y坐标，而后英雄机随着动
2.删除越界的飞行物:
  1)越界检查为所有飞行物都具备的行为，只是每个对象的具体行为不一样，
    在超类FlyingObject中设计抽象方法outOfBounds()，6个派生类中分别重写
  2)删除越界飞行物为定时发生的，所以在run()中调用outOfBoundsAction()
    在outOfBoundsAction()中:
	  声明不越界敌人/子弹数组，遍历enemies/bullets，获取每个敌人或子弹
	  判断若不越界，则将对象添加到不越界敌人/子弹数组中，
	  将不越界敌人/子弹数组复制到enemies/bullets中
3.设计Enemy得分接口，而后Airplane和BigAirplane实现接口
  设计Award奖励接口，而后Bee实现接口

Shoot射击游戏第九天:
1.子弹与敌人的碰撞:
  1)在超类FlyingObject中设计hit()实现敌人与子弹/英雄机的碰撞
    在超类FlyingObject中设计goDead()实现飞行物去死
	在Hero类中设计addLife()增命、addDoubleFire()增火力
  2)子弹与敌人的碰撞为定时发生的，所以在run()中调用bulletBangAction()实现子弹与敌人的碰撞
    在bulletBangAction()中:
	  遍历所有子弹，获取每个子弹，遍历所有敌人，获取每个敌人，
	  判断是否撞上了，若撞上了则:
	    2.1)子弹去死、敌人去死
		2.2)若撞了小敌机和大敌机，则玩家得分
		    若撞了小蜜蜂，则英雄机得奖励
2.画分和画命:
  1)在Hero类中设计getLife()获取命
  2)在paint()方法中，画分和画命


笔记:
1.多态:
  1)意义:
    1.1)同一类型的引用指向不同的对象时，有不同的实现
	    --------行为的多态:cut()、run()、step()...
	1.2)同一个对象被造型为不同的类型时，有不同的功能
	    --------对象的多态:我、你、水...
  2)向上造型/自动类型转换:
    2.1)超类型的引用指向派生类的对象
	2.2)能造型成为的类型有:超类+所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件只有如下两种:
    3.1)引用所指向的对象就是该类型
	3.2)引用所指向的对象实现了该接口/继承了该类
  4)强转若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议:强转之前先通过instanceof来判断引用所指向的对象是否是该类型


--------------------------------------day10---------------------------------
Shoot射击游戏第一天:
1.创建6个对象类，并创建World类测试

Shoot射击游戏第二天:
1.创建了6个对象类的构造方法，在World类中测试

Shoot射击游戏第三天:
1.设计小敌机数组、大敌机数组、小蜜蜂数组、子弹数组，并测试
2.设计FlyingObject超类，6个对象类继承超类
3.给FlyingObject超类设计了两个构造方法，6个派生类中分别调用

Shoot射击游戏第四天:
1.将小敌机数组、大敌机数组、小蜜蜂数组合为FlyingObject数组
2.在6个派生类中重写step()
3.画窗口

Shoot射击游戏第五天:
1.将类中的成员添加访问控制修饰符
2.设置图片属性

Shoot射击游戏第六天:
1.画对象:
  1)想画对象，得先去获取对象的图片，
    每个对象都得获取图片，意味着获取图片行为为共有的行为，
	  所以需要将获取图片的行为设计在FlyingObject超类中，
    每个对象获取图片的行为都是不一样的，
      所以获取图片的行为设计为抽象方法
	--------在FlyingObject类中设计抽象方法getImage()
  2)在获取对象的图片时，需要去考虑对象的状态(生命周期)，
    状态分三种(活着的、死了的(未删除)、删除的)，
	在实际应用中，状态都应设计为常量，
	每个对象都有状态，所以将状态设计在FlyingObject超类中，
	--------在FlyingObject类中设计三个常量和变量(存储当前状态)
    在获取图片时，需要去判断每个对象的状态，用于获取不同的图片，
	所以对象状态判断的行为为共有的行为，设计在FlyingObject超类中，
	每个对象判断状态的行为都是一样的，设计为普通方法
	--------在FlyingObject类中设计isLife()/isDead()/isRemove()
  3)在派生类中重写getImage()用于在不同状态下获取不同的图片
    3.1)Sky天空，直接返回image
	3.2)Bullet子弹:
	    3.2.1)若活着的，直接返回image
		3.2.2)若死了的，就删除
    3.3)Airplane小敌机:
        3.3.1)若活着呢，返回第1张图片
        3.3.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.4)Airplane小敌机:
        3.4.1)若活着呢，返回第1张图片
        3.4.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
	3.5)Airplane小敌机:
        3.5.1)若活着呢，返回第1张图片
        3.5.2)若死了呢，从第2张图到第5张图轮换，第5张图后可以删除了
    3.6)Hero英雄机:
	    3.6.1)若活着呢，返回2张图片的切换
  4)图片有了，就可以开画了，6个对象都可开画，属于共有的行为，
      所以将画的行为设计在FlyingObject超类中，
	所有对象画的行为都是一样的，所以设计为普通方法
	--------在FlyingObject超类中设计普通方法paintObject()画对象
  5)因为Sky天空是两张图，所以需要重写超类的paintObject()
    --------在Sky类中重写paintObject()
  6)画的行为完以后，只需要在窗口上调用即可
    --------在World类中重写paint()，而后调用paintObject()

Shoot射击游戏第七天:
1.敌人入场:
  1)敌人是由窗口产生的，所以在World中设计nextOne()生成敌人对象
  2)敌人入场为定时发生的，在run()中调用enterAction()实现敌人入场
    在enterAction()中:
	  每400毫秒调用nextOne()获取敌人，enemies扩容，装在最后一个元素上
2.子弹入场:
  1)子弹是由英雄机发射出来的，所以在Hero中设计shoot()生成子弹对象
  2)子弹入场为定时发生的，在run()中调用shootAction()实现子弹入场
    在shootAction()中:
	  每300毫秒调用hero的shoot()获取子弹，bullets扩容，数组追加
3.飞行物移动:
  1)移动是所有对象所共有的行为，并且每个对象移动的形为都是不一样的，
    所以在超类FlyingObject中设计了抽象方法step()，派生类重写step()
  2)飞行物移动为定时发生的，在run()中调用stepAction()实现飞行物移动
    在stepAction()中:
	  天空动，遍历敌人而后敌人动，遍历子弹而后子弹动

Shoot射击游戏第八天:
1.英雄机随着鼠标移动:
  1)英雄机移动是英雄机的行为，所以在Hero中设计moveTo(x,y)实现英雄机随着鼠标移动
  2)英雄机随着鼠标移动是事件触发的，在侦听器中重写mouseMoved()鼠标移动事件
    在mouseMoved()中:
	  获取鼠标的x和y坐标，而后英雄机随着动
2.删除越界的飞行物:
  1)越界检查为所有飞行物都具备的行为，只是每个对象的具体行为不一样，
    在超类FlyingObject中设计抽象方法outOfBounds()，6个派生类中分别重写
  2)删除越界飞行物为定时发生的，所以在run()中调用outOfBoundsAction()
    在outOfBoundsAction()中:
	  声明不越界敌人/子弹数组，遍历enemies/bullets，获取每个敌人或子弹
	  判断若不越界，则将对象添加到不越界敌人/子弹数组中，
	  将不越界敌人/子弹数组复制到enemies/bullets中
3.设计Enemy得分接口，而后Airplane和BigAirplane实现接口
  设计Award奖励接口，而后Bee实现接口

Shoot射击游戏第九天:
1.子弹与敌人的碰撞:
  1)在超类FlyingObject中设计hit()实现敌人与子弹/英雄机的碰撞
    在超类FlyingObject中设计goDead()实现飞行物去死
	在Hero类中设计addLife()增命、addDoubleFire()增火力
  2)子弹与敌人的碰撞为定时发生的，所以在run()中调用bulletBangAction()实现子弹与敌人的碰撞
    在bulletBangAction()中:
	  遍历所有子弹，获取每个子弹，遍历所有敌人，获取每个敌人，
	  判断是否撞上了，若撞上了则:
	    2.1)子弹去死、敌人去死
		2.2)若撞了小敌机和大敌机，则玩家得分
		    若撞了小蜜蜂，则英雄机得奖励
2.画分和画命:
  1)在Hero类中设计getLife()获取命
  2)在paint()方法中，画分和画命

Shoot射击游戏第九天:
1.英雄机与敌人的碰撞:
  1)借用FlyingObject中的hit()碰撞行为
    借用FlyingObject中的goDead()去死行为
	在Hero中设计subtractLife()减命、clearDoubleFire()清空火力值
  2)因为英雄机与敌人碰撞为定时发生的，所以在run()中调用heroBangAction()实现碰撞
    在heroBangAction()中:
	  遍历所有敌人，获取每个敌人，判断是否与英雄机撞上了，
      若撞上了: 敌人去死、英雄机减命、英雄机清空火力值
2.检测游戏结束:
  1)借用Hero的getLife()获取命
  2)因为检测游戏结束为定时发生的，所以在run()中调用checkGameOver()实现检测结束
    在checkGameOverAction()中:
	  判断英雄机的命数是否<=0，若为true则...
3.画状态:
  1)设计了四个状态常量，当前状态state变量
    设计了三个静态图片，在static块中初始化
  2)在paint()中设计在不同状态下画不同的图片
  3)将一堆action()设计为仅在运行状态下执行
    将英雄机随着鼠标动设计为仅在运行状态下执行
  4)重写mouseClicked()鼠标点击事件
    重写mouseExited()鼠标点击事件
	重写mouseEntered()鼠标点击事件


正课:
1.内存管理:由JVM来管理
  1)堆:
	1.1)存储new出来的对象(包括实例变量)
	1.2)垃圾:没有任何引用所指向的对象，
	    垃圾回收器(GC)不定时到内存中清扫垃圾，
        回收过程是透明的(看不到的)，不一定一发现垃圾就立刻回收，
		调用System.gc()可以建议虚拟机尽快调度GC来回收垃圾
	1.3)实例变量的生命周期:
	      创建对象时存在堆中，对象被回收时一并被回收
	1.4)内存泄漏:不再使用的对象还没有被及时的回收
	    建议:不再使用的对象及时将引用设置为null
  2)栈:
	2.1)正在调用的方法中的局部变量(包括方法的参数)
	2.2)调用方法时，在栈中为该方法分配一块对应的栈帧，
		栈帧中存储方法中的局部变量(包括方法的参数)，
		方法调用结束时，栈帧被清除，局部变量一并被清除
	2.3)局部变量的生命周期:
		方法调用时存储在栈中，方法结束时与栈帧一并被清除
  3)方法区:
	3.1)存储.class字节码文件(包括方法、静态变量)
	3.2)方法只有一份，通过this来区分具体的访问对象

设计规则:
1)将所有派生类所共有的属性和行为，抽到超类中-------抽共性
2)所有派生类的行为都一样，设计为普通方法
  所有派生类的行为都不一样，设计为抽象方法
3)将部分派生类所共有的行为，抽到接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展------------多继承

面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性的行为
  2)方法:封装一段特定的业务逻辑功能
  3)访问控制修饰符:封装的是具体的访问权限
2.继承:
  1)作用:代码复用
  2)超类:所有派生类所共有的属性和行为
    接口:部分派生类所共有的行为
	派生类:派生类所特有的属性和行为
  3)单一继承、多接口实现，传递性
3.多态:
  1)行为多态(所有抽象方法都是多态的)
    对象多态(所有对象都是多态的)
  2)向上造型、强制类型转换、instanceof
  3)多态的表现形式:
    3.1)重写:根据对象的不同来多态
	3.2)重载:根据参数的不同来多态

1.何时用:当程序的运行结果与你的预期不同时，需要调试
2.调试方式:
  1)打桩: System.out.println(数据);
  2)Debug调试工具:
    2.0)添加断点
    2.1)四个键:
	    2.1.1)F5:单步调试(会进入到方法中)
		2.1.2)F6:逐过程调试(不会进入到方法中)
		2.1.3)F7:结束方法的调试(从方法中返回)
		2.1.4)F8:直接跳到下一个断点(若后面无断点则结束调试)
	2.2)会看两个东西:
	    2.2.1)会看变量
		2.2.2)添加监视

#=========================Reflect==================================
# 反射
1. Java 提供了一套API
2. 提供了检查一个对象内部结构的手段
3. 反射API可以:
	1. 动态加载类, 
	2. 动态创建对象, 
	3. 动态访问属性, 
	4. 动态调用方法
> 反射API提供了"动态"执行功能!
	Foo foo = new Foo();
	foo.print();
## 反射检查对象的类型和类的内部结构
检查对象类型的方法:
	Class cls = obj.getClass();
	//返回值 cls 代表对象的类型.
	public void test(Object obj){
		// obj 是什么具体类型的?
		Class cls = obj.getClass();
		System.out.println(cls);
	}
检查类型的内部结构:
	//检查对象的类型中声明了哪些属性
	// Declared: 声明的(定义的)
	// Field : 字段,属性
	/*
	 * 动态获取cls代表的类型中声明的属性
	 * Field 类型来自反射包 java.lang.reflect
	 * 代表一个类中声明的属性信息
	 */
	Field[] fields = cls.getDeclaredFields();
	for (Field field : fields) {
		System.out.println(field); 
	}
	// Method: 方法
	// Method 来自reflect包, 代表cls中声明
	// 方法信息.
	Method[] methods = cls.getDeclaredMethods();
	for (Method method : methods) {
		System.out.println(method); 
	}
	//获取类中声明的全部构造器信息
	//Constructor 构造器/构造方法
	Constructor[] constructors= cls.getDeclaredConstructors();
	for(Constructor c:constructors){
		System.out.println(c); 
	}

## 动态加载类
API方法:Class cls = Class.forName(类名);
原理为:
![](imgs/forName.png)
案例:
	/* 动态加载类到内存中 */
	Scanner in = new Scanner(System.in);
	System.out.print("输入类名:");
	String className = in.nextLine();
	//动态加载类,当类名错误时候,会抛出类没有找到的异常
	Class cls = Class.forName(className);
	System.out.println(cls); 
	//可以继续检查cls的内部结构...
案例: 类只加载一次,forName返回值是同一个对象的引用
	
## 动态创建对象
API 方法
	Object obj=cls.newInstance();
	//Instance 实例(对象)
	// 创建cls代表的类型的实例
	// cls 类型上必须包含无参数构造器(可以是默认构造器)
	// newInstance就是调用这个无参数构造器创建对象!
	// 如果没有无参数构造器则抛出异常!

> 可以利用Constructor调用有参数构造器创建对象, 因为使用少, 这里省略了. 
![](imgs/1.png)
案例:
	public static void main(String[] args)
			throws Exception{
		/*
		 * 动态加载类到内存中
		 */
		Scanner in = new Scanner(System.in);
		System.out.print("输入类名:");
		String className=in.nextLine();
		//动态加载类
		//当类名错误时候,会抛出类没有找到的异常
		Class cls=Class.forName(className);
		System.out.println(cls); 
		//可以继续检查cls的内部结构...
		
		//利用反射API动态创建对象
		Object obj = cls.newInstance();
		System.out.println(obj); 
	}

## 动态访问属性
API 方法	
在 Field 类型上定义了get方法, 可以用于获取对象的属性值
如果需要动态获取属性的值:

- 利用Class类型对象的方法,才能获取Field类型对象
	- obj.getClass();
	- Class.forName();
- 获取Field类型对象
- 获得对象
	- new 一个对象
	- newInstance 创建对象
- 调用get方法
		Object val = fld.get(obj)
		//在对象obj上读取属性
案例:

	public static void main(String[] args)
		throws Exception{
		/*
		 * 动态访问对象的属性
		 */
		Scanner in = new Scanner(System.in);
		System.out.print("输入类名:");// Koo
		String className=in.nextLine();
		System.out.print("输入属性名:");// name
		String fieldName=in.nextLine();
		//加载类
		Class cls=Class.forName(className);
		//查找类中的属性(API 方法)
		// getDeclaredFields 获取全部属性
		// getDeclaredField(name) 获取指定名字的
		//                       一个属性
		Field fld=cls.getDeclaredField(fieldName);
		System.out.println(fld);
		//动态创建对象, obj 一定包含指定属性值
		// Koo koo = new Koo();
		Object obj = cls.newInstance();
		//在obj对象上获取fld属性的值, 如果obj上
		// 没有fld属性的值, 则抛出异常
		
		//Access 访问 Accessible 可以访问的
		fld.setAccessible(true);
		
		Object val = fld.get(obj);
		//属性名是用户运行期间输入的! 输入那个属性
		//名这段程序就会输出那个属性的值! 
		//也就意味着, 程序与属性之间是松耦合的关系
		System.out.println(val);
	}

## 利用反射API可以访问不可见成员
无论私有属性还是私有方法, 都可以利用反射API进行调用, 在调用之前使用 fld.setAccessible(true);

fld.setAccessible(true) 执行以后可以打开原有私有的访问权限.
不仅仅如此, fld.setAccessible(true) 还可以打开任何不可见属性/方法的访问权限.

案例:

	public static void main(String[] args)
		throws Exception{
		/*
		 *　访问私有属性
		 */
		Scanner in = new Scanner(System.in);
		System.out.print("输入类名:");// Koo
		String className=in.nextLine();
		System.out.print("输入属性名:");// name
		String fieldName=in.nextLine();
		//加载类
		Class cls=Class.forName(className);
		//查找类中的属性(API 方法)
		// getDeclaredFields 获取全部属性
		// getDeclaredField(name) 获取指定名字的
		//                       一个属性
		Field fld=cls.getDeclaredField(fieldName);
		System.out.println(fld);
		//动态创建对象, obj 一定包含指定属性值
		// Koo koo = new Koo();
		Object obj = cls.newInstance();
		//在obj对象上获取fld属性的值, 如果obj上
		// 没有fld属性的值, 则抛出异常
		
		//Access 访问 Accessible 可以访问的
		fld.setAccessible(true);
		
		Object val = fld.get(obj);
		//属性名是用户运行期间输入的! 输入那个属性
		//名这段程序就会输出那个属性的值! 
		//也就意味着, 程序与属性之间是松耦合的关系
		System.out.println(val);
	}

## 反射的用途
解耦!
利用反射可以实现一段程序与未来一个类之间耦合在一起, 这段程序就与未来的类之间是松耦合的关系-- 也就是解耦了! 
如: Eclipse 可以开发任何未来的程序, 解析任何未来程序的结构.

经典面试题目: 
	Eclipse 的快捷菜单用到了哪些技术?
	答: Eclipse利用反射技术实现快捷菜单, 可以使Eclipse与被开发的类解耦.

## 利用反射访问对象的方法
访问方法的核心API
	// invoke 调用 
	// obj是包含当前method方法的对象
	method.invoke(obj, 参数1, 参数2 ...)
使用步骤:
- 获得Class对象
	- Class.forName(类名)
- 利用Class对象的方法找到 Method 对象
	- Method getDeclaredMethod(方法名) 根据方法名找到Method对象
- 获得方法对象 method
- 得到包含方法的对象obj
	- cls.newInstance()
- 准备参数(选项)
		Object val = method.invoke(obj)
案例:
	public static void main(String[] args) 
		throws Exception{
		/*
		 * 利用反射API动态执行对象的方法 
		 */
		Scanner in = new Scanner(System.in);
		System.out.print("输入类型:");
		String className=in.nextLine();
		System.out.print("输入方法名:");
		String methodName=in.nextLine();
		//动态加载类
		Class cls=Class.forName(className);
		//在类cls中找到需要执行的methodName方法
		//如果方法名错误,将抛出没有找到方法异常
		Method method=
		  cls.getDeclaredMethod(methodName);
		System.out.println(method);
		//执行invoke时候, obj对象一定是包含
		//指定method的对象! 否则将出现异常
		Object obj = cls.newInstance();
		//动态调用方法
		method.setAccessible(true); 
		Object value = method.invoke(obj);
		//输出方法的返回值
		System.out.println(value);
	}
## getDeclaredMethod 与 getMethod
cls.getDeclaredMethod 在当前cls类型上查找当前类中声明的全部方法
	- getDeclaredMethod 只查询当前类
cls.getMethod 在当前cls类型以及全部继承的方法中查找声明的方法
	- 查询当前类和父类中继承的方法
 
## 反射总结
1. Java的"动态"执行 API
	- 动态加载类
	- 动态创建对象
	- 动态访问属性
	- 动态执行方法
2. 可以用于实现软件组件的"解耦"
	- 可以实现现在组件和未来的组件耦合关系, 调用未来的程序组件
例子: 
	Eclipse 的快捷菜单使用反射技术
	WebServer与未来的Servlet组件的耦合也是使用反射技术
重点掌握方法:
1. Class.forName(类名)
2. Method.invoke(obj)
3. Class.newInstance()
4. setAccessible(true)

#=========================Webbasic_day01===================================
#day01
## 李然 g-liran@tedu.cn
###Lunix----markdown, Windows---

##	java知识体系
### 前端:
	HTML--用来勾勒出网页的结构和内容--骨架
	CSS--样式表--用来美化网页-(美颜)
	JavaScript<-->jQuery框架

### 服务器webServer:
	servlet<-->SpringMVC框架,Struts2(大多被淘汰了)
	java基础,javaSE<-->Spring框架
	JDBC<-->MyBatis框架,Hibernate框架
	
	之前是SSH:Spring,Struts2,Hibernate框架
	现在是SSM:Spring.SpringMVC,MyBatis框架
### 数据库:
    sql

### 流程:
1. HTML css js jq
2. Mysql JDBC
3. servlet
4. SSM


## 前端课程介绍
1. HTML--用来勾勒出网页的结构和内容--骨架 1.5
2. CSS--样式表--用来美化网页-(美颜-整容的效果) 3.5
3. JavaScript--让网页呈现出动态的数据和效果 5
4. jQuery-是JS的框架,提高JavaScript的开发效率 2-3

## 浏览器内核
1. webkit(苹果研发的,safari内核,Chrome谷歌浏览器内核原型),开源的
2. Mozilla(FireFox火狐浏览器)
3. Opera 欧鹏
4. IE 微软自行研发

### 1.HTML是什么?
HTTP:超文本传输协议,应用层.
html:超文本标记语言

### 注意:html文件在哪里保存,html文件在哪里运行
1. html网页文档保存在服务器中
2. 由浏览器下载html文档后,解析并显示

### 2.HTML怎么用
1. 超文本标记语言-------html超文本标记语言 xml可扩招标记语言 
2. 就是标签相对固定的xml
	2.1标签名固定
	2.2标签上可以时用的属性固定
	2.3标签与其他标签的嵌套关系固定

### 总结:我们学习html.就是学习标签,标签属性,标签的嵌套关系

### HTML的基本结构
	<!DOCTYPE html>
	<html><!--根元素-->
    	<head></head>
    	<body>
    		<!--在页面中显示的元素在body标签内写-->
    	</body>
    </html>

### DOCTYPE
1. 文档类型的声明,告诉浏览器当前文档使用的html标准是什么版本,按照哪种版本的规则去解析显示
2. '<!DOCTYPE html>' 是按照html5的规则去解析
3. 如果不写DOCTYPE,不同浏览器解析标准不同
4. 写了就没有差异了么?? 不是的,差异会很小.

## HTML网页,在webserver中编写

### HTML文档的基本结构

1. title,就是定义当前页面的标题.建议设置,SEO:搜索引擎优化,
2. meta,设置浏览器端解码规则

## HTML中常见标签

### 1. 文本标签，跟论文格式很相似
### 标题 h1 h2 h3 h4 h5 h6 (hn) 用于声明文章中的标题

### 2. 段落 p paragraph 前后是有回车换行的

### 3. 属性align="center"
### 注意:所有的hn标签都可以使用algin="center"属性,使标题居中显示
### 但是现在的开发手段,一般是使用css进行格式化(居中,字体颜色,大小等)
### 所以现在在标签内部写属性,控制样式的方式,用的少啦

## 上午小作业
1. 创建homework.html
2. 在开启webserver后通过域名访问

### 课堂练习,模拟写自己的简历

### 列表,显得有条理
1. 无序列表 u-unordered l-list--->ul (项目中较多使用)
				l-list			i-item
		<ul>
			<li>不会自动添加序号</li>
			<li>不会自动添加序号</li>
		</ul>
2. 有序列表 o-ordered l-list--->ul (项目中很少使用)
				l-list			i-item
		<ol>
			<li>会自动添加序号</li>
			<li>会自动添加序号</li>
		</ol>
	
### 有序列表无序列表的嵌套练习

### 无序列表的嵌套练习

## 分区 

### 块级分区

		<div></div> 
		
	![](7.png)
	
### div 默认是看不见的,他的存在是为了逻辑上做分区.

### header footer nav 作用和div一模一样,只是可读性提高了,是H5新标签,可以和div标签嵌套使用.
1. '<header>' H5新特性,页眉,页头,导航区域
2. '<nav>' 放在'<header>'标签内使用
3. '<footer>' H5新特性,页脚,版权信息

### 它们都属于块级分区,块级分区要独占一行.默认不允许其他元素在同一行

### 行内分区,不会换行,可以和其他行内元素位于同一行.
### 如果只是一行文字内部的区域进行属性的设置,请使用行内分区

		<span></span>

## 元素的显示方式

1. 块级元素,自己独占一行的元素,块级元素>块级分区

		hn p ul ol li header footer nav div

2. 行内元素,可以和其他行内元素位于同一行,行内元素>行内分区

		span	行内分区 
		<i></i>/<em></em>	定义斜体
		<b></b>/<strong></strong>	定义粗体
		<u></u>	下划线
		<s></s>/<del></del>	删除线

### 行内元素的空格折叠现象
### 写代码的时候,不管连写多少个空格,回车,都会显示成一个空格
### 实体引用
		&nbsp;	代表一个空格,一定要带分号
		<br>	代表一个回车
		&lt;	代表<
		&gt;	代表>

### 图片标签
		<img alt="" src="">
		src中放图片路径
		
### 网页中图片路径的写法

1. 绝对路径 
		在tmooc,找到一个img标签,按F12选中这个标签,
		在控制台右键点击标签路径,选中open in new tab
		在一个新选项卡中打开图片,复制这个新选项卡的地址栏,
		然后放入img的src中.就可以显示其他网站的图片了
		这种行为称做图片的盗链,得到的是绝对路径

### 总结,一般情况下,在一个页面中显示其他网站的图片经常使用绝对路径连接显示图片
### 行业中,称专门提供网页图片的网站为图床

2. 相对路径.相对于当前页面的路径,从当前页面的位置出发,寻找
		
		<img src="../img/06.png">

### 总结:在一个网站内,自己的图片资源一般使用相对路径

## 关于img路径的大总结:
### 1. 使用其他网站的图片一般使用绝对路径
### 2. 使用自己网站的图片资源,一般使用相对路径

### img标签的常用属性
		<img
			src=""		图片的路径
			alt=""		图片显示失败时,显示的文本 
			title=""	图片的描述文本
			width=""	图片宽度
			height=""	图片高度
		>

### 为了防止图片失真,一般宽和高只写一个,让另外一个属性自动适应
### width和height,一般使用css去编写,不使用img的属性了
### img标签支持的图片类型
	1. jpg		不支持透明色
	2. png		支持透明色
	3. gif		动态图

## 作业
1. 笔记和demo要过一遍
2. 写一份模拟简历
3. 预习明天的PPT

#=========================Webbasic_day02===================================
# day02

## 复习
### HTML
### 文本标签
### 分区
### 元素的显示模式--***



## 超链接 主要用于跳转页面

		<a>李小龙</a>
		<!-- 超链接 href属性存放路径,当不知道跳转到哪里时,写# -->
		<a href="http://www.tmooc.cn">跳转到TMOOC</a>
		<a href="../img/06.png">跳转到图片</a>
		<a href="demo2.html">跳转到本网站的另一个页面</a>
		
## 总结:a标签是行内元素
### 添加href属性,a标签才有效果
### href中的url也分相对路径和绝对路径
### 访问本网站的其他页面用相对,访问其他网站用绝对

### a标签的其他属性
		
		target="_blank"	新页面,开启新窗口显示
		target="_self"	新页面,在原窗口显示
		默认是_self

### 超链接 锚点的用法 跳转到本页面之内其他位置

### 页面之间的跳转是超链接,一个页面之内位置的跳转是锚点.

		-- H5的锚点设置方式
		<a href="#charAt">charAt 方法</a>
		<h3 id="charAt">charAt 方法</h3>

		-- H4的锚点设置方式
		<a href="#length">length 方法</a>
		<a name="length"></h3>

## 网页中的表格标签

		<table>
			<tr><!-- table row -->
				<td></td>	<!-- table data -->	
				<td></td>		
				<td></td>									
			</tr>
			<tr>
				<td></td>		
				<td></td>									
			</tr>
		</table>

### 表格的相关属性
		
		border="2px" 	表格宽度
		align="center"	对齐方式
		width="200px" 	宽度
		height="100px"	高度

> 这些属性一般写在样式中,目前只在学习和测试过程中使用

### 表格的重要属性

1. 单元格边框与内容的距离
	
		cellpadding=""

2. 单元格之间的距离

		cellspacing=""

### 列合并与行合并
		
		colspan="占据的列数" 
		rowspan="占据的行数"

-- 		<table align="center"
					border="2px" 
					width="300px" 
					height="300px"
					cellpadding="50px"
					cellspacing="10px">
		<tr>
			<!-- 列合并 -->
			<td colspan="3">111</td>
		</tr>
		<tr>
			<td>111</td>
			<td>222</td>
			<td>333</td>
		</tr>
		</table>

		<table 	align="center"
					border="2px" 
					width="300px" 
					height="300px"
					cellpadding="50px"
					cellspacing="10px">
		<tr>
			<!-- 行合并 -->
			<td rowspan="2">aaa</td>
			<td>aaa</td>
			<td>aaa</td>
		</tr>
		<tr>
			<td>aaa</td>
			<td>aaa</td>
		</tr>
		</table>

### 课堂练习

 ![](3.png)

### 表分组,跟分区类似

		<thead></thead>
		<tbody></tbody>
		<tfoot></tfoot>

-- 		<h1>一周早餐食谱和预算</h1>
		<table		border="1">
			<thead>
				<tr>
					<!-- th等同于td,只不过是字体加粗,默认居中 -->
					<th>周一</th>
					<th>周二</th>
					<th>周三</th>
					<th>周四</th>
					<th>周五</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th>豆浆包子</th>
					<th>火烧</th>
					<th>粥和馅饼</th>
					<th>油条</th>
					<th>鸡蛋灌兵</th>
				</tr>
			</tbody>
			<tfoot>
				<tr>
					<th>10元</th>
					<th>8元</th>
					<th>12元</th>
					<th>6元</th>
					<th>15元</th>
				</tr>
			</tfoot>
		</table>

### 总结:逻辑分组,没有显示变化,一般用于数据重构.
### th和td一样,但是th默认字体加粗,居中.

## 表单标签

### 表单标签是用于在页面中显示一个可以收集用户填写数据的控件.
### 学习表单,就是学习表单控件的结构.和多种表单控件

 ![](4.png)

		<form action="url" method="get" align="center">
			<h3>登录学子商城</h3>
			<div>
				<label>请输入用户名:</label> 
				<input type="text" name="username">
			</div>
			<div>
				<label>请输入密码:</label> 
				<input type="password" name="pwd">
			</div>
			<div>
				<input id="auto" type="checkbox" name="auto">
				<label for="auto">自动登录</label>
			</div>
			<div>
				<input type="submit" value="登录">
			</div>
		</form>

## form表单主要属性
### action	表单提交的url,发送给谁的路径
### method	表单提交数据的方式get/post
### 所有的表单控件都要在'<form>'标签的内部 
### form表单可以使用label

## span和label的区别
### span可以用在任何地方
### label作用和span基本相同,但是只用在表单中,当点文字也可以选中文字前的选择框

## input元素有很多不同的type.
1. text		文本框
2. password	密码框
3. radio		单选框
4. checkbox	复选框
5. submit		表单提交
6. button		普通按钮,点击之后调用JavaScript代码
7. reset		重置按钮,清空表单
8. hidden		隐藏域
9. file		文件选择框

### 文本输入框/密码框 的主要属性
### value 用户自由输入的任何文本
### maxlength 限制输入的字符数
### readonly 设置只读,不能修改,但是数据可以提交
### placeholder 文本提示

### 单选框和多选框

### 单选框 '<input type="radio">'
		<input id="m" type="radio" name="gender">
		<label for="m">男</label>
		<input id="f" type="radio" name="gender">
		<label for="f">女</label>
		<input id="unknow" type="radio" name="gender" 
		checked="checked"><!-- check默认选中 -->
		<label for="unknow">保密</label>

## 总结:name 属性,分组(同时保证可以提交)
### 属性checked="checked",默认选中

### 多选框 '<input type="checkbox">'

		<h3>演示多选框</h3>
		<form action="#">
			<input id="study" type="checkbox" name="hobby" value="study">
			<label for="study">学习</label>
			<input id="sleepping" type="checkbox" name="hobby" value="study">
			<label for="sleepping">睡觉</label>
			<input id="drive" type="checkbox" name="hobby" value="drive">
			<label for="drive">开车</label>
			<input id="swimming" type="checkbox" name="hobby" value="swimming">
			<label for="swimming">游泳</label>
			<input type="submit" value="提交">
		</form>

### 按钮

		<input type="submit" value="提交">
		<input type="button" value="调用js代码"  onclick="alert('aa我是js代码')">
		<input type="reset" value="重置">
		
		sumbit		表单提交
		button		普通按钮,点击之后调用JavaScript代码
		reset		重置按钮,清空表单内容,基本不用

### 隐藏域

		<input type="hidden" name="cartid" value="1234">
		
### 不希望用户看到的信息,同时又需要提交的时候上传

### 文件选择框 file
### 上传文件使用,比如上传头像

		<input type="file" name="img" multiple="multiple">
		
### multiple="multiple" 多重的,可以同时选择多个文件


### 非input标签

1. 文本域,需要用户填写大量文本时使用
				
		<form action="#">
			<label>请输入地址</label>
			<textarea></textarea>
		</form>
		
		属性:rows和cols,原本的意思是本一行占多少字符,能显示多少行字符
		但是由于系统编码不同,浏览器解析不同,这个显示字符数差异很大.
		readonly,只读.

### 下拉选

		<select name=tName>
			<option>--请选择--</option>
			<option>王克晶</option>
			<option>范传奇</option>
			<option>李然</option>
			<option>刘苍松</option>
		</select>
		
### 总结:如果下拉选想要提交数据,需要name属性

	1. 如果option没有设置value属性,那么select的value就是选中的那个option的内容
	
	2. 如果option设置了value属性,那么select的value就是选中的那个option的value

## 关于form表单控件的总结
	
	1. 只有含有name属性的表单控件才可以提交数据,提交的是value值
	2. 单选按钮和多选按钮,需要设置value值,不然就算选中,提交的数据也是on(=on)
	3. 关于表单控件的默认值设置
		
		3.1 文本框和密码框,设置value属性就可以显示默认文本.(提示文本placeholder)
		3.2 单选框使用checked属性,设置默认选中
		3.3 下拉选设置selected属性,默认选中.

## CSS 层叠样式表

### CSS样式的编写使用方式

### 1. 内联样式
		
		<!-- 内联样式 -->
		<!-- 在标签内部,用style属性添加样式 -->
		<a href="#" style="color: red">五一节日快乐,就是不放学</a>

### 总结:除了学习和测试以外,内联样式不要使用
	
	1. 样式不能重用
	2. 内联样式优先级最高

### 2. 内部样式
		
		<ul>
		<li>韭菜</li>
		<li>菠菜</li>
		<li>酸菜</li>
		</ul>	
		
		<!-- 内部样式添加的标签 -->
		<style type="text/css">
		/* 选择器{样式}*/
		li{
			background-color: #006699;
			color: #990066;
		}
		</style>

### 总结:可以代码重用,但是开发用的少,因为只在本html页面内重用

### 3. 外部样式

![](5.png)
	
	1. 创建外部样式文件 style.css
	2. 在html中,head标签内部,引用外部的css文件
		
		<!-- 引用外部样式文件 -->
		<link rel="stylesheet" type="text/css" href="style.css">
	
	3. 注意路径问题,注意rel属性必须写.

### 总结:由于外部样式重用度高,所以开发中尽量使用外部样式

## 作业
1. 课程表
 ![](11.png)
 
2. 混乱的注册
 ![](12.png) 


#=========================Webbasic_day03===================================
# day03

## 复习

### CSS层叠样式表

### 1. 内联样式--display:none/block;定义标签显示方式.
### 2. 内部样式--学习演示时候使用
### 3. 外部样式--开发中一定使用

## 样式表的优先级

### 1. 浏览器默认样式-最低
### 2. 内部样式和外部样式-就近优先

![](1.png) 

### 3. 内联样式-最高

## css选择器
### 选择器的作用,就是为了选出当前页面中符合要求的一个或者多个标签.

1. 标签(元素)选择器,一般定义默认样式,等待被其他样式覆盖.

		h2{color:#f00}
		p{}
		a{}
		input{}

2. 类选择器(class选择器)
		
		.col{color:#006699;}
		.w100{
			border: 1px solid red;
			width: 100px;
		}
		
		<h2 class="col w100">类选择器</h2>
		<p class="col w100">类选择器</p>
		
3. id选择器-由于一个html中id唯一,所以id选择器作用是选取当前页面中符合要求的**一个**标签

		<h3 id="h">id选择器</h3>
		
		#h {color:#f00}

4. 派生选择器-可以通过父标签找到符合要求的子子孙孙标签.

		/* 派生选择器1 */
		/* ul li span a{
			color: #f00;
		} */
		/* 派生选择器2 */
		/* ul li .sh{
			color: #f00;
		}   */
		/* 派生选择器3 *//* 子子孙孙标签都改 */
		/* ul a{
			color: #ff0;
		} */
		
		<body>
		<ul>
			<li><a href="#">北京</a></li>
			<li><a href="#" class="sh">上海</a></li>
			<li><a href="#">广州</a></li>
			<li><span><a href="#">深圳</a></span></li>
			<a href="#">烟台</a>
		</ul>
		</body>
		
5. 子类选择器-根据父标签,找到符合要求的子标签
		
		/* 子类选择器 *//* 只更改子标签 */
		ul>a{
			color: #990066
		}

6. 伪类选择器-在一系列动作中,添加某种样式
		
		:hover--鼠标悬停和鼠标离开

### 总结:选择器(派生,子类)写的越具体,优先级越高.
		
		/* 深圳红色 */
		/* ul li span a{
			color: #f00;
		} */
		/* 上海红色 */
		/* ul li .sh{
			color: #f00;
		}   */
		/* ul下所有的a为#ff0色 */
		/* ul a{
			color: #ff0;
		} */

		<body>
		<ul>
			<li><a href="#">北京</a></li>
			<li><a href="#" class="sh">上海</a></li>
			<li><a href="#">广州</a></li>
			<li><span><a href="#">深圳</a></span></li>
			<a href="#">烟台</a>
		</ul>
		</body>

## CSS常用样式属性

1. 布局相关属性
		
		width:	单位:px	100%(前端常用)
		height:
		
		margin:设置外边距
		margin: 10px;			同时设置四个边距,以左上为准.
		margin: 10px 20px;		设置上下10px,左右20px
		margin: 0px auto;		块级元素的水平居中
		
		margin-top:value		上外边距
		margin-right:value		右外边距
		margin-bottom:value	下外边距
		margin-left:value		左外边距
		
		padding:设置内边距
		padding: 10px;			四个方向都是10px,以左上为准.
		padding: 10px 20px;	上下10px,左右20px
		padding: 10px 20px 30px 40px;	上右下左
		
		padding-top:value		上内边距
		padding-right:value	右内边距
		padding-bottom:value	下内边距
		padding-left:value		左内边距
		
		
### 总结1:若div不设置宽度,默认占父容器宽度的100%
### 总结2:若div不设置高度,有内容,内容多高div多高.没内容,默认高度为0px;
### 总结3:盒子模型BoxModel,元素之间的留白,元素背景的填充范围,元素的大小,这些东西的控制规定放在一起,就是盒子模型.

### 盒子模型一般用于计算整体布局的宽度,定义了元素框处理元素内容,内边距,边框和外边距的方式.
### 一个元素占用页面的宽度计算公式:左外边距+左边框+左内边距+内容区域宽度+右内边距+右边框+右外边距

		
2. 背景相关属性(background)

		background-color: 		背景颜色
		background-image: 		背景图片
		background-repeat: 	背景图片的平铺方式
		background-position:	背景图片的位置
		background-size:		背景图片的大小

#### background-color: 背景颜色,
#### 设置颜色值
		
		1.纯英文单词,red,green等
		2.#ffffff 6位16进制字符串,# 00 66 99
		3.#f00 相当于 # ff 00 00
		4.rgb(255,255,255); 0-ff 0-255
		5.rgba(255,255,255,0~1) a是透明度阿尔法 1不透明,0全透明

#### background-image: 背景图片

		background-image: 	url("路径")

若div设置了背景图片,那么div内部的元素将会在背景图片之上显示(背景图片类似于桌布)

#### background-repeat: 背景图片的平铺方式
		
	1. background-repeat: no-repeat;	不平铺
	2. background-repeat: repeat; 		平铺
	3. background-repeat: repeat-x;		横向平铺
	4. background-repeat: repeat-y;		纵向平铺

#### background-position: 背景图片的位置

#### center|top|bottom|left|right|具体数值

#### background-position: x轴 y轴
		
		background-position: right bottom;
		background-position: 270px 20px;
		background-position: center center;
		
#### background-size: 宽 高;

		background-size: 330px 350px;
		
## 作业:
1. 笔记中所有的知识点和demo,重新敲一遍
2. 完成如下demo
 ![](3.png)

#=========================Webbasic_day04===================================
# day04

## 复习
### 1. 样式表的使用
##### 1. 内联样式 display
##### 2. 内部样式
##### 3. 外部样式 link 导入*.css rel=stylesheet
 
### 2. 样式的属性
#### 1. 布局相关的属性 margin可以微调位置  padding
#### 2. 盒子模型

#### 2. 背景属性 background-image:url("路径")
##### 2.1 颜色的设置方式 
		1.纯英文单词,red,green等
		2.#ffffff 6位16进制字符串,# 00 66 99
		3.#f00 相当于 # ff 00 00
		4.rgb(255,255,255); 0-ff 0-255
		5.rgba(255,255,255,0~1) a是透明度阿尔法 1不透明,0全透明

3. 字体相关属性

		font-size:字体大小 
		单位:px cm 
		em:是一个相对的度量单位		若页面基础字号为16px,
		font-size:1.5em;	16px的1.5倍,为了屏幕自适应.

		font-family:字体		"微软雅黑"		"黑体"
		font-weight:字体粗细(权重)  单位:磅pt
		
			lighter  细一点
			nomarl	   正常粗细
			bold     粗一点
			bolder   更粗一点
		
		font-style:字体样式  normal italic斜体

		<div id="d1">测试font的div标签</div>
		<style type="text/css">
		#d1{
			width: 50%;
			height: 200px;
			border: 3px solid #aaa;
			font-size: 40px;
			font-family: "黑体";
			font-weight: bolder;
			font-style: italic;
		}
		</style>


4. 文本属性
		
		color:文本颜色
		text-align: 文本对齐方式 left|center|right
		text-decoration: 文本装饰 
		text-decoration: none;给a标签去除下划线
		text-decoration: line-through;删除线
		text-decoration: underline;下划线 
		text-decoration: overline;上划线
		
		line-height: 文本行高
		
		由于div的文本默认情况下根据行高垂直居中,若希望文本在div中垂直居中显示.
		只需要将line-height设置为div的height,但是此处存在bug.因为字数过多会折行,
		每一行都遵循行高的效果.


5. 边框属性border
		
		border: 1px solid black; 粗细 实线 颜色
		border-width: 边框的宽度 1px
		border-color: 边框颜色 black
		border-style: 边框样式 solid
		
		单独设置四个边框:border-top|left|right|bottom|
		border-top: 20px solid red;/* 实线 */
		border-left: 3px dotted blue;/* 点 */
		border-right: 30px double green;/* 双实线 */
		border-bottom: 10px dashed gray;/* 虚线 */ 
		
		单独设置某个边框:
		border-top-width: 上边框的宽度
		border-top-color: 上边框的颜色
		border-top-style: 上边框的样式
		
		border: none;去除边框
		
		设置边框的圆角
		border-radius: 10px; 圆角的半径
		
		将圆角半径设置为正方形div宽或高的一半,div在网页中就会显示圆形
		

## 课堂练习 学子商城二级菜单
![](1.png)

### 总结: 
### 1. 确定宽高(div不写宽默认为父容器宽)
### 2. 考虑背景问题.图片和颜色
### 3. 考虑内部字体问题.字号,颜色,字体,对齐
### 4. 位置的微调 margin padding 浮动 定位
### 注意:margin会移动元素位置,padding会改变元素占距页面的大小.

### 溢出属性 overflow
		visiable 溢出部分可见
		hidden 溢出部分不可见
		scroll 溢出部分显示滚动条

		<style type="text/css">
		#d1{
			width: 550px;
			height: 300px;
			background-color: red;
			overflow:hidden;
		}

		#d2{
			width: 500px;
			height: 500px;
			background-color: gray;
			margin-top: 20px; /* 有bug */
		}
		</style>
		
		<div id="d1">
			<div id="d2">
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
				<p>!!!!!!</p>
			</div>
		</div>

6. 常见复杂属性

### 1. display 控制元素的显示方式(唯一一个可以写在内联样式中的属性)
		
		dispaly:block;按照块级元素进行显示
		display:inline;按照行内元素进行显示(一般不用)
		displat:none;隐藏元素
		
		<span>我是span,这是一个行内元素</span>
		
		<style type="text/css">
		span {
			display: block;
			width: 200px;
			height: 200px;
			margin-top:100px;
			border: 2px solid red;
			font-size: 20px;
			color: red;
		}
		</style>
			
### 总结:行内元素一行中可以有多个,从左到右依次摆放.
###     行内元素,宽高,上下外边距失效.内边距不失效.
###     块级元素:独占一行,只有块级元素可以设置宽高和上下外边距. 

### display:inline-block;行内块!
### 与其他行内元素(行内块)共占一行,同时可以改变宽高和上下外边距.但是容易出bug,使用要小心

### 课堂练习 a标签模拟登录按钮

		<a href="#" id="login_btn">登录</a>
		
		<style type="text/css">
		#login_btn {
			display: block;
			width: 276px;
			height: 37px;
	
			background: -webkit-linear-gradient(top, #952561 0%, #651764 100%);
	
			font-size: 20px;
			font-family: "黑体";
			color: #fff;
			text-decoration: none;
	
			text-align: center;/* 水平居中 */
			line-height: 37px;/* 垂直居中 */
			border-radius: 4px;/* 设置圆角 边框的属性 */
		}
		</style>

## **浮动 float**

		float: left;元素浮动起来往左放
		float: right;元素浮动起来往右放

### 一旦元素设置了float属性,当前元素将会脱离默认文档流,在默认文档流之上,进行渲染绘制.
### 元素float后,原先的位置会被其他元素占用.float最常见的用法,是把块级元素横向排列.
### clear:both,清除浮动,本标签不被其他浮动的标签覆盖.

## 作业

### 课上前6个demo重写一遍
### 了解display none block inline 特性
### 表述浮动
### 预习定位


#=========================Webbasic_day5===================================
# day05

		-块级,独占一行,可以有宽高,margin都生效
		-行内,从左到右依次摆放,宽高不生效,margin-top,bottom不生效
		-行内块,可以和其他行内块占一行,可以设置宽高.
		
		-浮动
			1. 浮动时候,若本标签上面的标签处于文档流中,本标签只在当前行浮动.
			2. 若上面的标签也浮动,本标签会在上面标签那行浮动
			3. clear:both,清除浮动,本标签不被其他浮动的标签覆盖
			4. 浮动多用于块级元素横向显示
		
		
## 定位 position
		定位类型:absolute,relative,static,fixed
		position:absolute;绝对定位
		position:relative;相对定位
		
### 总结,position会让标签脱离默认文档流,成为单独层.
### 1. 一个标签如果设置了position属性,就会附带其他偏移属性,
### 如top,left,right,bottom,与四边的距离

### 2. absolute,原位置会被其他元素占用,新位置相对于包含它的最近的已定位祖先元素.
### 3. relative,原本所占的空间仍保留,元素位置相对于它原位置偏移某个距离.

## 总结写代码的套路:
	
	1. 若标签原始位置不能被占用,使用position:relative
	2. 若标签原始位置需要被占用,使用position:absolute,但是要在父级元素中添加position:relative

### 关于堆叠顺序,后写的层数高.
		z-index:100; 改变层数.数字越大,层数越高,

## position:fixed;相对页面定位,将元素内容固定在页面的某个位置,从文档流中去除,不占用页面空间

		<body>
		<div id="header">看见我了吗?就不让你动</div>
		<h1>其它内容</h1>
		<h1>其它内容</h1>
		<h1>其它内容</h1>
		</body>
		
		<style type="text/css">
		#header {
			height: 50px;
			width: 100%;
			background-color: #163684;
			font-size: 14px;
			color: #fff;
			line-height: 50px;
			font-weight: bolder;
			font-family: "黑体";
			position: fixed;/* 固定定位 */
			top: 0px;
			left: 0px;
		}
		body{
			padding-top: 50px;
		}
		</style>

## 项目 学子商城登录页面


#=========================Webbasic_day06===================================
# day06

# JavaScript
## 是嵌入HTML中的浏览器中的脚本语言.
### 网页所有的交互都是用JavaScript

## JavaScript的发展

### JavaScript 的特点
1. 可以使用任何文本编译工具编写
2. 由浏览器内置的JavaScript引擎执行代码
3. 解释执行:事先不编译,逐行执行
4. 基于对象:内置大量现成对象

### 学习JavaScript
### 1. 学习如何找到标签对象
### 2. 学习如何对标签的属性内容,进行增删改查.

## JavaScript的使用
1. 事件定义式,在定义事件时直接写js代码,在标签内写,类似css内联样式.
		<!-- 事件:用户做出某种操作时,调用js代码 某种操作就是事件 -->
		<!-- 触发事件,就是调用js的时机,比如单机按钮 -->
		<input type="button" value="事件定义式"  onclick="alert('扎心了老铁,事件定义式')">

2. 嵌入式,使`<script>`,`<script>`标签内写js代码,类似于java中自定义方法
		<script type="text/javascript">
			/* js代码写在script标签内部 */
			/* 语法上允许script标签可以放在html的任何位置 */
			/* 但是通常放在head标签中 */
			/* fuction是关键字,用来声明函数 */
			/* fn1是函数名,小括号内可以声明参数 */
			/* js中函数都是共有的,不需要修饰符 */
			/* 函数不需要声明返回值类型 */
			/* 若函数中没写retrun,函数调用时默认返回值为undefined */
			function fn1() {
				alert("嵌入式js的使用");
			}
			function fn2() {
				alert("我是验证返回值");
				return 123;
			}
		</script>
		
		<input type="button" value="事件定义式" onclick="alert('扎心了老铁,事件定义式')">
		<input type="button" value="嵌入式" onclick="fn1()">

3. 文件调用式 js代码写在单独的.js文件中----html页面引用 .js文件
		如何引用,head标签中添加新script标签,设置script标签的src==".js的路径"
		
		<script type="text/javascript" src="my.js"></script>

		my.js文件中写
		function fn3{
			console.log("我是文件调用式");
		}

4. js注释,script标签中是js的地盘,使用js的注释, 
		// /**/ /*js不区分单引号和双引号 */

### 课堂练习
### 事件定义式 嵌入式 文件调用式 注释 重新敲一遍

## js数据类型

### 1.变量的声明和定义
		<script type="text/javascript">
			//声明变量
			var x;
			//给变量赋值
			x=9;
			x="abc";
			console.log(x);//abc
			var y=123;
		</script>

### 总结:在scrip标签中写js代码一般两种形式
### 1. 封装成函数,该函数在页面加载完成后,用户激活事件时被调用.
### 2. 直接写js代码,该代码在页面加载过程中被直接调用,甚至比body渲染还早.

## Number 类型
### 不区分整型和浮点型,
### 所有数字都采用64位浮点型格式存储
### js中无double类型

## String类型
### 由Unicode 字符 数字 符号组成的字符序列,
### 首尾由一对单引号或者双以号括起.
### 单双引号嵌套时不需转义,其他特殊字符需要转义,\n,\\,\',\",
### 没有char类型,字符就是一个长度的String

## boolean
### true=1;flase=0;可以自动转型作为数值参与运算

### js引擎对boolean类型的解释规则
1. 非空字符串解释位true,空字符串解释位false;
2. 非0数字解释为true,0解释为flase;
3. null undefined 都为false

### 强制类型转换
1. typeof() 查询当前类型
		function fn1() {
		var num = 100;
		console.log(typeof (num) == "number");//true
		var str = "abc";
		console.log(typeof (str) == "string");//true 注意小写
		console.log(typeof (null));//object
		console.log(typeof (undefined));//undefined
		}
		<input type="button" value="检测typeof" onclick="fn1();">

2. is	NaN()判断 是不是NaN

		function fn2() {
		console.log(isNaN(56));//f
		console.log(isNaN("32"));//f 引号内的纯数字
		console.log(isNaN("abc"));//t
		console.log(isNaN(""));//f 引号内空 ==0
		console.log(parseInt(""));//是bug
		}
		<input type="button" value="检测isNaN" onclick="fn2();">

### 课堂练习 计算平方
1. 获取文本框内的数 value
	1.1 获取文本框对象 var input = document.getElementById("");
	1.2 通过对象获取文本框的值 var num = input.value;
	1.3 获取span的对象 var span = document.getElementById("");
2. 判断这个数是不是数字
	if(isNaN(num)){
		span.innerHTML="输入错误";
	}else{
		span.innerHTML=num*num;
	}
3. 是数字.计算,并在span中输出结果
4. 不是数字,span中提示用户输入错误

### 数学运算符 + - * / %  ++ -- 
### 纯数字的字符串遇到"+"号变成字符串拼接.遇到其他运算都是进行数字计算.
### js中的除法会得到浮点数.100/3=33.3333333336;
		var num=1;
		num=num++ + ++num + num++ + ++num;//12
		sum		1		4			7		12
		num		2		3			4		5
### 关系运算符<> >= <= != = !== ==  ===
### === 全等,数据类型和值都得相等

### 课堂练习:网页版猜数字

### 逻辑运算符 ! && || 一定要注意短路问题;

### 条件表达式 三目运算符 表达式?表达式1:表达式2 和java一样
### js可以使用任何数据做条件
### 当使用非boolean值做条件时.
### true:非空字符串	非0数字;	false:null undefined "" 0 NaN;

#=========================Webbasic_day07=========================================
# day07
## 循环 for while do-while

### 练习,输入1-100,计算该数的阶乘
	- n(正整数)的阶乘 1*2*3....*n
	- 0的阶乘为1
	- 小数,负数没阶乘

## javascript对象
### 包含内部对象 外部对象 自定义对象

## javascript常用API
### 对象是javascript最重要的API

## javascript 常用内置对象
### string number boolean array math date regexp(正则) function

### string
1. 创建的来两种方式,var str="hello" var str=new String("hello")
2. 大小写转换 和java一样
		.toLowerCase();
		.toUpperCase();
3. 获取指定的字符(串) ;返回值是字符串
		str.charAt(index);
		var str = "javascript网页教程";
		var str1 = str.charAt(12);//"教"
		
4. 查询指定字符串 indexOf() lastIndexOf();
		var str = "javascript网页教程";
		var index = str.indexOf("a");//1 
		var index1 = str.lastIndexOf("a");//3
		
5. 获取子字符串
		str.substring(start index,[end index])

6. 替换子字符串
		str.repalce(findstr, tostr); 返回替换后的字符串.
						旧的,       新的
		var str="abcde";
		var str1==str.repalce("cd","aaaa");//"abaaaae"
		
7. 拆分子字符串
		str.split(bystr,[length]);返回分割后的字符串数组
		bystr:分割用的字符串
		length:指定返回的数组最大长度,可省略
		
		var str ="一,二,三,四,五,六,七"
		var strArray=str.split(",",5);//["一" ,"二", "三", "四", "五"]
		var strArray1=str.split(",",10);//["一" ,"二", "三", "四", "五", "六", "七"]

### number对象的常用方法
		toFixed();转换为字符串,并保留小数点后一定位数.
		如果必要的话,该数字会被四舍五入,也可以用0补足位数.


## 数组
### js中的数组特点
1. 是object类型.
2. 可同时存放不同数据类型的值.
		var arr=["大一顿","不多于",12.3,true];
3. 两种创建方式,都是object类型
		var arr = [ "大一顿", "不多于", 12.3, true ];
		var arr1 = new Array();
		arr1[0] = "123";
4. 数组长度可变.arr.push(); 返回值是数组的长度.
		arr1.push(object obj);返回值是数组的长度.
5. 数组常用API
		arr.reverse()//反转输出

### arr.sort(); 排序,按照数组中每一个元素的Unicode编码集排序,比完第一位比较第二位.
		var arr=[5,12,3,14,26,1];
		arr.sort();//1,12,14,26,3,4
### string就是按照这个方式排序的

### arr.sort()排序有两个规则,
1. 排序规则,从大到小还是从小到大排序,被规定死了,从小到大.
2. 比较规则,默认按照Unicode编码集排序,但是可以修改.
		function x(a,b){
			return a-b;
		}
		返回值:a的unicode值-b的unicode值的差
		若return>0;则a>b,a b交换位置
		
		可以通过修改比较规则来改变排序规则
		var arr=[5,12,3,14,26,1];
		arr.sort(x);//1,3,4,12,14,26
		
		也可以用匿名函数
		arr.sort(function(a,b){
			return a-b;
		});

### math
		console.log(Math.round(4.56));//5;四舍五入,取整
		console.log(Math.floor(-4.5));//-5;向下取舍,取整

### date

1. 创建客户机当前时间
		var d1=new Date();
		//Mon May 07 2018 15:43:32 GMT+0800 (CST)

2. 创建指定时间的date对象(指定时间一般源于服务器)
		var d2=new Date("2016/08/22 20:20:20");
		//Mon Aug 22 2016 20:20:20 GMT+0800 (CST)

3. 读写时间的毫秒数
		getTime();读毫秒数 把年月日时分秒--->毫秒
		setTime();写毫米数 把毫秒--->年月日时分秒

### date的API
### 从服务器拿到时间对象,在页面根据不同需求显示;
### 读写时间分量:
		d1.getFullYear();//年
		d1.getMonth();//月份 0-11
		d1.getDate();//day of month
		d1.getDay();//day of week;
		d1.getHours();//小时
		d1.getMinutes();//分钟
		d1.getSeconds();//秒
		
### date转换为本地时间格式
		d1.toString();//"Mon May 07 2018 16:14:09 GMT+0800 (CST)"
		d1.toLocaleTimeString();//"下午4:14:09"
		d1.toLocaleDateString();//"2018/5/7"

### 正则
		.	任意字符
		\w	数字 字母 下划线
		\s	空白字符
		\d	数字
		^	字符串开头
		$	字符串结束

### 1. 如何创建正则表达式对象
	- 直接创建
		var reg=/正则表达式/[模式]  模式

	- 创建正则对象
		var reg=new RegExp(正则表达式,[模式])
		var reg=new RegExp('\s\d');//此句有坑

	- 模式
		g:全局模式,
		i:忽略大小写,

### 2. 正则对象匹配的方法 reg.xxx(str);
		reg.exec(str);从str中找到匹配的子串,并返回该字串
		reg.test(str);判断str中是否含有匹配的字符串,找到返回true;使用最多
				
		var str="you can you up,no can no bi bi";
		var reg=/no/g;
		console.log(reg.exec(str));
		console.log(reg.exec(str));
		console.log(reg.exec(str));
		//普通模式下返回第一个符合要求的字串;
		//全局模式下,第n次执行,返回符合要求的第n个字串;

		console.log(reg.test(str));
		
### 3. 字符串匹配的方法 str.match(regexp);
		
	1. str.replace(reg,"目标字符串");//返回替换后的新字符串;
	将str中与reg匹配的字符串替换称目标字符串;
	全局模式下全部替换;
	普通模式下,值替换第一个;
	
	2. str.match(reg);将替换掉的字符串放在数组中返回;
	从str中找出和reg匹配的字串;
	
	3. str.search(reg);,返回值是索引
	从str中找出和reg匹配的第一个字符串的索引;

### 课堂练习:学子商城登录验证
		<!DOCTYPE html>
		<html>
		<head>
		<meta charset="UTF-8">
		<title>学子商城登录验证副本</title>
		<script type="text/javascript">
			function checkUser() {
				var code = document.getElementById("username").value;
				var span = document.getElementById("msg_user");
				var reg = /^\w{5,10}$/;
				if (reg.test(code)) {
					span.className = "ok";
					return true;
				} else {
					span.className = "error";
					return false;
				}
			}
			function checkPwd() {
				var code = document.getElementById("pwd").value;
				var span = document.getElementById("msg_pwd");
				var reg = /^\w{5,10}$/;
				if (reg.test(code)) {
					span.className = "ok";
					return true;
				} else {
					span.className = "error";
					return false;
				}
			}
		</script>
		<style type="text/css">
		.ok {
			color: green;
		}

		.error {
			color: red;
		}
		</style>
		</head>
		<body>
			<form action="http://www.tmooc.cn" method="get" 
		onsubmit="return checkPwd()*checkUser()==1"> //遇到短路用这种方法
				<div>
					帐号:<input type="text" id="username" onblur="checkUser();"> <span
						id="msg_user">5-10位数字,字母,下划线</span>
				</div>
				<div>
					密码:<input type="password" id="pwd" onblur="checkPwd();"> <span
						id="msg_pwd">5-10位数字,字母,下划线</span>
				</div>
				<div>
					<input type="submit" value="登录">
				</div>
			</form>
		</body>
		</html>

#=========================Webbasic_day08===================================
# day08
## function对象
### 1.js中函数就是function对象
### 2.函数名就是指向function对象的引用
### 3.使用函数名是访问函数对象
### 4.函数名(),是调用函数
		var fn1=function(){alert("111")}
		等同于:function fn1(){alert("111")} 
		fn1();

### 5.函数返回值
	- 默认返回值是undefined
	- 可以使用return返回具体的值
### 6.函数的参数
		function x(){alert("222")}
		x();//222
		x(1,2);//222 不报错

### js的函数没有重载
### 函数被调用时,只要函数名一样,无论传入多少参数,调用的都是同一个函数对象
### 但是有和重载一样的调用方式,通过使用arguments(函数参数数组)
		function add(){
			var sum=0;
			for(var i=0;i<arguments.length;i++){
				sum+=arguments[i];
			}
			return sum;
		}
### js调用函数的过程中,只检测函数名,不检测参数列表,
### 若参数名匹配,则直接调用方法,可以使用arguments访问方法的所有参数

### 注意,若js中出现相同参数名的函数,后一个有效.
### 匿名函数:函数无名字,当一个函数在别出不再被使用,该函数可通过匿名函数创建.
		例如: arr.sort(function(a,b){
				return a-b}
				)

### 全局函数 所有js对象都可以使用
		typeof() isNaN() parseInt() parseFloat() 
		eval()

### eval()函数
### 1.用于 计算表达式 字符串,不合法则抛出异常
		var str="2+3";//"2+3";
		eval(str);//5

### 2.用于执行 字符串中的js代码
		var str="alert(1111)";
		eval(str);//1111
		
		var str="function fn1(){alert(1111);}fn1()";
		eval(str);//1111

### eval最重要的作用是,动态执行服务器传过来的js代码.

### 课堂练习 简易计算器
		function cal() {
			var input = document.getElementById("num");
			var num = input.value;
			try {
				input.value = eval("("+num+")");//需要包在()内
			} catch (e) {
				input.value = "error";
			}
		}
		
		<script type="text/javascript" src="demo2.js"></script>
		<input type="text" id="num">
		<input type="button" value="计算" onclick="cal()">

## 外部对象概述
1. 外部对象指的就是浏览器的API;
2. 这些对象由W3C规定,浏览器厂商设计研发
3. 外部对象分为两部分,BOM和DOM.BOM包含DOM
4. 我们可以使用JS代码访问这些对象

### BOM与DOM

### BOM Browser Object Model 浏览器对象模型,用来访问和操作浏览器窗口,使js有能力和浏览器"对话";
1. 通过BOM,可移动窗口,更改状态栏文本,执行其他不与页面内容发生直接联系的操作(即:不操作标签)
2. 没有标准,但被广泛支持
3. BOM拥有的对象

### DOM Document Object Model 文档对象模型,用来操作文档
1. 定义了访问和操作HTML文档的标准方法
2. 通过对DOM树 的操作,来实现对HTML文档数据的操作
3. 不可以控制文档的结构

## JS相关的BOM操作
### window 表示整个浏览器窗口
### 所有JS全局对象,全局函数和全局变量,都自动成为window对象的成员(window可以点出来)

### window的常用属性
		document		窗口中显示的HTML文档对象
		history		浏览过的历史记录对象
		location		窗口文件地址对象
		screen			当前屏幕对象	
		navigator		浏览器相关信息对象

## window 对象常用函数
1. 弹出框 
		<script type="text/javascript">
			//1.弹出框
			function fn1() {
				window.alert("你好");//window可以省略
			}
			//2.确认框
			function fn2() {
				var flag=window.confirm("how are you!!");
				console.log(flag);
			}
			//3.输入框
			function fn3() {
				var str=window.prompt("中午吃的什么?");
				console.log(str);
			}
		</script>
		
		<input type="button" value="按钮1" onclick="fn1();">
		<input type="button" value="按钮2" onclick="fn2();">
		<input type="button" value="按钮3" onclick="fn3();">

## 定时器
### 主要用于网页动态时钟,倒计时,轮播图,无缝滚动,跑马灯效果等
1. 周期性定时器:一定的时间间隔执行代码,循环往复
		setInterval(exp,time);
		exp:需要执行的js语句,一般为匿名函数
		time:时间周期,毫秒
		返回值:返回已经启动的定时器ID
		clearInterval(ID);停止启动的定时器
		<script type="text/javascript">
			function fn4() {//每一秒打印一个数 5,4,3,2,1
			var num = 5;
			var id = setInterval(function() {
				console.log(num--);
				if (!num) {//num==0
					clearInterval(id);
				}
			}, 1000);
			console.log("蹦蹦");
		</script>
		
		<input type="button" value="启动周期性定时器" onclick="fn4();">
		
### 总结:启动定时器相当于启动一个子线程,当前方法fn4相当于主线程,
### 两个线程之间并发执行,相互不等待

## 课堂练习:电子时钟 demo4.html/css/js
		
2. 一次性定时器(相当于延迟执行):在一个设定好的时间间隔之后执行代码,
		setTimeout(exp,time);
		exp:执行的代码
		time:延迟时间
		返回值:id
		clearTimeout(id);
		
## 课堂练习,模拟消息发送和撤销事件;

## 作业 每日笔记过一遍,学子商城登录页面form表单验证,两个定时器

#=========================Webbasic_day09===================================
# day09

## window常用的属性。
### 1. location对象,包含当前页面的URL的信息, 常用于获取和改变当前浏览器的网址
### 属性,href  loction.href="url";//跳转到目标url
### 方法,reload() 重新载入当前网页(即:刷新)
		<script type="text/javascript">
			function fn1() {
				//跳转到目标url
				// location.href="http://www.tmooc.cn";
				//刷新
				// location.reload();
				var flag = confirm("沙雕滚开!");
				if (flag) {
					location.href = "http://www.tmooc.cn";
				} else {
					location.reload();
				}
			}
		</script>

		<input type="button" value="location" onclick="fn1();">

### 2. screen对象,包含有关客户端显示屏幕的信息,常用于获取屏幕的分辨率和色彩
	1. width/height	宽高
	2. availWidth/availHeight 可用宽/高

### 3. history对象,包含用户在浏览器框口中访问过的URL,即:历史浏览记录
	length属性,浏览器历史列表中的url数量,即：历史记录浏览了多少网页
	1. back() 页面后退,到上一个url
	2. forward() 页面前进,到下一个url
	3. go(-1) 页面跳转到 上1页 
	   go(1)  页面跳转到 下1页 
	   前提是历史浏览了记录了网页
	   
### 4.navigator对象,包含浏览器的相关信息
	userAgent属性,当前浏览器的版本


## DOM节点树
1. 浏览器获得网页后将其解析成对象
2. 读写网页内容,就是读写对象
3. 对象具有树状结构,称为dom树
4. 树结构中,每级对象称为节点
5. 节点有不同种类
5. 学习DOM就是学习它的结构,以及节点的API

### DOM操作
### DOM提供了哪些操作.增删改查
1. 查找(获取)节点,
	- document.getElementById("p1");//获取id为p1的标签
	- document.getElementsByTagName("p");//获取所有p标签.返回值数组
		
		<script type="text/javascript">
			/*  页面加载事件,页面加载完毕之后事件才被激活 ,是window的事件*/
			window.onload=function(){
		//	var p1 = document.getElementById("p1");
			var p = document.getElementsByTagName("p");
			var p1 = document.getElementsByTagName("p")[0];
			var p2 = document.getElementsByTagName("p")[1];
			console.log(p);
			console.log(p1);
			console.log(p2);
			//console.log(p1);
			//console.log(p1.nodeName);//节点名
			//console.log(p1.nodeType);//节点类型 1
			}
		</script>

		<!-- b标签 字体加粗 行内元素 -->
		<p id="p1">1.<b>读写</b>节点</p>
		<p id="p2">2.<b>查询</b>节点</p>
		<p id="p3">3.<b>增删</b>节点</p>
		总结：noteType返回值，对应节点类型
		1 --- 元素节点
		2 --- 属性节点
		3 --- 文本节点
		8 --- 注释节点
		9 --- 文档节点
	
2. 读写节点信息(内容/值)
		双标签的叫内容,所有双标签都有内容,
		<div>今天天气不错</div>
		
		一般表单中的控件(标签),数据称之为值
		input select textarea都有value
		<input type="button" value="适合游玩">
		
		<script type="text/javascript">
			console.log(p1.innerHTML);
			console.log(p3.innerText);
			p1.innerHTML="5.<u>哈哈哈</u>dasd";
			p1.innerText="5.<u>哈哈哈</u>dasd";
		</script>
		
		<!-- b标签 字体加粗 行内元素 -->
		<p id="p1">1.<b>读写</b>节点</p>
		<p id="p2">2.<b>查询</b>节点</p>
		<p id="p3">3.<b>增删</b>节点</p>
	双标签	
	2.1 innerHTML//读取所有内容,认识标签
	2.2 innerText;//不认标签,写的时候会把标签当字符串,读的时候,忽略标签
	单标签
	2.3 TagName.value;	读写标签的值

### 2.4 读写节点的属性;	
	1. 通过方法读写属性**
		//1.通过方法读写属性
		var oImg=document.getElementsByTagName("img")[0];
		console.log(oImg);
		//获取属性
		console.log(oImg.getAttribute("src"));
		//设置属性
		oImg.setAttribute("src","../img/bshtg.gif");
		
	2. 通过标准的属性名读写属性**	
		//2. 通过标准的属性名读写属性,
		//className,id,style 
		var oP=document.getElementsByTagName("p")[0];
		console.log(oP.style.color);
		oP.style.fontSize="30px";//这是内联样式
	
	3. 通过不标准的属性名读写属性,只有高版本浏览器才支持	
		//3.通过不标准属性名读写属性,不推荐
		//a.href img.src
		//可以通过使用方法的方式来代替
		console.log(oImg.src);//图片的本地路径
		
### 总结:
### 1.不标准的属性建议使用方法处理.
### 2.标准属性中的style,是内联样式,仅限学习测试使用.		

### 鼠标悬停和鼠标离开的事件
		onmouseover="fn1();";	鼠标悬停
		onmouseout="fn2();";	鼠标离开
		
1. 查询节点的方法
	1.1 通过id查询
	1.2 通过标签名查询
	1.3 通过层次(节点关系);parentNode();
	1.4 通过name属性查询;下拉选

2. 创建新节点
		document.createElement(TagName);
		TagName:要创建的标签名称
		返回值:新创建的节点
		
		需要把该标签对象挂到DOM树上;
		
		<script type="text/javascript">
		window.onload=function(){
			//1.创建新节点
			var newNode = document.createElement("input");
			//2.设置节点信息
			newNode.setAttribute("type","text");
			newNode.value="我是新节点";
			newNode.style.color="red";
			//3.挂到DOM树上
			//3.1获取目标父节点
			var parentNode = document.getElementsByTagName("div")[0];
			//3.2通过目标父对象,把新节点挂在父节点下面
			parentNode.appendChild(newNode);
		}
		</script>
		
3. 追加节点
		function fn1(){
			var oLi=document.createElement("li");
			oLi.innerHTML="重庆";
			var oUl=document.getElementsByTagName("ul")[0];
			oUl.appendChild(oLi);
		}
		
4. 插入节点
		function fn2(){
			var newNode=document.createElement("li");
			newNode.innerHTML="大连";
			var oUl=document.getElementsByTagName("ul")[0];
			//在参考节点之前插入,
			var gz = document.getElementById("gz");
			oUl.insertBefore(newNode,gz);
		}
		
5. 删除节点
		function fn3(){
			//获取父元素和待删除的元素
			var oUl=document.getElementsByTagName("ul")[0];
			var gz = document.getElementById("gz");
			//父元素取删除子元素
			oUl.removeChild(gz);
		}
		
		<body>
			<ul>
				<li>北京</li>
				<li>上海</li>
				<li id="gz">广州</li>
				<li>深圳</li>
				<li>葫芦岛</li>
				<li>佳木斯</li>
			</ul>
			<div>
				<input type="button" value="追加" onclick="fn1();"> 
				<input type="button" value="插入" onclick="fn2();"> 
				<input type="button" value="删除" onclick="fn3();"> 
			</div>
		</body>

## 总结,需要父级去删除子元素
 
### 作业 每日demo 熟悉新建元素挂到DOM上的代 熟悉删除元素 了解window的四个属性

#=========================Webbasic_day10===================================
# day10
### DOM 节点的操作

## 课堂练习:二级联动菜单

## js事件处理
### 事件:指页面元素状态的改变,用户在操作鼠标或者键盘时触发的动作

### 1. 鼠标事件
		- onclick//单击事件
		- ondblclick//双击
		- onmouseover//鼠标悬停
		- onmouseout//鼠标离开
		- onmousedown//鼠标按下事件
		- onmouseup//鼠标抬起事件
		
### 2. 键盘事件
		- onkeydowm
		- onkeyup

### 3. 状态改变事件
		- onload="";//加载页面
		- onchange="";//值改变
		- onfocus="";//焦点获取
		- onblur="";//失去焦点
		- onsubmit="";//提交事件
		
### 事件绑定
1. 在标签属性中,直接处理事件
		<input type="button" onclick="fn1();" value="按钮1">
		function fn1() {
			confirm("在属性中直接处理事件");
		}
		
2. js代码中动态定义,使js代码与html代码分离,好维护
		window.onload = function() {
			var input = document.getElementsByTagName("input")[0];
			input.onclick=fn2;
		}
		
		function fn2() {
			confirm("动态定义事件绑定");
		}

3. 取消事件 onXXX="return false";

## 事件处理机制--事件冒泡
		<div style="border: 2px solid black; height: 100px;"
			onclick="alert('div标签');">
			<p style="border: 2px solid red; height: 50px;"
				onclick="alert('p标签');">
				div--p--btn <input type="button" value="事件冒泡的演示"
					onclick="alert('input标签');">
			</p>
		</div>

### 如果点击了input,将会依次触发input/p/div的onclick事件,这种现象称为事件冒泡
### 发生事件冒泡的要求:1嵌套关系.2内外层标签同一个事件才冒泡.

### 取消事件冒泡,由于浏览器厂商使用的内核不同,有两种方法取消事件冒泡
	1. enent.stopPropagation();
	该方式以前只支持firefox chrome.现在ie9.0及以上高版本已经支持了.
	
	2. event.cancelBubble=true; 
	该方法以前只支持IE,现在高版本的FF和chrome已经支持了
	
		<div style="border: 2px solid black; height: 100px;"
			onclick="alert('div标签');">
			<p style="border: 2px solid red; height: 50px;"
				onclick="alert('p标签');">
				div--p--btn <input type="button" value="事件冒泡的演示"
					onclick="event.cancelBubble=true;alert('input标签');">
			</p>
		</div>

### 4. event对象,事件对象(*****)
#### 获取event对象,
	- 任何事件触发后,会自动产生一个event对象
	- event对象记录事件发生时的鼠标位置,键盘状态和触发对象(事件源)等信息

1. 在html属性中直接使用event对象-----IE-FF-chrome
		<!-- 事件触发时鼠标的坐标 -->
		<input type="button" value="HTML_for_IE-FF-chrome"
		onclick="alert(event.clientX+':'+event.clientY);">	
		
	- 但是这种写法不是松耦合关系,html代码和js代码没分离

2. 在js代码块中,直接使用event对象-----chrome-IE
		function fn1(){
			alert(event.clientX+':'+event.clientY);
		}

		<input type="button" value="js_for_chrome-IE" onclick="fn1();">

3. 在函数中使用event,必须传参-----FF-IE-chrome,所以开发中要求这种写法
		function fn2(event) {
			alert(event.clientX + ':' + event.clientY);
		}
		
		<input type="button" value="for_FF" onclick="fn2(event);">

### 通过event对象获取事件源
### 1.IE和chrome,chrome对IE做了兼容
		<!-- 获取事件源 -->
		function fn3(event) {
			var obj = event.srcElement;
			console.log(obj);
		}
		<input type="button" value="事件源_IE-chrome" onclick="fn3(event);">
	
### 2.FF和chrome,IE9.0及以上也支持
		<!-- 获取事件源 FF-chrome -->
		function fn4(event) {
			var obj = event.target;
			console.log(obj);
		}
		
### 3.浏览器获取事件源的兼容性写法
		function fn5(event) {
			var obj = event.target || event.srcElement;
			console.log(obj);
		}

### 课堂练习:计算器

### js中this的使用
		<script type="text/javascript">
			function fn1(btn) {//btn表示标签.
				console.log(btn.parentNode);
			}
		</script>
		
		<div>
			<input type="button" value="111" onclick="fn1(this);"> 
			<input type="button" value="222" onclick="fn1(this);">
		</div>


## 作业
### 事件的冒泡,取消冒泡
### 获取event对象
### 通过event对象获取事件源
### 计算器
### 完成二级联动

#=========================Webbasic_jQuery_day11===================================
# day11
## jQuery

		function bigger(){
			//获取p的字号
			var size=$("p").css("font-size");
			//"16px"变成可以计算的数字,去掉单位
			size=size.replace("px","");
			//字号加大,设置p标签的字号
			$("p").css("font-size",++size +"px");
		}

		<body>
			<input type="button" value="+" onclick="bigger();">
			<p>jQuery是一个JavaScript库</p>
			<p>jQuery极大的简化了JavaScript编程</p>
			<p>jQuery非常容易学</p>
		</body>

## jQuery 对象详解
本质是一个DOM数组+jQuery的API
只有jq对象才能调用jq方法,
jQ--->DOM:通过下标----$("p")[index]
DOM--->jQ:通过封装---$(p)
注意双引号的问题
 
![](1.png)


## jQuery的常用选择器
### jQuery选择器可以准确选取,你想要的元素.
### 选择器允许你对html元素组或者单个元素进行操作
		$(function(){
			//1.基本选择器
			$("li");//标签选择器
			$("#gz");//id...
			$(".sz");//类...
			$("ul li");//派生...
			$("ul>#gz");//子类...
			$("ul .sz");//子孙类...
			//2.层次选择器
			$("#gz+");//选择他的第一个弟弟
			$("#gz~");//选择他的弟弟们
			$("#gz+li");//选择他的li弟弟
			//3.过滤选择器
			//4.表单选择器
		});
		
<ul>
			<li>北京</li>
			<li>上海</li>
			<li id="gz">广州</li>
			<li class="sz">深圳</li>
			<li>佳木斯</li>
		</ul>

### 3.过滤选择器

#### 1.基本过滤器
		$("li:first");//选第一个li
		$("li:lt(2)");//选下标小于2的li
		$("li:eq(index)");//选下标等于index的元素
		$("li:odd");//选下标为奇数的
		$("li:not(selector)");//选不是selector的

#### 2.内容过滤器
		$("li:contains('州')");//内容带"州"的li
		$("li:empty");//选择内容是空的li
		
#### 3.可见性过滤器
		$("li:hidden");//选择被隐藏了的li
		
		<li style="display: none;">澳门</li>

#### 4.属性过滤器   不是冒号,是中括号
		<li style="...">澳门</li>
		$("[style]");//选择本html中全部含有style属性的标签
		$("li[style]");//选择全部含有style属性的li

#### 5.状态过滤器
	状态:
		disabled;不可用的 
		checked:默认选中的
		readonly:只读状态
		
		$("input:disabled");//选择状态为disabled的input标签
		$("input:checked");//选择状态为checked的input标签
		

#### 6.表单过滤器
		type的9中类型.text button....
		$(":text");//选择text类型的input

## jQuery操作DOM		

### 1.jQuery对DOM内容和值的操作
		读写节点的相关信息
		var str= obj.html();//读写节点的html
		obj.html("<span>123</span>");//设置html的内容
		
		var str=obj.text();//读取节点的文本内容
		obj.text("123");//设置节点的文本内容
		
		var str=obj.val();//读取节点的value
		obj.val("abc");//设置节点的value
		
		var str=obj.attr("属性名");//读取节点的属性值
		obj.attr("属性名","属性值");//设置节点的属性的值

### 2.jQuery增删节点
#### 2.1 创建新节点
		var obj= $("<span>你好</span>");

#### 2.2 挂到DOM树上
		parent.append(obj);//做为最后一个子节点添加进来	
		parent.prepend(obj);//做为第一个子节点添加进来
		brother.before(obj);//做为哥哥节点插入
		brother.after(obj);//做为弟弟节点插入
		
#### 2.3 删除DOM节点
		obj.remove();//删除obj这个节点
		obj.remove(selector);//删除满足selector条件的节点
		obj.empty();删除空节点	-------------------------------------------------------------?????	

		$("#city option:gt(0)").remove();
		$("#city option").remove(":gt(0)");

### jQuery对样式操作 add remove has css toggle(切换)
		obj.addClass("样式类名")
		obj.removeClass();移除所有样式
		obj.removeClass("样式类名");//移除指定的样式
		obj.hasClass("ok");//判断是否有某个样式
		obj.toggleClass("ok");切换样式,若ok样式存在则删除,不存在则添加.
		
		obj.css("样式属性");//获得具体样式的值
		obj.css("样式属性","样式的值");//设置具体样式
		obj.css("font-size","20px");
		
		$("p").addClass("important").addClass("big");//连续加样式
		
		$(function(){
			setInterval(function(){
				$("p").toggleClass("big").toggleClass("red");
			},500);
		});


## jQuery方法的返回值

### 1.任何通过$得到的对象都是jQuery对象
	1. 选择器过滤器 $("p")
	2. 转型:DOM-->jQuery    $(DOM对象)
		var oP = document.getElementsByTagName("p")[0];
		$(oP).addClass(...);
		
	3. 创建新节点
		$("<p></p>")

### 2.修改方法一般都返回jQuery对象
		obj.html("abc").removeClass();	
		obj.attr("src","../img/06.png")
		obj.addClass("red").removeClass("red");
 
### 3.查询到的元素一般都是jQuery对象

		obj.父级.兄弟

### 4.读取到的文字返回值是string
		obj.val();
		obj.html();
		obj.text();

### 5.万能确认对象的方式
		console.log();
		alert();


#=========================Webbasic_jQuery_day12===================================
# day12

## 通过节点关系,查找节点
		
		obj.children();obj.children(selector);
		//获取obj的所有直接子元素;//获取符合过滤器要求的直接子元素
		
		obj.next();obj.next(selector);
		//获取obj的弟弟/获取obj符合要求的弟弟
		
		obj.prev();obj.prev(selector);
		//获取obj的哥哥;//获取obj符合要求的哥哥
		
		obj.siblings();obj.siblings(selector);
		//获取obj的其他所有兄弟;//获取obj符合要求的其他所有兄弟;(不含自己)

		obj.find(selector);//查找满足条件的所有后代
		obj.parent();//查找obj的亲爹

### 作业
### 1.简易的二级菜单
### 2.学子商城隐藏显示
### 3.简易的购物车


#=========================Webbasic_jQuery_day13===================================
# day13

## jQuery事件
### DOM事件操作繁琐,有严重的兼容性问题
### jQuery对DOM做了封装,简化操作消除兼容问题.

### 动态绑定事件
		$(function(){
			obj.click(function(){});//简写形式,常用
			obj.bind("click","function(){}");//完整的写法,了解
		});

### 关于js的window.onload和$(function(){});
### window.onload在同一个html文件上有多个,后者覆盖前者
### $(function(){})每一个都有效

### 事件机制
		事件冒泡机制,事件从内向外传播
		作用:少写事件,通过获取事件源绑定一个事件,例如计算器.

### 取消冒泡
		js:event.stopPropagation()
			event.cancelBubble=true;

### jQuery中取消事件冒泡的做法;	
		只需要在函数中添加return false;		

### 获取事件源
		js: var obj = event.srcElement|| event.target;
		jQ: var obj = event.target;//jQuery直接兼容

### 总结:jQuery对事件的操作需要背.

### 合成事件,jQuery对事件的特殊贡献,是噱头,不是重点.
		<script type="text/javascript" src="../jquery-3.1.1.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("img:first").hover(function(){
					$("img:first").addClass("big");
					$("img:first").attr("src","../img/摇就完事了.gif");
				},function(){
					$("img:first").removeClass();
					$("img:first").attr("src","../img/楼楼.gif");
				});
				setInterval(function(){
					$("img:eq(1)").toggle(1000);
				},1000);
			});
		</script>
		
		<body>
			<img alt="#" src="../img/摇就完事了.gif">
			<img alt="#" src="../img/楼楼.gif">
		</body>
		

### hover()相当于onmouseover和onmouseout的结合
### toggle()相当于hide()和show()的结合

### 模拟事件:电脑模拟人的行为做一些操作,激发了某些事件/例如电脑帮你自动关闭页面内的广告.
### 同时调用了绑定事件函数
		obj.trigger(事件类型);
		$(":button").trigger("click");
		
		<script type="text/javascript" src="../jquery-3.1.1.min.js"></script>
		<script type="text/javascript">
		$(function(){
			$(":button").click(function(){
				$("div").slideUp(1000);
			});
			setTimeout(function(){
				$(":button").trigger("click");
			},3000);
		});
		</script>
		
		<body>
			<div>
				<input type="button" value="x">
			</div>
		</body>

## 动画
### 网页上有动效,提高用户体验,有专门的动效设计.
### 动画的本质是使用定时器连续不断的修改样式,启动定时器相当于启动了子线程.
### 事件本身是主线程,两者并发执行,互不等待

### 1.显示,隐藏
		show()/hide();
		作用:同时改变元素宽高实现显示或隐藏,(透明度也会改变)
		用法:obj.show(执行时间,回调函数);
		执行时间:
		回调函数:传给某一个方法的函数,方法执行完毕后再执行此函数.
		此处.给showed方法传入回调函数,show方法执行完毕,才执行回调函数.
		
		function fn1(){
			$("img:eq(0)").show(1000,function(){
				console.log("显示完成");
			});
			console.log("111");
		}
	
		function fn2(){
			$("img:eq(0)").hide(1000,function(){
				console.log("隐藏完成");
			});
		}
		
		<input type="button" value="显示" onclick="fn1();"> 
		<input type="button" value="隐藏" onclick="fn2();">


### 2.上下滑动式
		slideUp()/slideDown()
		作用:通过通过改变高度来实现显示或隐藏效果
		用法同上!!!

		function down() {
			$("img:eq(1)").slideDown(1000, function() {
				console.log("打开完成");
			});
		}

		function up() {
			$("img:eq(1)").slideUp(1000, function() {
				console.log("关闭完成");
			});
			$("div:eq(1)>div").slideUp(2000);
		}
		
		<input type="button" value="打开"  onclick="down();"> 
		<input type="button" value="收起"  onclick="up();">
		<img alt="#" src="../img/06.png"> 
		<img alt="#"	src="../img/07.png">
		<div></div>


### 3.淡入淡出
		
		fedeIn()/fadeOut();
		作用:通过改变透明度opacity来实现显示或隐藏
		用法同上!!!		
		
		function hint() {
			$("img:eq(2)").fadeOut(2000).fadeIn(2000);
		}
		
		<input type="button" value="淡入淡出"  onclick="hint();">
		<img alt="#"	src="../img/08.png">
		
### 4.自定义动画,动起来
### 自定义动画基于定位.相对/绝对/固定

		animate(偏移位置,执行时间,回调函数);
		偏移位置:{'left':'500px'}	描述动画执行之后元素的样式位置

### 作业 完成学子商城帮助页面跳动的椅子



#=======================数据库==============================
#======================MySQL_day01===================================
刘国斌 
bjliugb@tedu.cn
18600654335

##数据库应用场景
咨询类型网站:存新闻,存评论,存用户信息
电商类:商品,订单,用户信息
社交类:微博,用户信息,用户微博信息,评论信息

##课程介绍:
![](01.png)
##IO流文件存储的弊端
1. 效率低(开发效率低,执行效率也低)
2. 数据的增删改查非常麻烦
3. 只能保存小量数据
4. 只能存储文本数据

##什么是DB
DataBase:数据库,数据库实际上就是一个文件集合,本质就是一个文件系统,数据按照特定的格式存储到文件中,使用sql语言对数据进行增删改查操作.
##什么是DBMS
DataBaseManagementSystem:数据库管理系统,管理数据库文件的软件
- 指一种操作和管理数据库的大型软件,用于建立,使用和维护数据库,对数据进行统一的管理和控制,用户通过DBMS访问数据库中的数据
常见:mysql oracle db2 sqlserver sqlite ...
##数据库的分类
1. 关系型数据库:经过数学理论验证,可以将现实生活中存在的各种关系,保存到数据库中,这种数据库称为关系型数据库,在此数据库中,以表的形式保存数据之间的关系
2. 非关系型数据库: 主要为了解决特定的应用场景,如:缓存,高并发访问等,存储数据的方式有多种,redis是常见的非关系型数据库,redis是以键值对的形式保存数据.

##常见数据库介绍
1. mysql: oracle公司,08年被sun收购 09 sun被oracle收购 ,开源,市场占有最高
   被oracle收购后出了5.5版本由于使用了oracle核心技术,性能有了大幅提高,导致oracle用户流失,公司决定将mysql闭源,导致原mysql程序员离开并创建了mariaDB,maria创始人的女儿名字
2. oracle: oracle公司,性能最强大的数据库,而且收费最贵,通常不缺钱却技术的公司会选用,市场排名第二
3. DB2: IBM公司,闭源收费,通常一些银行项目会使用
4. sqlserver: 微软公司,排名第三,闭源收费,提供整套解决方案(web服务器,操作系统,数据库服务器等)
5. sqlite:轻量级数据库,应用在嵌入式或移动设备中,大小只有几十k,功能和性能较大型数据库要少很多

##开源和闭源
- 开源: 公开源代码,免费, 大牛程序员会维护和升级
	弊端:通过卖服务赚钱,来钱比较慢
- 闭源: 不公开源代码,收费(卖产品)
	弊端:大牛程序员会攻击找漏洞 

###mysql安装
- 参见mysql安装文档,注意两点:1. 端口号选择默认的3306
2. 字符集选择utf-8

###什么是数据库服务器
服务器:一台高配置电脑
ftp服务器:安装了ftp服务软件提供了ftp服务功能的高配置电脑
邮件服务器:安装了邮件服务的软件 供了邮件服务功能的高配置电脑
数据库服务器:安装了数据库服务的软件 供了数据服务功能的高配置电脑
web服务器:安装了web服务软件的高配置电脑

##连接数据库
- 打开终端或命令行 在终端中输入以下命令:
mysql -uroot -p然后敲回车,然后再敲回车 
- 退出指令: exit;

##什么sql
Stuctured Query Language: 结构化查询语言,sql是在关系数据库上执行各种数据操作的语言,可以查询\操纵\定义\控制数据.

##sql规范
1. 以;(分号)结尾
2. 关键字之间有空格,通常只有一个,但多个也可以
3. 可以存在换行
4. 数据库名称和表名称区分大小写

##windows电脑出现命令行中无法插入中文数据的解决方案
	在命令行中先登录mysql 然后执行 set names gbk; 通知mysql数据库服务器,客户端(命令行)的编码格式为gbk

## 数据库相关的sql语句
- 每一个工程对应一个数据库,
1. 查看所有数据库
		show databases;
2. 创建数据库
	- 格式:create database 数据库名称;	
		create database db1;
	- 指定字符集:vreate database 数据库名 character set gbk;
		create database dn2 character set gbk;
3. 查看指定数据库详情
	-格式:show create database 数据库名;
		show create database db1;
4. 删除数据库
	- 格式:drop database 数据库名;
		drop database db2;
5. 使用数据库
	- 格式:use 数据库名;
		use db1;

### 表的引擎
1. innodb:支持数据库的高级操作,包括:事务 外键等;
2. myisam:只支持数据的增删改查操作。
- 什么是表:表是关系型数据库存储数据的单位.数据库中需要先创建表,再往表里存放数据.

## 和表相关的sql
1. 创建表
	-格式: create table 表名(字段1名,字段1类型[,字段2名,字段2类型]);
		create table 1802stu(id int[,name varchar(10)]);
####创建表sql语句的执行过程:终端中写完sql语句后,敲回车,终端会把sql通过网络传输到DBMS(mysql),DBMS对sql语句进行解析,然后对数据库中的数据进行操作.	
2. 查看所有表
		show tables;
3. 查看指定表详情 和 表的字段信息
		show create table 表名;
		desc 表名;
4. 创建表指定引擎和字符集
		create table t1(id int,name varchar(10)) engine=myisam charset=gbk;
5. 删除表
		drop table 表名;
6. 修改表名
	 - 格式:rename table 原名 to 新名;
		rename table person to t_person;
7. 修改表的引擎和字符集
	- 格式:alter table 表名 engine=myisam charset=gbk;
		alter table t_person engine=myisam charset=gbk;
		desc t_person;
8. 添加表的字段
	- 最后面添加字段格式:alter table 表名 add 字段名 字段类型;
		alter table t_person add age int;
		desc t_person;
	- 最前面添加字段格式:alter table 表名 add 字段名 字段类型 first;
		alter table t_person add chinese int first;
		desc t_person;
	- 在某字段后添加字段格式:alter table 表名 add 字段名 字段类型 after 字段名;
		alter table t_person add math int after id;
		desc t_person;
9. 删除字段
	- 格式:alter table 表名 drop 字段名;
		alter table t_person drop chinese;
		desc t_person;
10. 修改字段名称和类型
	- 格式:alter table 表名 change 原字段名 新字段名 字段类型;
		alter table t_person change age myage int;
		desc t_person;
11. 修改字段的类型和位置
	- 格式:alter table 表名 modify 字段名 字段类型 first/after xxx;
		alter table t_person modify myage int after id;
		desc t_person;

##数据相关的sql
		create table t_stu(id int,name varchar(10),age int);
1. 插入数据
	- 全表插入:要求插入的数据的数量和顺序要和表字段的数据顺序一致.
	- 格式:insert into 表名 values(值1,值2,......);
		insert into t_stu values(1,'zhangsan',22);

	- 指定字段插入:	
	- 格式:insert into 表名 (字段1,字段2,...) values(值1,值2,.....);
		insert into t_stu(id,name) values(2,'lisi');
	- 批量插入:
		insert into t_stu values(3,'悟空',500),(4,'八戒',400);
		insert into t_stu(id,name) values(6,'刘备'),(7,'关羽'),(8,'貂蝉');
2. 查询数据
	- 查询所有字段:
	- 格式:select * fom 表名;
		select * from t_stu;
	- 查询指定字段
	- 格式:select 字段名1,字段名2,..字段名n from t_stu;
		select name,age from t_stu;
3. 删除数据
	- 格式:delete from 表名 where 条件;
		delete from t_stu where id=4;
		delete from t_stu where name='悟空';
4. 修改数据
	- 格式:update 表名 set 字段名=字段值 where 条件;
		update t_stu set name='张三' where id=1;
		update t_stu set name='卷帘大将',age=200 where id=5;
####使用eclipse执行sql乱码问题


#======================MySQL_day02===================================
##在eclipse中执行sql步骤:
1. 下载mysql-connector-java-5.1.6.jar 文件 记住下载的位置
2. 在eclipse->window->show View->Other ->Data Management里面选择 第一个和第三个
3. 在DataManagementExplorer里面第一个文件夹上面右键new 在弹出窗口中选择 mysql,点击下拉选旁边的添加按钮
4. 在弹出窗口中选择5.1 第二个选项卡先clearall 然后添加下载的文件 最后ok
5. 修改url 把最后的database改成db2 有密码的添加密码没有直接 点击test connection  显示ping successed 点击finish
6. 在新建的文件上面右键 open sql scrapbook

###使用eclipse执行sql乱码问题 
在建立连接的时候修改url,在数据库名称的后面添加如下代码:   ?useUnicode=true&characterEncoding=UTF-8
例如:
	jdbc:mysql://localhost:3306/db2?useUnicode=true&characterEncoding=UTF-8

##主键约束
- 什么是约束:就是创建表的时候给表字段添加的限制条件
- 主键约束的特点: 唯一并且非空,一个表中只有一个主键
- 如何使用:
		create table t1(id int primary key,name varchar(10));
	-以下两行会报错,因为id重复了
		insert into t1 values(1,'小明');
		insert into t1 values(1,'小红');
	-以下会报错 因为主键不能为null
		insert into t1 (name) values('小花');
##主键+自增 primary key auto_increment
	-如何使用:
		create table t2(id int primary key auto_increment,age int);
1. 当自增字段的值为null时会自动赋值并自增
2. 以表中曾出现的最大值+1
3. 删除数据自增数值不减
4. delete删除所有数据 自增值在原来基础上继续+1
##注释 comment
- 在创建表的时候可以通过comment对字段进行描述
	create table t3(id int primary key auto_increment comment '这是主键id',comm int comment '这是奖金');
- 如何查看注释
	show create table t3;
##`和'的区别
- `是在创建表时 修饰表名和字段的名的 可以省略
	create table `t4`(id int,`age` int);
- '是用来表示字符串的

##数据冗余
- 如果数据库设计不合理,保存大量数据后会出现大量的重复数据,这种现象称为数据的冗余 ,通过拆分表格的形式,把可能大量重复的数据,用单独一张表保存,在原表中只需要通过id建立关系即可.
###练习:
1. 创建商品表(item) 商品id 商品名称 商品价格 分类id 库存
	create table item(id int primary key auto_increment,name varchar(10),price int,categoryid int,num int);
2. 创建分类表(category) 分类id 分类的名称 上级分类
	create table category(id int primary key auto_increment,name varchar(10),parentid int);
3. 表中插入 电器分类下电视机分类下的康佳电视价格3580,库存25.
	- 分类表插入以下数据
	insert into category values(null,'电器',null);
	insert into category values(null,'电视机',1);
	- 商品表插入以下数据
	insert into item values(null,'康佳电视',3580,2,25);

###练习:设计表保存以下数据: 保存教学部下java教研部的老师信息苍老师 工资200 年龄18岁, 然后再保存集团总部下销售部,销售A部的员工李然老师,工资50,年龄28 
1. 创建部门表
	create table dept(id int primary key auto_increment,name varchar(10),parentid int);
	insert into dept values(null,'集团总部',null);
	insert into dept values(null,'教学部',1);
	insert into dept values(null,'java教研部',2);
	insert into dept values(null,'销售部',1);
	insert into dept values(null,'销售A部',4);
2. 创建员工表
	create table emp(id int primary key auto_increment,name varchar(10),sal int,age int,deptid int);
	insert into emp values(null,'苍老师',200,18,3),(null,'李然老师',50,28,5);

##事务
		create table person(id int,name varchar(10),money int);
		insert into person values(1,'超人',500),(2,'钢铁侠',1000);
	-超人和钢铁侠借300块钱 
	1. 超人+300
		update person set money=800 where id=1;
	2. 钢铁侠-300
		update person set money=700 where id=2;

- 什么是事务: 事务是数据库中执行sql语句的最小工作单元,在同一个事务中的sql语句要么同时成功,要么同时失败.
- mysql数据库默认sql语句是自动提交的
- 关闭数据库的自动提交
	-查看自动提交的状态:
		show variables like '%autocommit%';
	-关闭自动提交  如果需要打开自动提交把0换成1
		set autocommit=0;
	-验证转账流程:
		update person set money=800 where id=1;
	-此时打开一个新的终端,在新终端中查看是否修改(没改)
	-回到原窗口执行下面sql commit之后再去新窗口验证(改了)
		update person set money=700 where id=2;
		commit;
	- 回滚 rollback
		执行rollback会回滚到上次提交的点或者关闭自动提交时的点
	- 保存回滚点 savepoint s1(标识);
		update person set money=100 where id=1;
		savepoint s1;
		update person set money=200 where id=1;
		rollback to s1;
- 回顾:执行sql的最小工作单元 同时成功,同时失败
	show variables like '%autocommit%';
	关闭或打开
	set autocommit=0/1;
	提交
	commit	
	回滚 rollback 
	保存回滚点 savepoint s1
	回滚到某个回滚点 rollback to s1

**SQL分类**
##DDL Data Definition Language 数据定义语言
- 包括: create drop alter truncate
- 不支持事务
##DML Data Manipulation Language 数据操作语言
- 包括: insert update delete select()
- 支持事务
##DQL Data Query Language 数据查询语言
- 只有select
- 也属于DML
##TCL Transaction Control Language 事务控制语言
- 包括:commit rollback savepoint  rollback to
##DCL Data Control Language 数据控制语言
- 分配用户权限的相关sql


DDL 数据定义语言: create drop alter truncate 不支持事务
DML 数据操作语言:insert update delete select 支持事务
DQL 数据查询语言:Select 
TCL 事务控制语言: commit rollback 等
DCL 数据控制语言:分配用户权限

###truncate
	-格式:truncate table 表名;
- 作用:删除表并创建一张空表,auto_increment数值清零

##数据库数据类型
###整型
- 常用:int(m) bigint(m) m代表显示长度,如果字段数值长度不到m时 会在数值的前面补零,但是一定要和 zerofill结合使用
	例如: create table t_int(num int(10) zerofill);
	insert into t_int values(15);
	select * from t_int;
###浮点数
- 常用:double(m,d) m代表总长度,d代表小数长度 如:76.232     m=5 d=3;
- decimal(m,d) 超高精度小数,需要涉及高精度运算时使用decimal
###字符串
- char(m): 长度不可变 m=20  abc 20 执行效率高 最大值255 
- varchar(m):长度可变 m=20  abc 3  节省资源 最大值:65535但是超过255建议使用text
text: 可变长度,最大65535
###日期类型
- date: 只能保存年月日
- time: 只能保存时分秒
- datatime:年月日时分秒 9999-12-31 默认值为null
- timestamp:年月日时分秒 2038-01-19 默认值为当前时间
- 练习:创建时间的表
	 create table t_date(d1 date,d2 time,d3 datetime,d4 timestamp);
	insert into t_date values('2018-03-22',null,null,null);
	insert into t_date values('2018-03-22','12:22:38','2008-08-08 18:08:18',null);

#回顾:
1. 主键 自增
	primary key auto_increment
2. 注释 
	comment
3. `和'
4. 数据冗余
5. 事务:执行sql语句的最小单元 
	show variables like '%autocommit%';
	set autocommit=0/1;
	rollback
	commit
	savepoint s1;
	rollback to s1;
6. 数据库sql分类
	- DDL 数据定义语言 不支持事务 create drop alter truncate
	- DML 数据操作语言 支持事务 insert update delete select
	- DQL 数据查询语言 select
	- TCL 事务控制语言 
	- DCL 数据控制语言 分配用户权限
7. 数据类型
	-整型 int bigint(m)  zerofill
	-浮点型 double(m,d)  decimal(m,d) 
	-字符串 char(m)不可变 255 varchar可变 65535 text 可变 65535   longtext
	-日期
	date 年月日
	time 时分秒
	datetime  null 9999-12-31
	timestamp 当前值  2038-01-19


#======================MySQL_day03===================================
#Day03
1. 创建四张表 导入一堆数据

	验证四张表是否都有数据
		select * from emp;
		select * from dept;
		select * from t_item;
		select * from t_item_category;

## 没有条件的查询
	select * from 表名;
	select 字段1,字段2... 表名;

## 带条件查询
### 列值为null 和 不为null
1. 查询没有上级领导的员工编号,姓名,工资
		select empno,ename,sal from emp where mgr is null;
2. 查询有上级领导的员工编号,姓名,领导编号
		select empno,ename,mgr from emp where mgr is not null;
-练习: 查询没有奖金(comm)的员工信息
		select * from emp where comm is null;

###别名
		select empno as '员工编号',ename as '姓名' from emp;
		select empno '员工编号',ename '姓名' from emp;
		select empno 员工编号,ename 姓名 from emp;

###去重 distinct
	-查询emp表中所有员工的职位
		select distinct job from emp;

###比较运算符   > < = >= <=  !=(<>)
1. 查询工资高于2000的所有员工编号,姓名,职位,工资
		select empno,ename,job,sal from emp where sal>2000;
2. 查询工资小于等于1600的所有员工编号,姓名,工资
		select empno,ename,sal from emp where sal<=1600;
3. 查询部门编号是20的所有员工的姓名,职位,部门编号
		select ename,job,deptno from emp where deptno=20;
4. 查询职位是manager的所有员工姓名,职位
		select ename,job from emp where job='manager';
5. 查询不是10号部门的所有员工姓名,工资,部门编号(两种写法)
		select ename,sal,deptno from emp where deptno!=10(deptno<>10);
6. 查询单价等于23的商品信息
		select * from t_item where price=23;
7. 查询单价不等于8443的商品信息
		select * from t_item where price!=8443;

###and和or
- and等效java的 &&
- or等效java的 ||
1. 查询不是10号部门,工资小于3000的员工编号,姓名,工资,部门编号
		select empno,ename,sal,deptno from emp where deptno!=10 and sal!=3000;
2. 查询部门是30或者上级领导为7698的所有员工的姓名,部门编号,上级领导编号
		select ename,deptno,mgr from emp where deptno=30 or mgr=7698;

## in
- 如果查询字段的值为多个的时候可以使用in关键字
1. 查询person表中 年龄(age)是25,28,30,22岁的所有信息
		select * from person where age in (25,28,30,22);

## between x and y
-在某两个数值之间, 包含and两边的数值
1. 查询员工工资在500-1000的所有员工名字和工资
		select ename,sal from emp where sal between 500 and 1000;

## like
- _:代表单个未知字符
- %:代表多个未知字符
- 举例:
	-以a开头 
		字段名 like a% 
	-以a结尾 
		字段名 like %a
	-第二个字符是a; 
		字段名 like _a%
	-包含a; 
		字段名 like %a%
	-倒数第三个字符是a; 
		字段名 like %a__
	-第二个和最后一个是a; 
		字段名 like _a%a
	-不包含a字符; 
		字段名 not like '%a%';
1. 查询名字以k开头的所有员工名字
		select ename from emp where ename like 'k%';
2. 查询商品标题包含记事本的商品
		select title from t_item where title like '%记事本%';
3. 查询单价低于100的记事本
		select title,price from t_item where title like '%记事本%' and price!=100;
4. 查询有图片的得力商品
		select title,image from t_item where title like '%得力%' and image is not null;
5. 查询单价介于50到200之间的得力商品
		select title,price from t_item	where price between 50 and 200 and title like '%得力%';
6. 查询有赠品的dell商品(卖点中带赠字)
		select title,sell_point from t_item where title like '%dell%'	and sell_point like '%赠%';
7. 查询标题不包含得力的商品
		select title from t_item where title not like '%得力%';
8. 查询价格介于50和200之外的所有商品
		select * from t_item where price not between 50 and 200;

##查询结果排序 order by 
- 格式: order by 字段名
- 默认升序, 升序是:asc  降序:desc
1. 查询员工的名称和工资 按照工资降序排序
		select ename,sal from emp order by sal desc;
2. 查询单价在100以下的商品名称和价格,按照价格降序排序
		select title,price from t_item	where price!=100 order by price desc;
- 多字段排序,当第一个字段有相同值时,第二个字段排序开始

1. 查询所有员工名称,部门编号,工资, 部门编号降序排序,工资升序排序
		select ename,deptno,sal from emp order by deptno desc,sal;
2. 查询所有dell商品,按分类id升序,单价降序排序
		select title,category_id,price from t_item
		where title like '%dell%' order by category_id,price desc;

###limit 分页查询
- limit 跳过总条数,每页查询条数
1. 查询商品表中商品名称和价格,第2页数据每页5条
		select title,price from t_item	limit 5,5;
2. 查询所有商品,单价升序,显示第三页,每页3条数据
		select title,price from t_item	order by price limit 6,3;
3. 查询拿最高工资的员工信息
		select * from emp	order by sal desc	limit 0,1;

###数值计算 + - * /  % (mod())
1. 查询所有商品的单价,库存,总价
		select price,num,price*num from t_item;
- %和mod都是取余的作用 
	7%2 等效 mod(7,2)

###日期相关函数
1. 获取当前日期+时间  now()
		select now();
2. 获取当前日期
		select curdate();
3. 获取当前时间
		select curtime();
4. 从日期和时间中提取日期
		select date(now());
5. 从日期和时间中提取时间
		select time(now());
- 案例: 查询商品创建的年月日
		select date(created_time) from t_item
6. 提取年 月 日 时 分 秒
	-select extract(year from now());	
	-select extract(month from now());
	-select extract(day from now());
	-select extract(hour from now());
	-select extract(minute from now());
	-select extract(second from now());
- 案例:查询入职的年份	
		select extract(year from hiredate) from emp;
7. 日期格式化 date_format()
	-格式: date_format(时间,格式)
	-%Y 4位年  2018
	-%y 2位年  18
	-%m 2位月  05
	-%c 1位月  5
	-%d 日
	-%H 24小时
	-%h 12小时
	-%i 分
	-%s 秒
- 案例: 
		select date_format(now(),'%Y年%m月%d日 %H时%i分%s秒');
- 练习:查询商品的创建日期(created_time) 年月日
		select date_format(created_time,'%Y年%m月%d日') from t_item;
8. 把不规则日期格式转成标准格式
	-格式: str_to_date(日期字符串,格式)
		select str_to_date('25号12月2015年','%d号%m月%Y');

###ifnull() 
- 格式: age=ifnull(x,y) 判断x是否为null如果是 age=y如果不是age=x;
- 案例:把员工表 没有奖金的 奖金修改为0;
		update emp set comm=ifnull(comm,0);

##聚合函数
-对多行数据进行合并统计
- 求和  sum(字段名) 比如:求工资总和 sum(sal)
- 平均值 avg(字段名) 比如:求工资平均值 avg(sal)
- 最大值 max(字段名) 比如:求奖金最大值 max(comm)
- 最小值 min(字段名) 比如:求年龄最小值 min(age)
- 统计数量 count(*) 
1. 查询员工表的平均工资
		select avg(sal) from emp;
2. 查询10号部门的最高工资
		select max(sal) from emp where deptno=10;
3. 查询dell商品的库存总和
		select sum(num) from t_item where title like '%dell%';
4. 查询得力商品的条数
		select count(*) from t_item where title like '%得力%';
5. 查询员工姓名中包含a的 最低工资
		select min(sal) from emp	where ename like '%a%';

##字符串相关函数
1. concat(a,b)  字符串连接函数
		select concat('a','b');
- 案例:查询每个员工的工资 工资后面显示元
		select ename,concat(sal,'元') from emp;
2. char_length(str) 获取字符串的长度
- 案例: 获取每个员工姓名的长度
		select ename,char_length(ename) from emp;
3. instr(str,subStr)获取subStr在Str中的位置
		select instr('nba','a');
4. locate(subStr,str)获取subStr在Str中的位置
		select locate('a','nba');
5. insert(str,start,length,newstr)插入字符串
		select insert('abcdefg',3,2,'m'); 
6. lower(str) 转小写
		select lower('NBa');
7. upper(str) 转大写
		select upper('nBa');
8. trim(str) 去两端空白
		select trim('   abc  ');
9. left(str,length) 从左边截取多少个字符
		select left('abcdefg',3);
10. right(str,length)从右边截取多少个字符
		select right('abcdefg',3);
11. substring(str,index,length)截取字符串
		select substring('abcdefg',2,3);
12. replace(str,old,new) 替换字符串
		select replace('我爱苍老师','我','你们');
13. repeat(str,count)重复
		select repeat('加油',2);
14. reverse(str) 反转
		select reverse('我爱苍老师');

##数学相关函数
1. 向下取整 floor(num)
		select floor(3.23);
2. 四舍五入 round(num)
		select round(2.7);
	-round(num,m);
		select round(3.283749,2);
3. truncate(num,m); 非四舍五入
		select truncate(3.283749,1);
4. 随机数 rand()  0-1
		select floor(rand()*6);//0-5

	1.案例：查询没有上级领导的员工的编号，姓名，工资
	2.案例：查询emp表中没有奖金的员工的姓名，职位，工资，以及奖金
	3.案例：查询emp表中含有奖金的员工的编号，姓名，职位，以及奖金
	4.案例：查询含有上级领导的员工的姓名，工资以及上级领导的编号
	5.案例：查询emp表中名字以‘S’开头的所有员工的姓名
	6.案例：查询emp表中名字的最后一个字符是'S'的员工的姓名
	7.案例：查询倒数的第2个字符是‘E’的员工的姓名
	8.案例：查询emp表中员工的倒数第3个字符是‘N’的员工姓名
	9.案例：查询emp表中员工的名字中包含‘A’的员工的姓名	
	10.案例：查询emp表中名字不是以'K'开头的员工的所有信息
	11.案例：查询emp表中名字中不包含‘A’的所有员工的信息
	12.案例：做文员的员工人数（job_id 中 含有 CLERK 的）
	13.案例：销售人员 job: SALESMAN 的最高薪水
	14.案例：最早和最晚入职时间
	15.案例：查询类别 163的商品总库存量
	16.案例：查询 类别 163 的商品
	17.案例：查询商品价格不大于100的商品名称列表
	18.案例：查询品牌是联想,且价格在40000以上的商品名称和价格
	19.案例：查询品牌是三木,或价格在50以下的商品名称和价格
	20.案例：查询品牌是三木、广博、齐心的商品名称和价格
		select title,price from t_item
		where title like '%三木%' or title like '%广博%' or title like '%齐心%'; 
	21.案例：查询品牌不是联想、戴尔的商品名称和价格
		select title,price from t_item
		where title not like '%联想%' and title not like '%戴尔%' 
	22.案例：查找品牌是联想且价格大于10000的电脑名称
		select title from t_item
		where title like '%联想%' and price>10000
	23.案例：查询联想或戴尔的电脑名称列表
		select title from t_item
		where title  like '%联想%' or  like '%戴尔%'
	25.案例：查询不是戴尔的电脑名称列表
		select title from t_item
		where title not like '%戴尔%'
	26.案例：查询所有是记事本的商品名称和价格
		select title,price from t_item
		where title like '%记事本%'
	27.案例：查询品牌是末尾字符是'力'的商品的名称和价格
		select title,price from t_item
		where title like '%力';
	30.案例：查询emp表中员工的编号，姓名，职位，工资，并且工资在1000~2000之间。
		select empno,ename,job,sal from EMP
		where sal between 1000 and 2000
	31.案例：查询emp表中员工在10号部门，并且含有上级领导的员工的姓名，职位，上级领导编号以及所属部门的编号
		select ename,job,mgr,deptno from emp
		where deptno=10 and mgr is not null;
	32.案例：查询emp表中名字中包含'E'，并且职位不是MANAGER的员工的编号，姓名，职位，以及工资。	
		select empno,ename,job,sal from emp
		where ename like '%E%' and job != 'manager'
	33.案例：查询emp表中10号部门或者20号部门中员工的编号，姓名，所属部门的编号
		select empno,ename,deptno from emp
		where deptno in (10,20);
	34.案例：查询emp表中没有奖金或者名字的倒数第2个字母不是T的员工的编号，姓名，职位以及奖金
		select empno,ename,job,comm from emp
		where comm is null or comm=0 or ename not like '%T_';
	35.案例：查询工资高于3000或者部门编号是30的员工的姓名，职位，工资，入职时间以及所属部门的编号	
		select ename,job,sal,hiredate,deptno from emp 
		where sal>3000 or deptno=30
	36.案例：查询不是30号部门的员工的所有信息
		select * from emp
		where deptno!=30
	37.案例：查询奖金不为空的员工的所有信息
		select * from emp
		where comm is not null
	38.案例：查询emp表中所有员工的编号，姓名，职位，根据员工的编号进行降序排列
		select empno,ename,job from emp order by empno desc
	39.案例：查询emp表中部门编号是10号或者30号中，所有员工姓名，职务，工资，根据工资进行升序排列
		select ename,job,sal from emp
		where deptno in(10,30) order by sal;
	40.案例：查询emp表中所有的数据，然后根据部门的编号进行升序排列，如果部门编号一致，根据员工的编号进行降序排列
		select * from emp order by deptno,empno desc
	41.案例：查询emp表中工资高于1000或者没有上级领导的员工的编号，姓名，工资，所属部门的编号，以及上级领导的编号，根据部门编号进行降序排列，如果部门编号一致根据工资进行升序排列。
		select empno,ename,sal,deptno,mgr from emp
		where sal>1000 or mgr is null 
		order by deptno desc,sal;
	42.案例：查询emp表中名字中不包含S的员工的编号，姓名，工资，奖金，根据工资进行升序排列，如果工资一致，根据编号进行降序排列.
		select empno,ename,sal,comm from emp
		where ename not like '%S%' order by sal,empno desc
	43.案例：统计emp表中员工的总数量
		select count(*) from emp
	44.案例：统计emp表中获得奖金的员工的数量
		select count(*) from emp
		where comm>0 and mgr is not null;
	45.案例：求出emp表中所有的工资累加之和
		select sum(sal) from emp;
	46.案例：求出emp表中所有的奖金累加之和
		select sum(comm) from emp;
	47.案例：求出emp表中员工的平均工资
		select avg(sal) from emp;
	48.案例：求出emp表中员工的平均奖金
		select avg(comm) from emp;
	49.案例：求出emp表中员工的最高工资
		select max(sal) from emp;
	50.案例：求出emp表中员工编号的最大值
		select max(empno) from emp;
	51.案例：查询emp表中员工的最低工资。
		select min(sal) from emp;
	52.案例：查询emp表中员工的人数，工资的总和，平均工资，奖金的最大值，奖金的最小值,并且对返回的列起别名。
		select count(*) c, sum(sal) s,avg(sal) a,max(comm) max,min(comm) min from emp;
	53.案例：查询emp表中每个部门的编号，人数，工资总和，最后根据人数进行升序排列，如果人数一致，根据工资总和降序排列。
		select deptno,count(*) c,sum(sal) s from emp group by deptno order by c,s desc;
		select deptno,count(*),sum(sal) from emp group by deptno order by count(*),sum(sal) desc;
	54.案例：查询工资在1000~3000之间的员工信息，每个部门的编号，平均工资，最低工资，最高工资，根据平均工资进行升序排列。
		select deptno,avg(sal) a,min(sal),max(sal) from emp where sal between 1000 and 3000
		group by deptno order by a;
	55.案例：查询含有上级领导的员工，每个职业的人数，工资的总和，平均工资，最低工资，最后根据人数进行降序排列，如果人数一致，根据平均工资进行升序排列
		select count(*) c,sum(sal),avg(sal) a,min(sal) from emp	
		where mgr is not null group by job order by c desc,a;
	-- 1. 每个部门中，每个主管的手下人数
		select deptno,mgr,count(*) from emp 
		where mgr is not null group by deptno,mgr;
		
	-- 2. 每种工作的平均工资
		select job,avg(sal) from emp
		group by job;
	-- 提高题 3. 每年的入职人数
		select count(*),extract(year from hiredate) year from emp
		group by year;
	56.案例：查询工资在1000~3000之间每一个员工的编号，姓名，职位，工资
		select * from emp where sal between 1000 and 3000
	57.案例：查询emp表中奖金在500~2000之间所有员工的编号，姓名，工资以及奖金
		select * from emp where comm between 500 and 2000
	58.案例：查询员工的编号是7369，7521，
		select * from emp where empno in(7369,7521)	
	59.案例：查询emp表中，职位是ANALYST，
		select * from emp where job='analyst'
	60.案例：查询emp表中职位不是ANALYST,
		select * from emp where job!='analyst'


#======================MySQL_day04======================================
## 分组查询 group by
- 分组查询通常和聚合函数结合使用
- 查询条件中每个XXX 就以XXX做为分组条件.
- 格式: select deptno,avg(sal) from emp group by deptno;
###练习 
1. select deptno,max(sal) from emp group by deptno;
2. select category_id ,sum(num) from t_item group by category_id;
3. select deptno ,count(*) from emp group by deptno;
4. select deptno ,count(*) from emp where sal>2000 group by deptno;
5. select category_id ,count(*) from t_item where price>100 group by category_id;

## having 有条件的分组统计
- where后面写普通字段条件
- Having后面写聚合函数条件,通常是和group by结合使用,Having写在group by后面
- 查询每个部门的平均工资,要求平均工资大于2000;
		select deptno,avg(sal) a from emp group by deptno having a>2000;

###练习:
1. select category_id,sum(num) a from t_item group by category_id having a>100000;
2. select category_id,avg(price) p from t_item group by category_id having p>100;
3. select deptno,ename,avg(sal) a from emp 
	where ename like '%a%' group by deptno having a>2000;

- sql 中各个关键字的顺序
select...from 表名 [right] join 表名 on...where...group by...having...order by...limit...
		
## 子查询	
- 嵌套在sql语句里面的sql查询语句
- 可以多层嵌套
- 可以写在的位置: 
1. where后面做查询条件的值
2. from后面做新表 **必须起别名**
	- select* from(select*from xxx) 别名;
3. 写在创建表的时候
	create table newt1 as (select 字段1,字段2 from 表名);
	将查询的结果做为一个新表创建出来

	select ename,sal from emp where sal=(select max(sal) from emp);	
	select ename,sal from emp where sal>(select avg(sal) from emp);
	select * from emp where hiredate=(select min(HIREdate) from emp);

	select * from t_item_category where id in (select distinct category_id from t_item);
	select * from dept where deptno in (select distinct deptno from emp);
	select avg(sal) a from emp group by deptno order by a desc limit 0,1;
	select deptno from emp group by deptno having avg(sal)=(select avg(sal) a from emp group by deptno order by a desc limit 0,1); 
	select * from dept where deptno in(select deptno from emp group by deptno having avg(sal)=(select avg(sal) a from emp group by deptno order by a desc limit 0,1));

## 关联查询
- 同时查询多张表的数据称为关联查询
1. 查询每一个员工姓名和所对应的部门名称
		select emp.ename,dept.dname from emp,dept where emp.deptno=dept.deptno;
		
2. 查询每个商品的标题，商品单价，商品分类名称；
		select i.title,i.price,c.name from t_item i,t_item_category c where i.category_id=c.id;
3. 查询在new york 工作的所有员工信息
		select e.* from emp e,dept d where e.deptno=d.deptno and d.loc='new york';

##笛卡尔积
- 关联查询 若不写关联关系,则查询结果为两张表的乘积.
- 这是错误的查询结果,工作中不能出现

##等值连接和馁连接
- 等值连接和内连接都是关联查询的查询方式,效果相同
- 等值连接格式:select*from A,B where A.x=B.x and A.y=abc;
- 内连接格式:select*from A [inner] join B on A.x=B.x where A.y=abc;可读性高,用的多
		select e.* from emp e join dept d on e.deptno=d.deptno where d.loc='new york';

## 外连接
- 关联查询时,内连接不满足需求时,可以使用外连接.
- 左外连接格式:select*from A left [outer] join B on A.x=B.x where A.y=abc;
	以join左边为主表
- 右外连接格式:select*from B right [outer] join A on B.x=A.x where A.y=abc;
	以join右边为主表
		
		select emp.ename,dname from emp left join dept on emp.deptno=dept.deptno;
		select emp.ename,dname from emp right join dept on emp.deptno=dept.deptno;

### 强化练习
	-- 查询出所有有地址的员工
		select * from
		emp e join dept d
		on e.deptno=d.deptno
		where d.loc is not null;
	-- 查询出所有用户,同时查出这些用户的地址
		select * from
		emp e left join dept d
		on e.deptno=d.deptno;
	-- 查询出所有的地址,同事查出地址所对应的用户信息
		select * from
		emp e right join dept d
		on e.deptno=d.deptno;
## 练习

  1. 每个部门的人数,根据人数排序
		select deptno,count(*) c from emp group by deptno order by c;
  2. 每个部门中，每个主管的手下人数
		select deptno,mgr,count(*) from emp group by deptno,mgr;
  3. 每种工作的平均工资
		select job,avg(sal) from emp group by job
  4. 每年的入职人数 
		select extract(year from hiredate) year,count(*) from emp 
		group by year;
  5. 少于等于3个人的部门
		select deptno,count(*) c from emp
		group by deptno 
		having c<=3;
  6. 拿最低工资的员工信息
		select * from emp where sal=(select min(sal) from emp);
  7. 只有一个下属的主管信息 **好好消化**
		-先通过mgr分组 统计人数 让人数=1
	- 关联查询
		select e.* from
		emp e join (select mgr,count(*) c from emp
		group by mgr
		having c=1)n
		on e.empno=n.mgr; 
	- 子查询
		select * from emp where empno in (
		select mgr from emp 
		where mgr is not null
		group by mgr
		having count(*)=1); 
		
  8. 平均工资最高的部门编号
		select deptno from emp 
		group by deptno
		order by avg(sal) desc
		limit 0,1;
  9. 下属人数最多的人，查询其个人信息
		select * from emp where empno=(select mgr from emp
		group by mgr
		order by count(*) desc limit 0,1);
		
		select * from emp where empno in (select mgr from emp
		group by mgr
		having count(*)=(select count(*) c from emp
		group by mgr
		order by c desc
		limit 0,1));
		
		select * from emp
		group by mgr
		having count(*)=(select count(*) c from emp
		group by mgr
		order by c desc
		limit 0,1);
		
  10. 拿最低工资的人的信息
		select * from emp where sal=(select min(sal) from emp);
  11. 最后入职的员工信息
		select * from emp where hiredate=(select max(hiredate) from emp);
  12. 工资多于平均工资的员工信息
		select * from emp where sal>(select avg(sal) from emp);
  13. 查询员工信息，部门名称
        select e.*,d.dname
		from emp e join dept d
		on e.deptno=d.deptno
  14. 员工信息，部门名称，所在城市
      	select e.*,d.dname,d.loc
		from emp e join dept d
		on e.deptno=d.deptno
  15. DALLAS 市所有的员工信息
		select e.*
		from emp e join dept d
		on e.deptno=d.deptno
		where d.loc='dallas';
  16. 按城市分组，计算每个城市的员工数量
     	select d.loc,count(*)
		from emp e join dept d
		on e.deptno=d.deptno 
		group by d.loc;
  17. 查询员工信息和他的主管姓名
		select e.*,m.ename
		from emp e join emp m
		on e.mgr=m.empno;
  18. 员工信息，员工主管名字，部门名
	  第一种在第17上直接join的方式
		select e.ename,m.ename,d.dname
		from emp e join emp m
		on e.mgr=m.empno 
		join dept d
		on e.deptno=d.deptno;
	  第二种把17查询结果当成新表
		select n.*,d.dname
		from (select e.*,m.ename 主管名
		from emp e join emp m
		on e.mgr=m.empno)n join dept d
		on n.deptno=d.deptno;
		注意:如果多表查询时出现重复字段名称 需要通过别名的方式进行区分
  20. 员工和他所在部门名
		select e.ename,d.dname
		from emp e join dept d
		on e.deptno=d.deptno;
  22. 案例：查询emp表中所有员工信息以及该员工上级领导的信息
		select * from emp e left join emp m
		on e.mgr=m.empno;	
  23. 案例：查询emp表中名字中没有字母'K'的所有员工的编号，姓名，职位以及所在部门的信息
		select e.empno,e.ename,e.job,d.*
		from emp e left join dept d
		on e.deptno=d.deptno
		where e.ename not like '%k%';
  24. 案例：查询dept表中所有的部门的所有的信息，以及与之关联的emp表中员工的编号，姓名，职位，工资
		select d.*,e.empno,e.ename,e.job,e.sal
		from dept d left join emp e
		on d.deptno=e.deptno;

#======================MySQL_day05===================================
##表设计之关联关系
###一对一:
- 什么是一对一:有两张表A和B,A表中有一条数据对应B表中的一条数据称为一对一关系
- 应用场景: 用户表和用户信息扩展表,商品表和商品信息扩展
- 如何建立关系:在从表中添加一个字段记录主表的id,用户表和用户信息扩展表中,用户表为主表,信息扩展表为从表,用户表中的id 称为主键, 从表中记录主表id的字段称为外键,主键用来表示数据的唯一性,外键用来和其它表建立关系.

- 练习:创建user(id,username,password)和userinfo(id,nick,age,phone)两张表然后往两个表里面各插入3条有关系的数据
		create table user(id int primary key auto_increment,username varchar(10),password varchar(10));
		create table userinfo(id int,nick varchar(10),age int,phone varchar(15));
- 插入数据
		insert into user values(null,'libai','admin'),(null,'lisi','admin'),(null,'liubei','123');
		insert into userinfo values(1,'李白',25,'13838383388'),(2,'李四',15,'131223232'),(3,'刘备',40,'2342342');
1. 查询每一个用户的用户名,昵称,电话
		select u.username,ui.nick,ui.phone
		from user u join userinfo ui
		on u.id=ui.id;
2. 查询名字叫李白的所有信息
		select *
		from user u join userinfo ui
		on u.id=ui.id
		where ui.nick='李白';
###一对多
- 什么是一对多:AB两张表中A表中一条数据对应B表中多条数据,并且B表中一条数据对应A表中一条数据,两张表的关系称为一对多.
- 应用场景:部门和员工,商品和分类等
- 如何建立关系: 一对多的两张表,在多的表中添加一个字段记录另外一张表的id.
- 练习:创建t_emp(id,name,sal,deptid),t_dept(id,name,loc), 两张表中插入数据:部门表插入神仙部loc为西天, 妖怪部 loc为盘丝洞, 员工表插入,猪八戒,孙悟空,蜘蛛精和白骨精.
		create table t_emp(id int primary key auto_increment,name varchar(10),sal double,deptid int);
		create table t_dept(id int primary key auto_increment,name varchar(10),loc varchar(20));
		insert into t_dept values(null,'神仙','西天'),(null,'妖怪','盘丝洞');
		insert into t_emp values(null,'猪八戒',2000,1),(null,'孙悟空',3000,1),(null,'蜘蛛精',1000,2),(null,'白骨精',4000,2);
	
1. 查询每个部门对应的每个员工
		select *
		from t_emp e join t_dept d
		on e.deptid=d.id
2. 查询每个员工对应的每个部门只显示工资大于2000的信息,
		select *
		from t_emp e join t_dept d
		on e.deptid=d.id
		where e.sal>2000;
###多对多
- 什么是多对多:AB两张表,A表中的一条数据对应B表的多条数据,同时B表的一条数据对应A表的多条数据,这种关系称为多对多
- 应用场景: 老师表和学生表,用户表和角色表
- 如何建立关系:需要创建一个关系表,在关系表中记录两个表的id.
- 练习: 创建老师(id,name)和学生表(id,name),创建老师和学生关系表t_s(tid,sid)
		create table teacher(id int primary key auto_increment,name varchar(10));
		create table student(id int primary key auto_increment,name varchar(10));
		create table t_s(tid int,sid int);

		insert into teacher values(null,'唐僧'),(null,'刘备'),(null,'苍老师');
		insert into student values(null,'悟空'),(null,'关羽'),(null,'小明');
1. 关系表中插入数据唐僧是悟空和小明的老师,刘备是关羽的老师,苍老师是所有人的老师
	insert into t_s values(1,1),(1,3),(2,2),(3,1),(3,2),(3,3);
2. 查询老师和学生表中 每个学生名子和对应的老师名字
	select s.name,t.name
	from teacher t join t_s ts
	on t.id=ts.tid
	join student s
	on ts.sid=s.id;
3. 查询苍老师的所有学生姓名
	select s.name
	from teacher t 
	join t_s ts
	on t.id=ts.tid
	join student s
	on ts.sid=s.id
	where t.name='苍老师';
4. 查询小明的所有老师
	select t.name
	from teacher t join t_s ts
	on t.id=ts.tid
	join student s
	on ts.sid=s.id
	where s.name='小明';
- 子查询方式:
	select name from teacher where id in(select tid from t_s where sid=(select id from student where name='小明'));

###自关联
- 什么是自关联:在一张表中有一个字段指向当前表的id,这种称为自关联
- 是什么时候使用自关联:当保存的数据有层级关系并且不确定有多少层的时候使用自关联.
1. 查询员工姓名和对应的上级姓名
		select e.ename,m.ename
		from emp e join emp m
		on e.mgr=m.empno
###连接方式和关联关系
- 连接方式:包括内连接和外连接(左外和右外),是指通过sql查询两张表数据时使用的查询方式.
- 关联关系:包括一对一,一对多,多对多,是指设计表时两张表之间存在的逻辑关系.

###案例:权限管理的表设计
1. 创建db5数据库并use,创建5张表: user(id,name),role(id,name),module(id,name),
用户和角色关系表u_r(uid,rid),
角色和权限关系表r_m(rid,mid)
		create table user(id int primary key auto_increment,name varchar(10));
		create table role(id int primary key auto_increment,name varchar(10));
		create table module(id int primary key auto_increment,name varchar(10));

		create table u_r(uid int,rid int);
		create table r_m(rid int,mid int);
2. 插入数据user:刘德华,张学友,凤姐 role:男游客,男会员,女游客,女管理员 module:男浏览,男发帖,女浏览,女发帖,女删帖
		insert into user values(null,'刘德华'),(null,'张学友'),(null,'凤姐');
		insert into role values(null,'男游客'),(null,'男会员'),(null,'女游客'),(null,'女管理员');
		insert into module values(null,'男浏览'),(null,'男发帖'),(null,'女浏览'),(null,'女发帖'),(null,'女删帖');
3. 建立关系 刘德华是男游客 张学友是男会员,凤姐是女游客和男会员, 男游客对应男浏览 男会员对应男浏览和男发帖 女游客对应女浏览,女管理员对应女浏览女发帖和女删帖
		insert into u_r values(1,1),(2,2),(3,3),(3,2);
		insert into r_m values(1,1),(2,1),(2,2),(3,3),(4,3),(4,4),(4,5);
- 做题:
1. 查询每个用户对应的所有权限
	    select u.name,m.name
    	from user u join u_r ur
    	on u.id=ur.uid
    	join r_m rm
    	on ur.rid=rm.rid
    	join module m
    	on rm.mid=m.id;
    	
2. 查询刘德华对应的所有权限
		select u.name,m.name
		from user u join u_r ur
		on u.id=ur.uid
		join r_m rm
		on ur.rid=rm.rid
		join module m
		on rm.mid=m.id
		where u.name='刘德华';
		
3. 有男发帖的用户都有哪些
		select u.name,m.name
		from user u join u_r ur
		on u.id=ur.uid
		join r_m rm
		on ur.rid=rm.rid
		join module m
		on rm.mid=m.id
		where m.name='男发帖';

##课程回顾
1. 关联关系: 
- 一对一: 从表中添加字段记录主表的id
- 一对多: 从多的表中添加字段记录另一个表的id
- 多对多: 创建中间关系表保存关系
- 自关联: 自己关联自己 把一张表当两张表查询
2. 连接方式: 内连接和外连接(左右) 
3. 权限管理:5张表   用户表 角色表 权限表 用户-角色  角色-权限

		use db5;
人名表:person
		create table person(personid int primary key auto_increment,
		name varchar(10),genid int,relationid int);
红包流水表:trade
		create table trade(tradeid int primary key auto_increment,
		tradetime date,tradeamount int,modeid int,personid int);
方式表:mode
		create table mode(modeid int primary key auto_increment,
		payment varchar(10));
关系表:relation
		create table relation(relationid int, rela varchar(10));
			
性别表:
		create table gender(genid int,	gen varchar(10));
		insert into gender values(1,'男'),(2,'女');

		str_to_date('2018-02-15','%Y-%m-%d');----------???????????????
		select sum(tradeamount) from trade where tradetime>='2018-02-15';
		
		select person.name,trade.tradeamount from trade join person 
		on trade.personid=person.personid
		join relation 
		on person.relationid=relation.relationid
		where person.genid=2 and relation.relationid=1;
		
		select mode.payment,sum(tradeamount)from trade join mode on trade.modeid=mode.modeid
		group by mode.payment; 
		
		insert into trade values(1,'2018-02-14',500,3,1),	(2,'2018-02-15',-300,1,3),
		(3,'2018-02-16',80,2,2),(4,'2018-02-17',300,3,4);
		
		insert into mode values(1,'微信'),(2,'支付宝'),(3,'现今');
		insert into relation values(1,'亲戚'),(2,'朋友'),(3,'同事');
		insert into person values(1,'妹妹',2,1),(2,'弟弟',1,1),(3,'张同事',1,3),(4,'李朋友',2,2);
		

#======================MySQL_day06===================================
#面试题
1. 创建表
	    create table trade(id int primary key auto_increment,time date,money double,type varchar(5),pid int);
    	create table person(id int primary key auto_increment,name varchar(10),gender varchar(5),rel varchar(5));
- 插入数据
		insert into person values(null,'刘德华','男','亲戚'),(null,'刘若英','女','亲戚'),(null,'马云','男','同事'),(null,'特朗普','男','朋友'),(null,'貂蝉','女','同事');
		insert into trade values(null,'2018-02-20',-20,'微信',1),
		(null,'2018-02-21',500,'现金',2),
		(null,'2018-02-21',-50,'现金',2),
		(null,'2018-02-23',50000,'支付宝',3),
		(null,'2018-02-23',-100,'支付宝',3),
		(null,'2018-02-20',1000,'微信',4),
		(null,'2018-02-20',-20000,'现金',5);
3. 统计2月15号到现在的所有红包收益 2018年2月15号
	select sum(money) from trade where time>str_to_date('2018年2月15号','%Y年%m月%d号');
4. 查询2月15号到现在 金额大于100 所有女性亲戚的名字和红包金额
		select p.name,t.money
		from trade t join person p
		on t.pid=p.id
		where t.money not between -100 and 100
		and p.gender='女'
		and p.rel='亲戚'
		and t.time>str_to_date('2018年2月15号','%Y年%m月%d号');
5. 查询三个平台分别收入的红包金额
		select type,sum(money) from trade
		where money>0
		group by type;

##视图
- 什么是视图:数据库中存在多种对象,表和视图都是数据库中的对象,创建视图时名称不能和表名重名,视图实际上是代表了一段sql查询语句,可以理解成视图是一张虚拟的表,表中的数据会随着原表的改变而改变.
- 为什么使用视图:因为有些数据的查询需要书写大量的sql语句,每次书写比较麻烦,使用视图可以起到sql重用的作用,可以隐藏敏感信息 
- 创建视图的格式:
	- create view 视图名 as 子查询;
	- 例如: (切换回db3数据库)
		create view v_emp_10 as (select * from emp where deptno=10);
- 隐藏员工表的工资字段
		create view v_emp_nosal as (select empno,ename,job,mgr,deptno from emp);
1. 创建emp表部门是20并且工资小于3000的视图
		create view v_emp_20 as (select * from emp where deptno=20 and sal<3000);
2. 创建emp表每个部门工资的总和,平均工资,最大工资,最小工资的视图
		create view v_emp as (
		select deptno,sum(sal),avg(sal),max(sal),min(sal) from emp group by deptno);
		
###视图的分类
1. 简单视图:创建视图的子查询中不包含:去重,函数,分组,关联查询的视图称为简单视图. 可以进行增删改操作
2. 复杂视图: 和简单视图相反.

###在简单视图中进行增删改操作
1. 视图中插入数据
	insert into v_emp_10 (empno,ename,deptno,sal) values (10001,'张三',10,300);
	
####数据污染: 
	往视图中插入一条视图中不显示,但是原表会显示的数据称为数据污染
	insert into v_emp_10 (empno,ename,deptno,sal) values (10002,'李四',20,400);
- 如果需要避免数据污染的出现,创建视图时需要使用 with check option的关键字
	create view v_emp_20 as (select * from emp where deptno=20) with check option;
	insert into v_emp_20 (empno,ename,deptno,sal) values (10003,'王五',20,400);(成功)
	insert into v_emp_20 (empno,ename,deptno,sal) values (10004,'赵六',10,400);(失败)
- 测试在视图中修改和删除数据 修改和删除操作方式和table一样
1. 修改v_emp_10视图中任意一条数据的工资为500;
	update v_emp_10 set sal=500 where empno=10001;
	update v_emp_10 set sal=500 where empno=10002;
2. 删除v_emp_10中工资为500的员工
	delete from v_emp_10 where sal=500;
	delete from v_emp_10 where empno=10002;
	
- 修改和删除只能操作视图中存在的数据

###修改视图
- 格式:
	create or replace view 视图名 as 子查询
	create or replace view v_emp_10 as (select * from emp where deptno=10 and sal>2000);
	
###删除视图
		drop view v_emp_20;
		drop view if exists v_emp_20;(如果存在删除 不存在也不会报错)
		
###视图别名
- 如果创建视图的时候使用了别名,则对视图操作的时候只能使用别名
		create view v_emp_name as (select ename name from emp);
		update v_emp_name set name='abc' where name='李四';
		
###视图总结:
1. 视图是数据库中的对象,代表一段sql语句
2. 作用:重用sql,隐藏敏感信息
3. 分类:简单(不包含函数,去重,分组,关联查询)(可以进行增删改查操作)和复杂(和简单相反)(只能查)
3. 工作中一般使用视图时只进行查询操作 如果需要增删改则直接对原表进行操作

##约束
- 什么是约束:约束是给表字段添加的限制条件.
###非空 not null
- 添加非空约束的字段 值不能为null
		create table t_null(id int,age int not null);
###唯一 unique
- 添加唯一约束的字段 值不能重复
		create table t_unique(id int,age int unique);
		insert into t_unique values (1,20);(成功)
		insert into t_unique values (2,20);(失败)
###主键约束 primary key
- 添加了主键约束的字段,值不能为null也不能重复
- 创建表时添加主键约束
		create table t_pri (id int primary key);
- 创建表后添加主键约束
		create table t_pri2 (id int);
		alter table t_pri2 add primary key(id);
- 一个表只能有一个主键
- 删除主键约束
		alter table t_pri2 drop primary key;
###自增
1. 当字段赋值为null,字段会自动增长
2. 如果删除数据,自增数值不会减
3. 如果指定插入比较大的值,下次插入数据时会从最大值的基础上+1
4. 如果使用delete删除全表数据,自增值不变
5. 使用truncate 关键字 自增数值清零
###默认约束 default
- 给字段设置默认值,当字段不赋值的时候,默认值生效
		create table t_def(id int,age int default 10);
###检查约束  check
- mysql不支持,但语法通过不会报错
		create table t_check(id int,age int,check(age>10));
		
###外键约束 
- 什么是外键约束: 用来保证两张表之间数据一致性和完整性的约束
- 添加约束后:外键的值可以为null,可以重复,但不能是另外一张表不存在的数据
- 添加约束后,外键指向的表(dept)不能先删除,如果需要删除,要么删除外键约束,要么先删除存在外键的表(emp)
- 添加约束后,外键指向的数据不能先删除
- 外键的值通常指向另外一张表的主键
- 使用外键必须两张表使用相同的引擎(innodb),myisam不支持外键
- 工作中除非特殊情况,一般不使用外键约束,使用java代码通过逻辑对插入和删除的数据进行限制,因为加了外键约束后不方便测试
###添加外键约束的格式:
	create table emp(id int,age int,deptid int,constraint 约束名 foreign key(deptid) 
	references 关联表名(关联的字段名));

- 创建部门和员工的两张表,创建一个db6数据库并使用
		create table dept(id int primary key auto_increment,name varchar(10));
		
		create table emp(id int primary key auto_increment,name varchar(10),deptid int, constraint fk_dept foreign key(deptid) references dept(id));

		insert into dept values(null,'神仙'),(null,'妖怪');
		insert into emp values(null,'观音',3);(失败)
		
##索引
###导入数据
- 在终端中先登录mysql 在db6下面执行 source命令
	source 文件的绝对路径
- 学生机路径:
	source /home/soft01/桌面/item_backup.sql
- windows电脑路径:把文件放在d盘下
	source d:/item_backup.sql

- 导入完之后 测试执行: select count(*) from item2;

###什么是索引
	索引是用来提高查询速度的技术,类似一个目录
- 为什么使用索引: 如果不使用索引,数据会零散的保存在磁盘块中,磁盘块大小(4-8kb),查询数据时需要挨个遍历每一个磁盘块,直到找到数据为止,使用索引之后会在磁盘中将数据以树状结构进行保存,查询数据时从树状结构中进行查询,可以大大降低磁盘块的访问数量,从而提高查询速度
- 索引内部原理图(了解)
![](01.png)

###索引是越多越好吗?
- 索引会占用磁盘空间,所以创建时需谨慎,根据查询需求来决定创建什么索引.

###有索引就一定好吗?
- 索引需要建立在大量数据的表中,如果数据量不够大,有可能会降低查询效率

###索引的分类(了解)
1. 聚集索引(聚簇索引):数据保存在树状结构中,一张表只有一个聚集索引,数据库会自动为添加了主键的表创建聚集索引.
2. 非聚集索引: 树状结构中没有数据,保存的是磁盘块的地址

###如何创建索引(非聚集索引)
- 格式: create index 索引名 on 表名(字段名[(长度)]);------------------???
- 创建表时直接指定索引
	create table 表名(id int,age int,index index_age(age));
- 修改表结构时添加索引
	ALERT TABLE 表名 ADD INDEX[索引名] (字段名[(长度)]); 
	
###查看索引
	show index from 表名;
###删除索引
	drop index 索引名 on 表名;
	
###复合索引
	创建索引的时候添加多个字段,这种索引称为复合索引
- 什么时候使用:当频繁使用多个字段作为查询条件的时候使用复合索引
- 创建格式: create index index_title_price on item2(title,price);


###索引总结
1. 索引会占磁盘空间,不是越多越好
2. 数据量小的表不要创建索引
3. 主键会自动创建聚集索引
4. 对经常出现在 where/order by/distinct后面的字段创建索引可以提高效率,效果更好
5. 不要在修改太频繁的表中创建索引

##事务
###什么是事务
	数据库执行sql语句的最小工作单元,不可拆分,同时成功或同时失败
	
###事务的ACID特性 *****面试常考*****
- Atomicity:原子性,最小 不可再次拆分
- Consistency:一致性,同时成功,同时失败
- Isolation:隔离性, 多个事务之间互不影响
- Durability:持久性, 事务完成后数据持久保存到数据库

###mysql中事务的指令
1. 查看自动提交的状态
	show variables like '%autocommit%';
2. 设置自动提交的状态
	set autocommit=0/1;
3. 提交
	commit
4. 回滚	
	rollback
5. 保存回滚点
	savepoint s1
6. 回滚到某个点
	rollback to s1
	
#课程回顾
##day01
1. 数据库相关
create database db1 character set utf8;
show databases;
show create database db1;
drop database db1;
use db1;
2. 表相关
create table t1(id int,age int);
show tables;
show create table t1;
desc t1;
drop table t1;
rename table t1 to t2;
alter table t1 engine=myisam/innodb charset=gbk;
alter table t1 add age int first/after xxx;
alter table t1 drop age;
alter table t1 change age myage int;
alter table t1 modify age int first/after xxx;
3. 数据相关
insert into t1 (id,age) values(1,2),(3,4);
delete from t1 where id=1;
update t1 set age=20 where id=1;
select * from t1;
##day02
1. 注释 comment
2. '和`
3. 冗余 
4. sql分类 
	ddl数据定义语言 alter create drop truncate 不支持事务
	dml数据操作语言 insert update delete select 支持事务
	dql数据查询语言 select
	tcl事务控制语言 
	dcl数据控制语言 分配权限
3. 数据类型
	整数:int bigint(m) 显示长度 zerofill
	浮点数: double(m,d)  decimal(m,d)
	字符串: char 不可变 255 varchar 可变 65535 text longtext
	日期: date time datetime timestamp
	其他类型
##day03
1. > < >= <= = !=  <>
2. and or
3. in 
4. between x and y
5. like  _ %
6. distinct
7. not
8. sum avg max min  count
9. limit count,size
10. order by 字段名 desc/asc,字段名
11. now()   curdate()  curtime()
	date(now())  time(now()) 
	extract(year from now()) month day hour minute second
	date_format(now(),'格式') 
	Y y m c d H h i s
	str_to_date('时间字符串','格式')
12. ifnull(x,y)
13. 字符串
	concat(a,b)  char_length(str) instr(str,substr) locate(substr,str) 
	upper() lower()  trim()  left  right
	substring(str,index,length)
	replace(str,old,new)
	repeat(str,2);
	reverse(abc)
	insert(str,start,length,new)
14. 数学 
	floor() 
	round(num,m)
	truncate(num,m)
	rand()
##day04
1. 分组查询 group by   having 
2. 子查询 
3. 关联查询
	等值连接 select * from A,B where A.x=B.x and ....
	内连接 select * from A join B on A.x=B.x where ...
	外连接 select * from A left/right join B on A.x=B.x where ...
###day05
1. 表设计: 
1对1: 在从表中添加外键 记录主表的id
1对多: 在多的一端添加外键 记录主表id
多对多: 关系表 记录两个表的主键id
自关联:当前表中添加外键指向自己表的主键id
2. 连接方式 内连接和外连接
3. 权限管理案例  三张主表 用户表 角色表,权限表 2张关系表  用户-角色    角色-权限
###day06
1. 视图:数据库中的对象,一段sql,简单视图(不包含函数,去重,分组,关联查询,可以进行增删改操作)和复杂视图(简单相反)
	数据污染:插入一条视图中不可见但是原表中存在的数据  通过添加 with check option 解决
	格式: create view 名字 as 子查询
	修改格式: create or replace view 名字 as 子查询
	删除视图: drop view if exists 视图名;
2. 约束
	非空 not null
	唯一 unique
	主键 primary key 
	自增 auto_increment 
	默认 default 
	检查 check
	外键约束: 可以为null 可以重复但不能不存在, 被依赖的数据不能删除 被依赖表不能随便删除
3. 索引: 提高查询效率 目录 ,索引占磁盘空间,数据量小的表添加索引会降低查询效率, 主键会自动创建聚集索引, 自己创建的索引都是非聚集索引
	格式: create index 名字 on 表名(字段名(长度),字段名)
	多字段的索引称为复合索引
	查看索引: show index from 表名
	删除索引: drop index 索引名 on 表名
4. 事务
	ACID:
	原子性:最小 不能拆分
	一致性: 同时成功或失败
	隔离性: 多事务互不影响
	持久性:事务完成后 数据持久保存在数据库中
	查看自动提交: show variables like '%autocommit%'
	设置自动提交: set autocommit=0/1;
	提交: commit
	回滚: rollback	
	设置回滚点: savepoint s1;
	回滚到某个点: rollback to s1;


#==================================jdbc01======================================
##JDBC
Java Database Connectivity java数据库连接,实际上JDBC是接口,定义了一套java和数据库交互的API.数据库厂商根据各自数据库的特点来实现这些接口.
创建工程--下载jar包-登录maven.tedu.cn-搜索mysql-找到5.1.6-点击它-复制右侧代码.回到工程找到工程pom.xml并打开-在底端找到pom.xml-在</project>标签之前加入如下代码
		<dependencies>
			<dependency>
				<groupId>mysql</groupId>
				<artifactId>mysql-connector-java</artifactId>
				<version>5.1.6</version>
			</dependency>
		</dependencies>

##maven 
	是项目管理工具	,可以构建工程,通过使用坐标的形式导入jar包,坐标(上方复制粘贴的代码)

##execute
	此方法可以执行任意sql,返回boolean类型,true表示有结果集,例如查询语句,false为没有结果集.
	通常此方法用于执行DDL.

###executeUpdate
	此方法执行增删改操作,返回值代表生效行数

###executeQuery
	此方法执行查询操作,返回值为ResultSet,里面保存查询到的所有结果
###ResultSet对象
	此对象里面装着查询到的结果数据,注意:得到ResultSet就用while遍历
	next()方法,先判断是否有下一条数据,
	有:返回ture,内部游标会往下移动;无,返回false
###从ResultSet对象中获取数据
1. 通过字段的名称获取数据	
	- int getInt("字段名");
2. 通过字段的位置获取数据 从1开始
	- int getInt(字段下标);即第几列
	
	例如:	
		while(rs.next()) {
				int id = rs.getInt("id");
		//int id = rs.getInt(columnIndex);
				String name = rs.getString("name");
				System.out.println("id="+id+",name="+name);
		}

###数据库字段类型和java类型对比
		数据库							java
		int								getInt/getLong
		varchar						get	String
		double							getDouble
		datetime/timestamp			getDate

###关闭资源	
1. 关闭Connection,使用完之后的连接要及时关闭,避免浪费资源	.
2. 关闭Statement,因为它会占用内存空间,Statement对象有上限.
3. 关闭ResultSet,结果集,占内存空间,使用完毕就关闭它.
- 关闭顺序:ResultSet->Statement->Connection


#==================================jdbc02======================================
##获取连接
在工程中,编写一个访问数据库工具类,此后访问数据库的操作,都从工具类中获取连接
两种方式:
1. 直接把数据配置写在工具类中
		写死了,无法动态访问
2. 把数据库配置写在一个properties属性文件里,
	工具类读取属性文件,逐行获取数据库参数----建议第二种
		可以动态访问

##Properties属性配置对象
-什么是properties: 程序员可以把工程中出现的某些数据以配置文件的形式保存起来, 而此对象就是处理*.properties文件的对象,在Properties文件中是以键值对的形式保存的数据
-例如:
在maven/src/main/resources中新建文件my.properties
在maven/src/main/java-cn.tedu中新建类
		
		public class PropertiesDemo {
			public static void main(String[] args) {
			//创建属性对象
				Properties prop = new Properties();
				//通过反射得到文件输入流
				InputStream ips = PropertiesDemo.
						class.getClassLoader().getResourceAsStream("my.properties");
				//把流交给属性对象
				try {
					prop.load(ips);
					//获取数据,数据类型为String	
					String name = prop.getProperty("name");
					String age = prop.getProperty("age");
					String loc = prop.getProperty("loc");
					System.out.println(name+","+age+","+loc);

				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}

##练习:把driver/url/username/password保存到配置文件中
-为什么要保存到配置文件中:因为以后工作中有更换数据库的需求,此时如果写在java类中修改比较麻烦,所以需要把这些数据保存到配置文件中.jdbc.properties文件的内容
		driver=com.mysql.jdbc.Driver
		url=jdbc:mysql://localhost:3306/db6
		username=root
		password=
		
###DBUtils 第二次封装
		//只执行一次
		static {
			//1创建属性对象
			Properties prop = new Properties();
			//2通过反射得到文件输入流
			InputStream ips = DBUtils.
					class.getClassLoader().getResourceAsStream("jdbc.properties");
			//3属性对象加载流
			try {
				prop.load(ips);
				//4获取属性对象的数据,数据类型为String	
				driver = prop.getProperty("driver");
				url = prop.getProperty("url");
				username = prop.getProperty("username");
				password = prop.getProperty("password");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		// 获取连接
		public static Connection getConn() throws Exception {
			//注册驱动
			Class.forName(driver);
			Connection conn = DriverManager.getConnection(
					url,username,password);
			return conn;
		}

##数据库连接池 DBCP
-什么是数据库连接池 DBCP DataBaseConnection Pool
	一套管理数据库连接的API
-为什么用数据库连接池:
	如果没有数据库连接池,每次和数据库的交互都要建立和关闭连接,频繁的开关连接非常消耗资源,
	使用数据库连接池,可以设置一个初始最大连接数量,如果有连接需求会向连接池要,
	连接池中有空闲连接则用空闲的,如果没有此时会检测是否是最大数量,如果是则等待,如果不是则创建新的连接,
	每个连接使用完之后会归还到连接池中.等待其他的操作.
	
-如何使用数据库连接池
1. 下载jar包 去maven私服中搜索 dbcp 找到1.4版本
BasicDataSource
			BasicDataSource dataSource = new BasicDataSource();
			//设置数据库连接信息.
			dataSource.setDriverClassName("com.mysql.jdbc.Driver");
			dataSource.setUrl("jdbc:mysql://localhost:3306/db6");
			dataSource.setUsername("root");
			dataSource.setPassword("");			
			//设置管理策略参数
			//初始化连接数量
			dataSource.setInitialSize(3);
			//最大连接数量
			dataSource.setMaxActive(5);
			//获取连接对象
			Connection conn = dataSource.getConnection();
			Statement stat = conn.createStatement();
			String sql = "insert into t_jdbc values (101,'貂蝉')";
			stat.executeUpdate(sql);


##PrepareStatement 
是Statement的子接口
好处:
	1.代码可读性高.避免拼接字符串时出现的错误
	2.有预编译效果可避免sql注入.预编译时已经把sql语句的逻辑定死,不能通过替换?的形式修改的sql逻辑.
	3.执行效率要比statment高(效果不是太明显)(因为使用statemet每次执行sql都需要把sql编译成执行计划,而PrepareStatement 只需要创建时转换一次,之后只需修改里面的值即可所以效率会高)
- 如何使用
		@Test
		public void preparedStatement() {
			String name = "赵云";
			int id = 3;
			Connection conn = null;
			PreparedStatement stat = null;
			ResultSet rs = null;
			try {
				conn = DBUtils.getConn();
				//准备sql 需要拼接进来的变量用?代替,占位符
				String sql = "update t_jdbc set name=? where id=?";
				//执行sql语句的PS对象
				stat = conn.prepareStatement(sql);
				//替换sql中的"?"
				stat.setString(1,name);
				stat.setInt(2, id);
				stat.executeUpdate();
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				DBUtils.close(conn, stat, rs);
			}
		}

创建用户表 id  username password
//有则先删除
		drop table if exists user;
		create table if not exists user(id int,username varchar(10),password varchar(10));
		insert into user values(1,'libai','admin'),(2,'liubei','123456');

sql主入:select count(*) from user where username='libai' and password='' or '1'='1';
		select count(*) from user where username='libai' and password='admin';

回顾:
1.数据库连接池
2.Properties
3.PreparedStatement

#==================================jdbc03======================================
创建学生表,create table student(id)

##生成set get方法的快捷键
1. alt + shift + s
2. r
3. alt+a     a松手 alt继续按   按o 最后回车
##toString方法
 alt + shift s   松手  s   最后回车

##数据库操作和对象的关系
因为数据库中查询的数据比较零散,需要通过对象的形式把数据封装起来,这种封装数据的对象通常称为JavaBean

###JavaBean (面试题)
俗称简单的java对象
具备以下三个特点:
1.私有属性
2.无参构造方法
3.提供属性的set和get方法
-以后项目开发,基本上有什么表,在代码中就会创建相应的对象,表中有什么字段对象中就有什么属性.
- 数据库中有什么表就需要在Java代码中创建什么DAO(Data Access Object 数据访问对象)
###注意工作中 撤销(control+z) 和 恢复(control+shift+z)的使用

##Statment和PreparedStatement应用场景
通常DDL使用Statment
通常DML和DQL使用PreparedStatement
总结:sql中出现变量用PreparedStatement

##批量操作
因为类似sql执行,每一次都需要和数据库服务器进行数据交互,多次数据交互会浪费资源,并且耗时,可以使用批量操作的方式把多次交互合并成一次,从而提高执行效率.
-statement:
			String sql1 = "insert into t_item (id,title) values(100,'aaa')";
			String sql2 = "insert into t_item (id,title) values(101,'bbb')";
			String sql3 = "insert into t_item (id,title) values(102,'ccc')";
			//添加批量操作的sql
			stat.addBatch(sql1);
			stat.addBatch(sql2);
			stat.addBatch(sql3);
			//执行批量操作
			stat.executeBatch();
-PreparedStatement:
			String sql = "insert into t_item (id,title) values(?,?)";
			stat = connection.prepareStatement(sql);
			stat.setInt(1, 1001);
			stat.setString(2, "啦啦");
			stat.addBatch();
			
			stat.setInt(1, 1002);
			stat.setString(2, "呵呵");
			stat.addBatch();
			
			stat.setInt(1, 1003);
			stat.setString(2, "嘿嘿");
			stat.addBatch();
			stat.executeBatch();
###事务
	原子性
	一致性
	隔离性
	持久性
1. 关闭自动提交
	connection.setAutoCommit(false);
2. 提交事务
	connection.commit();
3. 回滚
	connection.rollback();
-转账练习sql:
drop table user;

create table user
(id int,name varchar(10),money int);

insert into user values(1,'超人',200),(2,'蝙蝠侠',10000);
实现过程:
1. 关闭自动提交
2. 修改超人的钱+3000
3. 修改蝙蝠侠的钱-3000
4. 查询蝙蝠侠的钱是否大于0 如果小于0 则抛出 运行时异常 大于等于0 提交
5. 在catch异常的地方把SqlException改成Exception,
并且在catch里面回滚 

###获取自增主键的值
-为什么获取:因为某些插入的数据 插入完成之后,需要用到数据的主键值作为下一条数据外键

准备sql
create table t_d(id int primary key auto_increment,name varchar(10));

			String sql = "insert into t_d values (null,'神仙')";
			//执行sql 并且标记此次执行需要获取生成的key值
			stat.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS);
			//得到生成的key值
			rs = stat.getGeneratedKeys();
			while(rs.next()){
				int id = rs.getInt(1);
				System.out.println("主键值:"+id);
			}

###获取元数据

-数据库元数据: 数据库厂商类型(mysql oracle) ,数据库连接信息 都成为数据库的元数据
	
-表元数据:表有哪些字段 哪些类型等

获取方式:
			connection = DBUtils.getConn();
			stat = connection.createStatement();
			//得到数据库元数据
			DatabaseMetaData dbmd = connection.getMetaData();
			System.out.println("驱动版本"+dbmd.getDriverVersion());
			System.out.println("用户名"+dbmd.getUserName());
			System.out.println("连接地址"+dbmd.getURL());
			System.out.println("数据库厂商的名称: "+
			dbmd.getDatabaseProductName());
			
			String sql = "select * from user";
			rs = stat.executeQuery(sql);
			//从结果集中获取表的元数据
			ResultSetMetaData resultSetMetaData = 
					rs.getMetaData();
			//获取表字段的数量
			int columCount = 
					resultSetMetaData.getColumnCount();
			//获取每个字段的名称
			for (int i = 0; i < columCount; i++) {
				String name = resultSetMetaData.getColumnName(i+1);
				System.out.println("字段名:"+name);
			}

###补充:乱码问题

在JDBC 连接数据库的url后面添加如下参数
jdbc:mysql://localhost:3306/db3?useUnicode=true&characterEncoding=UTF-8

课程回顾:
1. jdbc代码和面向对象
2. 批量sql执行
3. 分页查询
4. 事务  conn.setAutoCommit(false/true)
conn.commit()   conn.rollback();
5. 获取自增主键 
6. 获取元数据
7. 乱码


#==================================Servletjsp01======================================
程祖红
chengzh@tedu.cn
servlet/jsp + mvc框架
框架+项目

##网络架构CS和BS
-BS: Browser Server 浏览器和服务器
特点:跨平台,功能升级比较方便,加载数据慢,用户体验稍差
-CS: Client Server 客户端和服务器
特点:功能升级,需要下载新版本客户端,用户交互界面炫酷,体验度高,需要开发多个平台的版本开发成本高
总结:两种架构各有优缺点,以后工作都有可能涉及到

##什么是服务器
服务器实际上就是一台高配置的电脑,通常配置内存8g以上cup8核以上,硬盘T级别(1T=1024G)
web服务器:电脑上安装了web服务软件,提供复杂的数据及文件共享功能
邮件服务器:电脑上安装了邮件服务软件,提供了收发邮件的功能
数据库服务器:电脑上安装了数据库软件(mysql oracle db2 sqlserver等),提供了数据的增删改查
ftp服务器:电脑上安装了ftp服务软件,提供了文件上传下载功能

##什么是Web服务器
电脑中的任何资源(数据或文件)被远程计算机访问,都必须有一个与之对应的网络通信程序,当有用户来访问时,此程序负责建立网络连接,读取相关资源并把资源发送给用户,此程序负责底层的网络通讯,处理http协议,使用此类型程序,程序员只需要把精力放在具体的业务逻辑上即可

# 1. 什么是Servlet? 
	sun公司制订的一种用来扩展web服务器功能的组件规范。
## (1)用来扩展web服务器功能
	web服务器只能处理静态资源的请求（即需要事先将html文件准备好，并存放到指定的文件夹下面），不能够处理动态资源的请求（即需要计算，生成动态页面），所以需要扩展其功能。
	servlet可以扩展web服务器功能，当web服务器收到请求之后，如果需要计算，可以调用servlet来处理。

## (2)组件规范
### 1)什么是组件?
	符合规范，实现部分功能，并且需要部署到相应的
	容器里面才能运行的软件模块。
	servlet就是一个组件，需要部署到servlet容器里面
	才能运行。
### 2)什么是容器?
	符合规范，提供组件运行环境的程序。
	servlet容器需要符合servlet规范，为servlet提供
	网络相关的服务。

##市面上常见的web服务器
-WebSphere: 是IBM公司产品,闭源,收费 
		应用场景:IBM的操作系统+DB2+WebSphere 
-Tomcat:apache的产品,开源,免费 应用在中小型网站中
		web学习阶段使用的服务器
-weblogic: BEA公司的产品,闭源,收费
弊端:只能处理静态资源,即写好的.html文件,不能处理动态的资源

-静态资源:任何用户 任何时间访问 内容都一样
-动态资源:不同的用户访问显示的内容可能会不一样,通过计算生成的网页 

servlet:处理业务相关的问题
servlet容器:处理网络相关的问题

# 2. 安装Tomcat
##学生电脑tomcat位置
home下有个tomcat8.5文件夹 

##linux下手动开启Tomcat
1. 找到home/tomcat8../bin 
2. 右键打开终端
3. 在终端中执行  chmod +x *.sh  回车  开启运行sh文件的权限
4. 在终端中 ./startup.sh  回车 显示tomcat started表示tomcat已经启动
5. 找到tomcat根目录下 webapps文件夹,在里面新建a文件夹然后把今天上午的a.html 复制到里面
6. 在浏览器中输入以下请求地址:
		http://localhost:8080/a/a.html
7. 在终端中 ./shutdown.sh
##总结:
	通过手动开启Tomcat使用tomcat共享资源文件,要比手动自己写webServer方便的多,但是tomcat本身只支持共享静态资源文件
	
# 3.如何写一个Servlet?
	step1.写一个java类，实现Servlet接口或者继承HttpServlet抽象类。
	注：一般选择继承。
	step2.编译。
	step3.打包。（变成一个组件）
		appname (应用名)
			WEB-INF
				classes (放 .class文件)
				lib (可选，放.jar文件)
				web.xml (部署描述文件)
	step4.部署。
		将step3创建的整个文件夹拷贝到容器里面。
		注：
			可以使用jar命令将step3创建的整个文件夹压缩成".war"结尾的文件，
			然后再拷贝这个文件就可以了。
	step5.启动servlet容器，访问servlet。
		http://ip:port/appname/url-pattern
		注:
			url-pattern在web.xml文件当中设置。

- 案例:创建Servlet第一个程序Hello Kitty

1.创建maven项目  把默认的jar 改成war
2.把package Explorer 改成 project Explorer
3.在工程根目录的第一个文件上右键 点击最长的那个(默认工程中没有web.xml部署描述文件)
4.在window preference->server->runtime 清空内容然后点击add添加 根据自己电脑上的tomcat版本选择好版本,然后next 点击browse找到电脑中的tomcat路径,jre默认即可 
5.指定web服务器:在工程上右键 properties 选择targetedRuntime 选择 第四步添加的tomcat 点击ok
6.创建HelloServlet 继承HTTPServlet
7.在window中showView other 找到server并显示
8.双击server窗口中tomcat 修改ServerLocation 选择第二个,修改Publishing 选择第一个
9.工程上右键 run on Server
10.访问测试:
	http://localhost:8080/工程名/hello

第二次的步骤:
1.创建maven工程 选择 war
2.在工程中的最长的文件上右键点击最长的生成web.xml
3.在工程上右键properties选择target 设置部署的tomcat服务器
4.创建HelloServlet 继承HttpServlet
5.重写 service方法 并写返回数据的代码
6.在web.xml中写servlet和url的映射关系
7.工程上右键 run as on server 

# 4. Servlet是如何运行的?
1. 浏览器中发出请求,会先由浏览器的通讯模块对请求打包,打包后把数据传递给tomcat服务器
2. tomcat由通讯模块接收请求包并且对请求包进行解析,把请求数据封装到Request对象中,并且创建Response对象用于给浏览器返回数据
3. tomcat通讯模块通过查找web.xml文件找和本次请求相对应的Servlet,通过反射技术创建对象并且调用对象的Service方法,并把Request和Response传递到方法中
4. 在service方法中书写各种业务代码,把需要返回的数据交给response对象由Response对象传递给通讯模块,在通讯模块中打包(响应数据包)
5. 把响应数据包发送给浏览器通讯模块
6. 浏览器通讯模块解析响应数据包并展示出返回的数据
		
# 5. 错误码:
## (1)404
	1)含义
	404是一个状态码，服务器依据请求路径找不到对应的资源。
	2)原因:
	  a.请求路径写错。
	  	http://ip:port/appname/url-pattern
	  b.忘记部署或者部署失败。
## (2)500
	1)含义
	  服务器运行时发生异常。
	2)原因
		a.代码不规范（没有按照servlet规范来写）
			比如: 
				没有继承HttpServlet。
				配置文件中,servlet-class写错。
		b.代码不严谨
			比如：
				对请求参数值没有做检查就做类型转换。
## (3)405
	1)含义
		服务器找不到处理方法。
	2)原因
		没有正确override HttpServlet的service方法。

# tcp/ip抓包工具(了解即可，不用掌握)

练习:写一个Servlet,输出当前的系统时间



#==================================Servletjsp02======================================
# 1. http协议(了解)
## (1)http协议是什么?
	是一种网络应用层协议，规定了浏览器与web服务器之间如何通信以及相应的数据包的格式。
	注:
		TCP/IP(传输层和网络层协议),可以确保数据可以可靠的传递。
		Http协议(应用层协议)将数据打包之后，需要依赖TCP/IP协议来传递数据包。
	1)通信过程:
		建立连接
		发送请求
		发送响应
		关闭连接
	2)优点
	  web服务器可以利用有限的连接数为尽可能多的请求服务。
![](http.png)

## (2)数据包的结构
1)请求数据包
	a.请求行 (请求方式 请求资源路径 协议和版本)
	b.若干消息头
		注:
			消息头是一个键值对（以": "隔开），浏览器与web服务器之间可以通过发送消息头来传递一些特定的信息，比如浏览器可以发送"user-agent"消息头告诉服务器，浏览器的类型和版本。
	c.实体内容
		注：
			get请求没有数据，只有发送post请求时，才会有数据（请求参数）	。
2)响应数据包
		a.状态行 （协议和版本 状态码 状态描述）
		注:
			200: 正确
			404: 依据请求路径找不到对应的资源
			500: 系统出错
		b.若干消息头
			注：
			服务器也可以将一些消息头发送给浏览器，比如，通过发送"content-type"消息头，告诉浏览器，服务器发送过来的数据类型以及编码。	
		c.实体内容
			程序处理的结果，浏览器需要解析出来，生成相应的页面。

## (3)两种请求方式
1)get请求
	a.哪一些情况下，浏览器会发送get请求?
		在地址栏输入某个地址。点击链接。表单默认的提交方式。
	b.特点
		会将请求参数显示在浏览器地址栏，不安全。
		会将请求参数添加到请求行（也就是请求资源路径的后面），只能提交少量的数据。2k
2)post请求
	a.哪一些情况下，浏览器会发送post请求?
		设置表单的method属性为"post"。
	b.特点
		浏览器地址栏不会显示请求参数，相对安全。
		请求参数会添加到实体内容里面，可以提交大量的数据。
	注：
		不管是哪种请求类型，都不会对数据加密。对于敏感数据，一定要加密处理。

#　2.读取请求参数值
## (1)方式一
	String request.getParameter(String paramName);
	paramName：请求参数名。写错，返回null,可能会发生空字符串异常.
## (2)方式二
	String[] request.getParameterValues(String paramName);
	有多个请求参数名相同时，用该方法。

# 3.Servlet输出中文时产生的乱码问题
## (1)为什么会有乱码?
	out输出时，默认会使用iso-8859-1来编码。
## (2)如何解决?
1. 设置消息头的时候,告知浏览器服务器返回的类型即及编码
2. 设置out在输出时,使用的哪种字符集 
- response.setContentType("text/html;charset=utf-8");

# 4.表单包含有中文参数值产生的乱码问题
## (1)为什么会有乱码?
	表单提交时，会对中文参数值进行编码,会使用打开该表单所在的页面时的字符集来编码。而服务器端默认会使用iso-8859-1来解码，编码解码不一致,所以产生了乱码。
## (2)如何解决?
1)post请求:
	在所有getParamenter方法前添加代码:request.setCharacterEncoding("utf-8");
2)get请求:
	修改server.xml.65行左右<Connector URIEncoding="utf-8">
	
# 练习
	练习１：完成计算bmi指数
	如果bmi < 19,提示用户“体重过轻”，
	如果bmi > 25,提示用户“体重过重”,
	其它，提示“体重正常”。

	练习２:建表
		create table t_user(
			id int primary key auto_increment,
			username varchar(50) unique,
			password varchar(20),
			email varchar(20),
			phone varchar(20)
		);
		create table t_emp(
			id int primary key auto_increment,
			username varchar(50) unique,
			password varchar(20),
			email varchar(20),
			phone varchar(20)
		);

	练习3:复习jdbc(重点是DAO)
		
	
#==================================Servletjsp03======================================	

# 1.重定向
## (1)什么是重定向?
服务器通知浏览器重新访问一个新的地址。
注：
    服务器可以发送一个302状态码及一个Location消息头(该消息头的值是一个地址，一般称之为重定向地址)给浏览器；浏览器收到之后，会立即向重定向地址发请求。
		
## (2)如何重定向?
response.sendRedirect(String url);
注:
    url:重定向地址。
    
## (3)特点
a.重定向地址是任意的。
b.重定向之后，浏览器地址栏的地址会发生变化。
c.重定向过程中设计的web组件并不会共享同一个request和response对象.
   因为重定向是两次请求,request和response只存在一次请求中.

## (4)一个细节（了解）
重定向之前，容器会先清空response对象上存放的所有数据。

# 练习
写一个Servlet,依据id,删除某个用户。
比如: http://ip:port/appname/del?id=1
提示:
    step1.在UserDAO类中增加一个删除方法:
        public void delete(int id)
    step2.测试该方法。
    step3.添加DelUserServlet:
         读取id
         调用delete方法删除用户
         重定向到list
		
#==================================Servletjsp04======================================			
# 1. jsp (java server page)
## (1)jsp是什么?
	sun公司制订的一种服务器端 动态页面技术规范。
	注：
	  a.虽然使用servlet也可以生成动态页面，但是过于繁琐(需要使用out.println语句输出)，并且维护麻烦(要修改页面，就必须修改java代码)。所以sun才制订了jsp规范。
	  b. jsp是一个以.jsp为后缀的文件,主要内容是html和少量的java代码。容器(比如tomcat)会将该文件转换成一个对应的Servlet类 然后执行。
	  c. jsp本质就是一个servlet!
## (2)如何写一个jsp文件?
1. 添加一个以.jsp为后缀的文件。
2. 在该文件里面，可以添加如下内容:
a. html(css,javascript):
		直接写即可。

b. java代码:
	第一种形式　java代码片断,(jsp小脚本)
		<%  java代码   %>
	第二种形式　jsp表达式
		<%= java表达式 %>
	第三种形式  jsp声明
		<!-- 声明成员属性和成员方法 -->
		<%! 
			int i =100; 
			int sum(int a1,int a2){
				return a1+a2;
			};
		%>

c. 隐含对象
	c1.什么是隐含对象?
		在jsp文件里面，直接可以使用的对象，比如
		out,request,response。
	c2.为什么可以直接使用这些隐含对象?
		jsp会被容器转换成一个对应的servlet,
		在转换过程中，容器会自动添加获得这些对象的代码。
	c3.有哪些隐含对象?->9个
		out,request,response,session,application
		exception: 只有在isErrorPage="true"时才能使用。
		pageContext: (a6.jsp,a7.jsp)
			1. pageContext是什么?
				容器会为每一个jsp实例都会创建一个唯一的一个符合PageContext接口要求的对象。
			2. 特点
				唯一性：一个jsp实例对应一个pageContext。
				持久性：只要jsp实例还在，则pageContext会一直存在。
			3. 作用
				作用1：绑订数据。注：绑订到pageContext上的数据，只有对应的jsp实例能访问到。
				作用2: 提供了获得其它所有隐含对象的方法。
			 
		page:  jsp实例本身。jsp对应的那个servlet实例。
		config: (a5.jsp)实际就是ServletConfig
	<!-- 
	配置jsp.和配置servlet类似,也可以写初始参数
	 <servlet>
	  	<servlet-name>a5</servlet-name>
			<jsp-file>/a5.jsp</jsp-file>
			<init-param>
				<param-name>company</param-name>
				<param-value>IBM</param-value>
			</init-param>
	  </servlet>
	  <servlet-mapping>
	  	<servlet-name>a5</servlet-name>
	  	<url-pattern>/abc.html</url-pattern>
	  </servlet-mapping>
	 -->
	 <!-- 隐藏参数config,获取初始参数 -->
		公司名称:<%=config.getInitParameter("company")%>	
d.指令
	d1.什么是指令?
		通知容器，在将jsp转换成servlet时，做一些额外的处理，比如导包。
	d2.语法
		<%@ 指令名 属性＝值 %>
	d3.page指令:
		import属性：指定要导的包名，比如
			<%@ page import="java.util.*,java.lang.*"%>
	注:	如果要导多个包，包与包之间用","隔开。
		contentType属性:设置response.setContentType方法的参数值。
		pageEncoding属性:告诉容器，在读取jsp文件的内容时，使用指定的字符集去解码。
		session属性:缺省值是true,如果设置为false,则该jsp中不能使用session隐含对象。(a2.jsp)
		errorPage属性:用来指定一个异常处理页面，当jsp运行出错，容器会调用异常处理页面。(a3.jsp)
			<%@ page contentType="text/html; charset=UTF-8"
			pageEncoding="UTF-8" session="true" errorPage="a4.jsp"%>
		
		isErrorPage属性:缺省值false,如果值为true,则可以使用exception隐含对象。
			<%@ page contentType="text/html; charset=UTF-8"
			pageEncoding="UTF-8" isErrorPage="true"%>
			判断当前页面是否为异常处理页面。(a4.jsp)
	d4.include指令
		file属性：指定要包含的文件名。比如
			<%@ include file="header.jsp" %>
	注:	容器在将jsp转换成servlet时，会将file属性指定的文件的内容插入到该指令所在的位置。
	d5.taglib指令
		用于到入jsp标签	
e.注释
		<!-- 注释内容 -->;HTML注释,若注释内容包含java代码,会被执行
		<%-- 注释内容 --%>;JSP特有的注释,若注释内容包含java代码,会被忽略

## (3)jsp是如何运行的?
### 1)阶段一 容器将.jsp文件转换成一个.java文件
		html ----> 在service方法里面，使用out.write输出。
		<%    %> ---> 在service方法里面,照搬。
		<%=  %> ---> 在service方法里面，使用out.print输出。
		<%!   %> ---> 为servlet增加新的属性和方法。
### 2)阶段二　容器再调用该servlet。
	  注:
		包括编译、实例化、调用service方法。

# 练习：
	写一个jsp,以表格的形式显示所有员工的信息。
	create table t_emp(
		id int primary key auto_increment,
		ename varchar(50),
		salary double,
		age int
	);
	insert into t_emp values(null,'Giving',2000,22);
	提示:
		step1. 建工程
		step2. 导包
			jdbc驱动　连接池
		step3. 添加jdbc.properties
		step4. DBUtils
		step5. 测试 DBUtils
		step6. Employee类
		step7. EmployeeDAO类
			List<Employee> findAll
		测试 EmployeeDAO类
		step8. listEmp.jsp

	
#==================================Servletjsp05======================================			
# 1.转发
## (1)什么是转发?
	一个web组件将未完成的处理交给另外一个web组件继续做。
	注:
	 a. web组件指的是jsp或者servlet。
	 b. 常见的场景是一个servlet获取处理结果之后，转交给一个jsp来展现。
![](forward.png)

##　(2)如何转发?
### 1)绑订数据到request对象上。
	request.setAttribute(String name,Object obj);
	注:
		name:绑订名，obj:绑订值。
		Object request.getAttribute(String name);//不存在返回null
### 2)获得转发器。
	RequestDispatcher rd = request.getRequestDispatcher(String uri);
	注:
		a. RequestDispatcher是一个接口，
			该方法会返回一个符合该接口要求的对象，我们一般称之为转发器。
		b. uri是转发的目的地，比如一个jsp的地址。
		c. 转发的本质是一个web组件通过转发器，通知容器去调用另外一个web组件。
### 3)转发
	 rd.forward(request,response)
注:在forward之后的其他语句还是会继续执行的,只要不报异常.
## (3)特点	
	a.转发之后，浏览器地址栏的地址不变。
	b.转发的目的地地址是有限制的，要求是一个应用中的某个web组件的地址。
	c.共享同一个request和response对象

# 2.比较转发与重定向
## (1)能否共享request对象?
	转发可以，而重定向不行。
	注:
		a.当请求到达容器时，容器会立即创建request和response,当响应发送完毕，容器会立即销毁这两个对象。也就是说，request和response的生存时间是一次请求与响应期间存在!
		b.转发是一次请求，重定向是两次请求。
## (2)浏览器地址栏的地址有无变化?
	转发无变化，而重定向有变化。
## (3)目的地有无限制
	转发有限制（同一个应用），而重定向没有任何限制。

# 登录
## 流程:
	用户填写用户名和密码并提交，服务器端检查是否有匹配条件的记录，如果有，则登录成功，跳转到用户列表页面；否则登录失败，跳转到登录页面并提示用户。
##　步骤:
	step1. UserDAO类
		public User find(String username);
	step2.　测试UserDAO。
	step3. login.jsp
	step4. LoginServlet
		   读取用户名和密码
		   调用UserDAO的find方法
			  登录成功：重定向list
			  登录失败：转发到login.jsp

# 2.路径问题
## (1)什么是路径问题?
	链接地址、表单提交、重定向、转发都需要填写一个路径（或者也可以称之为地址）。
		<a href="addUser.jsp">
		<form action="login">
		response.sendRedirect("list")
		request.getRequestDispatcher("listUser.jsp")
## (2)相对路径
	不以"/"开头的路径
## (3)绝对路径
	以"/"开头的路径
## (4)如何写绝对路径?
	链接、表单提交、重定向从应用名开始写，转发从应用名之后开始写。
	注:
		不要将应用名直接写在路径里面！
		而应该使用以下方法获得实际部署时的应用名:
		String request.getContextPath();
	

#==================================Servletjsp06======================================			
# 1.状态管理

## (1)什么是状态管理?
	将浏览器与web服务器之间 多次交互 当作一个整体来处理,并且将多次交互 所涉及的数据(即状态) 保存下来.

## (2)如何进行状态管理?
	a. 将状态保存在浏览器端,代表性的是Cookie技术
	b. 将..........服务器端,.........Session技术

## (3)Cookie
### 1)什么是Cookie?
	服务器临时存放在浏览器端的少量数据
	
### 2)工作原理
	当浏览器访问服务器时,服务器会将少量数据以set-cookie消息头的形式发送给浏览器,浏览器会将这些数据保存下来;当浏览器再次访问服务器时,会将这些数据以cookie消息头的形式发送给服务器.
	
### 3)添加Cookie----response添加
	3.1 先创建Cookie对象,并指定名字和值
		Cookie c = new Cookie(Steing name, String value);
	3.2 调用response的添加Cookie方法
		response.addCookie(c);
		
### 4)读取Cookie,以及名称和值-----request读取
	Cookie[] resquest.getCookies();//该方法可能返回null
	String Cookie.getName();
	String Cookie.getValue();
注: 	a. 一个Cookie对象封装了一个Cookie中所有数据

### 5)编码问题
原因：	Cookie只能保存合法的ASCII字符，对于中文，需要将中文转换成合法的ASCII字符。
解决：String URLEncoder.encode(String str， String charset);
		Cookie c = new Cookie(
			"city2", URLEncoder.encode("烟台", "utf-8"));
	  String URLDeoder.decode(String str， String charset);//解码
		String value = URLDecoder.decode(c.getValue(), "utf-8");
	  
### 6)Cookie生存时间问题
	默认情况浏览器将Cookie保存在内存中,浏览器不关闭,Cookie一直存在.
	但是可以设置Cookie过期时间 void Cookie.setMaxAge(int seconds);
	若 seconds>0:浏览器将Cookie保存在硬盘上.
	  second=0;删除Cookie;
	  second`<`0;浏览器将Cookie保存在内存中.

### 7)Cookie的路径问题
	a. 什么时Cookie的路径问题?
	浏览器访问服务器上的某个地址时,会比较该地址与Cookie的路径是否匹配,
	只有匹配的Cookie才会发送给浏览器
	b. Cookie的默认路径
	等于添加该Cookie的Web组件的路径
	比如: /Servlet_day06/biz01/addCookie.jsp,添加了一个cookie,
	则该cookie默认的路径就是"/Servlet_day06/biz01"
	c. 发送Cookie的条件
	要邀访问的地址必须时Cookie的路径或者其子路径时,浏览器才会发送Cookie
	d.	修改Cookie的路径
	cookie.setPath(String path);	
	
### 8)实现一个简单的Cookie工具(CookieUtil)-------扩展
	添加Cookie
	读取Cookie
	删除Cookie

Cookie的使用流程
创建Cookie c = new Cookie("","");
c.setMaxAge()
c.setPath()
response.addCookie(c);
查询时 :

### 9)Cookie的限制
	a. 可以被用户禁止
	b. 不安全,对于敏感数据,不建议保存在Cookie里,若保存,必须加密
	c. 只能保存少量数据 4k左右
	d. 数量也有限制 几百个
	e. 只能保存字符串


#==================================Servletjsp07======================================			
# 1. Session(会话)
## (1)什么是Session?
	服务端为了保存用户状态而创建的特殊的对象
	
##	(2)原理
	当浏览器访问服务器时,服务器创建session对象,该对象有一个唯一的id,称为SessionId,
	服务器会将SessionId以Cookie的方式发送给浏览器,当浏览器再次访问服务器时,会将SessionId
	发送给服务器,服务器依据SessionId找到对应的Session对象.
	
## (3)如何获得Session对象
1. 方式一
	HttpSession s = request.getSession(booleab flag);
	注:
		a. HttpSession是一个接口,request.getSession(booleab flag)方法
			会返回一个符合要求的Session对象.
		b. 	当flag为true时:--->一定能得到Session对象
			先查看请求中是否有SessionId,若没有,则创建Session对象,
			若有id,则根据Id查找对应的Session对象.找不到则创建新的Session对象,
			找到则返回该对象.
		c. 当falg为false时:-->不会创建Session对象
			先查看请求中是否有SessionId,没有id和有id找不到session对象都返回null,
			有id,则找对应的Session对象
2. 方式二
	HttpSession s = request.getSession();//默认true
	等价于request.getSession(true);
	
## (4)绑定数据相关的方法
	session.setAttribute(String name, Object obj);//转发时候也用过
	Object getAttribute(String name);//找不到返回null
	session.removeAttribute(String name);//移除绑定的数据
	
## (5)统计访问次数
		//设置服务器的类型和字符集
		response.setContentType("text/html;charset=utf-8");
		PrintWriter out = response.getWriter();
		//获取Session对象
		HttpSession session = request.getSession(true);
		//获取绑定的值
		Integer count = (Integer)session.getAttribute("count");
		if(count==null) {//第一次
			count = 1;
		}else {
			count++;
		}
		//绑定最新的次数
		session.setAttribute("count", count);
		out.println("你是第:"+count+"次访问");
		
## (6)Session超时
1. 什么是Session超时?
	服务器会将空闲时间过长的Session对象删除
		a. 	目的时节省内存空间
		b. 缺省的超时时间为30分钟
2. 修改超时时间
	Servers-tomcat-web.xml
		<session-config>
			<session-timeout>30</session-timeout>
		</session-config>
	或者:
	session.setMaxInactiveInterval(int seconds);
	两次请求的间隔不能超过指定时长,若超时,则session对象被删除.-->不常用

## (7)立即删除Session对象
	session.invalidate();

## (8)Session验证(案例)
1. 登录成共后,在Session对象上绑定一些数据,
	比如:session.setAttribute("user",user);
2. 当用户请求某个地址时,进行session验证,
	获取session对象,Object obi = session.getAttribute("user");
	判断是否登录过
	if(obj==null){//未登录过,重定向到登录界面
		response.sendRedirect("login.jsp");	
		return;
	}	
	在loginServlet中,登录成功后,在session对象上绑定一些数据
	为session验证做准备
		//获取session
		HttpSession session = request.getSession();
		//在session对象上绑定数据
		session.setAttribute("user", user);
		//重定向到用户列表
		response.sendRedirect("list");

# 2. 容器如何处理请求资源路径?
		比如在浏览器地址输入http://ip:port/Servlet_day07/abc.html
1. 容器默认请求的是一个Servlet,先查看部署文件web.xml,看是否有匹配的servlet配置.
	三种匹配方式:
		a. 精确匹配	<url-pattern>/abc.html</url-pattern>----->常用
		b. 通配符匹配	使用 * 来匹配任意个字符;
			比如:<url-pattern>/*</url-pattern>
			<url-pattern>/demo/*</url-pattern>
		c. 后缀匹配	使用 *.开头,后接任意后缀
			比如:<url-pattern>*.do</url-pattern>	匹配所有以 .do 结尾的请求			
2. 如果没有匹配的servlet,再去查找对应位置的文件.找到则返回,找不到则404

# 3. 如何让一个Servlet处理多种请求?
1. 该Servlet采用后缀匹配
		<servlet-mapping>
				<servlet-name>actionServlet</servlet-name>
				<url-pattern>*.do</url-pattern>
		</servlet-mapping>
2. 分析请求路径,依据分析结果进行不同的处理


#==================================Servletjsp08======================================			
# 1.Servlet的生命周期
## (1)什么是Servlet的生命周期？
	Servlet容器如何创建Servlet对象,如何对其进行初始化处理,
	如何调用其方法处理请求,以及如何销毁该对象的整个过程.
	
## (2)生命周期分为哪几个阶段?
### 1. 实例化
a. 什么是实例化?
	容器调用Servlet的构造器,创建Servlet对象
b. 什么时候实例化?
	1. 容器收到请求之后,通过构造器(构造方法)实例化-->默认情况
	2. 容器启动之后,立即实例化-->需要额外的配置,如下:
		<servlet>
			<servlet-name>someServlet</servlet-name>
		  	<servlet-class>web.SomeServlet</servlet-class>
		  		<!-- 配置启动加载:即容器启动之后,立即创建相应的实例 -->
		  		<!-- 值:是一个大于等于0的整数,值越小,优先级越高(优先被创建) -->
		  	<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
		  	<servlet-name>someServlet</servlet-name>
		  	<url-pattern>/some</url-pattern>
		</servlet-mapping>
	当一个Servlet初始化比较复杂,操作的时间比较长的时候,往往使用第2种
c. 会创建几个实例?
	容器只会创建一个实例!	
		
### 2. 初始化;调用init(方法)
a. 什么是初始化?
	容器调用Servlet的init(ServletConfig config)方法,进行初始化,
	初始化只执行一次.
b. GenericServlet抽象类已经提供了init方法的实现.
	将容器传递过来的ServletConfig对象保存下来,并且提供了一个方法
	getServletConfig()来获得该对象.例如:
		ServletConfig config = getServletConfig();
		System.out.println("config:"+config);
c. 如何实现自己的初始化处理逻辑?
	只需要override GenericServlet的init()无参方法.例如:
		@Override
		public void init() throws ServletException {
			System.out.println("SomeServlet的初始化处理逻辑");
		}	
d. 初始化参数
	1. 配置初始化参数
		在<servlet-class>web.CommentFilter</servlet-class>>下面写
		<init-param>
			<param-name>company</param-name>
			<param-value>IBM</param-value>
		</init-param>
	2. 读取初始化参数
		String company = config.getInitParameter("company");
		System.out.println("company:"+company);
	
### 3. 就绪(调用)
a. 什么是就绪?
	容器受到请求之后调用Servlet的service方法来处理请求
b. HttpServlet已经提供了service方法的实现
	注:该方法依据请求类型,调用对应的doXXX方法.比如:
	get请求,调用doGet方法.post请求,调用doPost方法.
	(这两个方法只是抛出了一个异常)
c. 我们写servlet,可以有两个选择,
	1.override HttpServlet的sevice方法;
	2.override HttpServlet的doGet方法和doPost方法;
	
### 4. 销毁
a. 什么是销毁?
	容器在删除Servlet对象之前,会调用destroy方法;只执行一次!
b. GenericServlst已经提供了destroy方法的实现.
c. 如何实现自己的销毁处理逻辑?
	override GenericServlet的destroy方法.
	
## (3)相关的接口与类(了解)
a. Servlet接口
		init(ServletConfig config);//初始化
		service();//就绪,调用
		destroy()	;//销毁
b. GenericServlet抽象类
		实现了Servlet接口中的部分方法(init和destroy);
c. HttpServlet抽象类
		继承了GenericServlet,实现了service方法

### 案例:重新计算bmi指数

# 2. Servlet上下文
## (1)什么是Servlet上下文?
容器启动之后,会为每一个web应用创建唯一的符合ServletContext接口要求的对象,
该对象就是Servlet上下文.
注:	唯一性:一个web应用对应唯一一个上下文.
	持久性:只要容器不关闭,或应用不卸载,上下文就会一直存在.

## (2)如何获得Servlet上下文?
1. 	GenericServlet提供的getServletContext()
2. ServletConfig提供的getServletContext()
3. HttpSession提供的getServletContext()
4. FilterConfig提供的getServletContext()

## (3)作用
1. 绑定数据
	setAttribute(String name,Object obj)
	setAttribute(String name);
	removeAttribute();
注:	
		request<session<servlet上下文,都提供了绑定数据的方法,如何选取?
		在满足使用条件的情况下,优先使用生命周期短的.
2. 读取全局的初始化参数
	a. 什么是全局的初始化参数?
		可以被同一个应用中全部组件共享的初始化参数
	b. 如何使用
		1. 配置:
			<!-- 配置全局的初始化参数 -->
			<context-param>
				<param-name>company</param-name>
				<param-value>IBM</param-value>
			</context-param>
		2. 读取
			ServletContext 对象.getInitParameter(String paramName);	
				
#==================================Servletjsp09======================================			
# 1. 过滤器
## (1)什么是过滤器?
	Servlet规范当中定义的一种特殊组件,用来拦截Servlet容器的调用过程.
注:容器受到请求以之后,先调用过滤器,在调用后续的其他组件(servlet)

## (2)如何写过滤器?简述过滤器的开发步骤
1. 编写一个jvalei,实现Filter接口
2. 重写destroy,init,doFilter方法中实现拦截处理逻辑
3. 把过滤器和Web应用一起打包部署.类似于servlet的配置
		<filter>
			<filter-name>commentFilter</filter-name>
			<filter-class>web.CommentFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>commentFilter</filter-name>
			<url-pattern>/comment</url-pattern>
		</filter-mapping>

## (3)过滤器的优先级
	多个过滤器都符合拦截要求时候,从上到下,按照配置先后顺序来执行,
	
## (4)初始化参数
		在<filter-class>web.CommentFilter</filter-class>下写
		<init-param>
			<param-name>company</param-name>
			<param-value>IBM</param-value>
		</init-param>
		
## (5)过滤器的优点(思考)

# 练习：
	写一个过滤器，检查评论的字符的个数，如果超过10个字符，则
	提示“评论的字数过多”。

# 2.监听器
## (1)什么是监听器?
	Servlet规范中定义的一种特殊的组件,用来监听Servlet容器产生的事件并进行相应的处理.
注:
	容器产生两大类事件:
	1. 生命周期相关的事件
		容器创建或者销毁request,session,ServletContext时产生的事件.
	2.绑定数据相关的事件
		调用request,session,ServletContext的setAttribute,removeAttribute方法
		时产生的事件.

## (2)如何编写监听器?
1. 写一个java类,依据监听的事件类型选择实现相应的监听器接口.
例如:监听Session对象的创建和销毁对应的事件----HttpSessionListener接口.
2. 重写sessionCreated和sessionDestroy方法,实现相应的监听处理逻辑
3. 在web.xml文件中配置该监听器
	<!-- 配置监听器 需要放在过滤器之前-->
	<!-- 容器启动后立即创建监听器实例 -->
	<listener>
		<listener-class>web.CountListener</listener-class>
	</listener>

练习:统计在线人数

#==================================Servletjsp10======================================			
# 1. Servlet线程安全问题
## (1)为什么Servlet有线程安全问题?
a. 容器收到一个请求,就会启动一个线程来进行相应的处理.
b. 默认情况下,容器只会创建一个Servlet实例.
c. 如果同时有多个请求访问同一个Servlet,就会出现多个线程访问这个Servlet实例,
	如果这些线程要修改Servlet实例的某个属性,就可能发生线程安全问题.
## (2)如何解决?
	使用synchronized对可能产生线程安全问题的代码加锁

# 2.servlet总结
## (1)servlet基础
	1)什么是servlet?
	2)如何写一个servlet?
	3)servlet是如何运行的?
	4)http协议(了解)
		a.什么是http协议
		b.特点
		c.数据包的结构
		d.消息头、状态码
## (2)servlet核心
	1)如何读取请求参数值?
	2)表单包含有中文参数值，如何处理?
	3)servlet输出中文，要注意什么?
	4)容器如何处理请求资源路径?
	5)如何让一个servlet处理多种请求?
	6)转发与重定向
		a.什么是重定向?
		b.如何重定向?
		c.重定向的特点?
		d.什么是转发?
		e.如何转发?
		f.转发的特点?
		g.转发与重定向的区别
	7)servlet生命周期
		a.什么是servlet生命周期?
		b.分成哪几个阶段?
		c.相关的接口与类(了解)
	8)路径问题
	9)线程安全问题
	10)servlet上下文
		a.什么是上下文(ServletContext接口)
		b.特点
		c.如何获得上下文?  FilterConfig  ServletConfig
		d.作用 
		e.request,session,上下文均可以绑订数据，有何区别?
## (3)状态管理
	1)什么是状态管理?
	2)Cookie
		a.什么是Cookie?
		b.工作原理
		c.如何添加一个cookie?
		d.三个问题(编码问题、生存时间问题、路径问题)
		e.如何读取cookie?
		f.cookie有什么限制?
	3)Session
		a.什么是session?
		b.工作原理
		c.如何获得session对象?
		d.绑订数据相关的几个方法
		e.session超时
		f.删除session
		g.比较session和cookie:
			session的优点: 
				安全、可以保存更丰富的数据类型、可以保存更多的数据。
				cookie不安全、只能保存少量的数据、只能保存字符串。
			session的缺点:
				因为所有数据都保存在服务器端，如果用户量大，会占用大量的内存。而cookie是将数据保存在浏览器端，不会占用服务器资源。
	
## (4)数据访问
	dao
	处理异常
## (5)过滤器与监听器
	a.什么过滤器?
	b.如何写一个过滤器?
	c.优先级
	d.初始化参数
	e.优点
	f.什么是监听器?
	g.如何写一个监听器?
## (6)案例
	用户管理
	登录
	session验证

#==================================Servletjsp11======================================
# 1. jsp标签和el表达式
## 1. jsp标签是什么
sun公司制订的一种用来替换jsp中java代码的技术，语法类似于html标签，容器遇到jsp标签之后，会找到标签对应的标签类然后执行。
注：
	a.因为直接在jsp文件中写java代码，不利于jsp文件的维护，比如，将包含有java代码的jsp交给美工去修改就很不方便。所以，sun才制订了jsp标签技术规范。
	b.使用jsp标签，jsp文件会变得更简洁，方便维护，同时，方便代码的复用。

## 2. el表达式是什么
是一套简单的运算规则，用于给jsp标签的属性赋值。也可以脱离jsp标签直接使用。
## 3. el表达式的作用(使用)
1. 访问bean的属性:
		什么是JavaBean:是一个public class,
					有无参构造,
					implement Serializable,
					有一些属性,
					对应的get/set方法.
### 方式一:${user.username} ---(e1.jsp)(e2.jsp)
a. 执行过程:	
		容器依次从pageContext->request->session->application中调用getAttribute方法	查找绑定名称为"user"的对象,找到后调用getUserName方法,输出计算结果.
b. 会将null转换成 空字符串"" 输出
c. 如果依据绑订名找不到对应的对象，不会报空指针异常，仍然输出""。
d.	可以使用pageScope、requestScope、sessionScope、applicationScope来指定查找范围,范围内找不到也不去其他地方查找.比如，从session对象中查找: ${sessionScope.user.username}.
注:若在某个范围中找到了,则不再往后继续查找	
### 方式二:${user['username']};--->(e1.jsp)(e2.jsp)
a. 执行过程:同方式一.
b. 允许[ ]里面写绑定名,相当于表达式中绑定一个变量;
		User user = new User(); 
		user.setUsername("闪电");
		<% request.setAttribute("str", "username"); %>
		username:${user[str]}
	允许[ ]里面使用从0开始的下标，用于访问数组中的某个元素。	
		User user = new User(); 
		user.setInterest(new String[]{"洗","剪","吹"});
		interest:${user.interest[0]}	
c. 若绑定名没写对,返回空字符串"";

注意:${employee.addr.city}
2. 做一些简单的运算
	注：运算结果可以用来给jsp标签的属性赋值，也可以直接输出。
	
a. 算术运算 (e1.jsp)
	+,-,*,/,%
	注:
		+号只能求和，不能够连接字符串。
b. 关系运算
	>,>=,<,<=,==,!=
c. 逻辑运算
	&&,||,!
d. empty运算
	判断集合内容是否为空，或者是否为一个空字符串。

3. 读取请求参数值 (e2.jsp)
	${param.username}
	等价于
		request.getParameter("username");
	${paramValues.interest}
	等价于
		request.getParameterValues("interest");

#==================================Servletjsp12======================================
# 1. jstl 
## (1)jstl是什么?
	(java standard tag lib 即java标准标签库)
	apache开发的一套通用的jsp标签，后来捐献给了sun,sun将其命名为jstl。
## (2)编程步骤
	step1.导包。
		jstl
	step2.使用taglib指令导入要使用的标签。
		uri属性：指定要导入的标签的命名空间。
		prefix属性:指定命名空间的别名。
		注：
		 命名空间:是为了区分同名的元素而在元素前添加的一个限定。
		 通常是一个域名。
	
## (3)核心标签
### 1)if标签 (e3.jsp)
	a.语法
	<c:if test="" var="" scope="">
		标签体
	</c:if>
	b.当test属性值为true时，容器执行标签体的内容。
	c.test属性值可以使用el表达式来赋值。
	d.var属性指定绑名，scope属性指定绑订的范围。
![](a1.png)

### 2)choose标签 (e4.jsp)
	a.语法
	<c:choose>
	  <c:when test="">
	  </c:when>
	  <c:otherwise>
      </c:otherwise>
	</c:choose>
	b.when可以出现1次或者多次，表示一个分支；otherwise可以出现0次或者1次，表示例外。
	c.当test属性值为true时，执行标签体的内容，可以使用el表达式来给该属性赋值。

### 3)forEach标签 (e5.jsp)
	遍历集合或者数组
	a.语法
	<c:forEach items="" var="" varStatus="">
	</c:forEach>
	b.items属性用来指定要遍历的集合或者数组，可以使用el表达式来赋值。
	c.var属性用来指定绑订名。
	注：
		绑订范围固定是pageContext。该标签每次从集合或者数组中取一个元素，然后将该元素绑订到pageContext上。 
	d.varStatus属性用来指定绑订名。
	注：
		绑订范围固定是pageContext。绑订值是一个特殊的对象，该对象提供了几个方法用来获得当前遍历的状态。
		getIndex(): 获得当前正在被遍历的元素的下标（从0开始）
		getCount(): 获得当前是第几次遍历（从1开始）。

# 3.自定义标签 (了解)  (hello.jsp)
## (1)编程步骤
	step1. 写一个java类，继承SimpleTagSupport类。
	注：
		复杂标签技术(old)
		简单标签技术(new),继承SimpleTagSupport类属于简单标签技术
	step2. override doTag方法，在该方法里面，编写相应的处理逻辑。
	step3. 在.tld文件里面描述标签。
## (2)标签的运行过程 (了解)
	step1.容器依据标签的命名空间，找到标签的描述文件。
		比如，以hello2.jsp为例，容器依据命名空间
	("http://tedu.cn/tag")找到标签的描述文件(mytag.tld)。
	step2.容器依据标签的名字找到对应的标签类。
		比如，标签名字为"hello"，对应的标签类是"tag.HelloTag"。
	step3.容器调用标签类的构造器，创建其实例。
	step4.容器将标签的属性值赋给标签对象对应的属性。
		比如，将"hello kitty"赋给HelloTag对象对应的info属性。
		（通过调用对应的set方法）。
	step5.容器调用标签对象的doTag方法。
	简单来说:
		1. 命名空间->描述文件
		2. 标签名->标签类
		3. 构造器->实例化
		4. 标签属性值->标签对象对应的属性
		5. doTag方法
# 练习
	将listUser3.jsp中的java代码使用jstl标签和el表达式替换掉。
	开发一个自定义标签，输出当前系统日期，比如
	<d:date pattern="yyyy-MM-dd"/>

#==============================Servletjsp13_MVC======================================
# MVC (Model View Controller 模型 视图 控制器)
## (1)MVC是什么?
是一种软件架构思想、其核心思想是，要将数据处理与数据展现分开，按照这种思想，我们一般将软件划分成三种不同类型的模块，分别是模型(用来处理业务逻辑，即数据处理),视图(数据展现，即用户交互的界面)及控制器(用来协调模型和视图)。
	注:
		用户通过视图将请求发送给控制器，由控制器选择合适的模型来处理；
		模型返回的处理结果也要先交给控制器，由控制器选择合适的视图来展现处理结果。
![](mvc.png)

## (2)如何使用MVC？
	在web开发当中，我们可以使用java类充当模型，使用Servlet充当控制器，使用jsp充当视图。
![](webmvc.png)

## (3)MVC的优点
	a.方便代码的维护：
		模型或者视图发生了改变，不会彼此影响。
		比如，模型负责计算bmi指数，可以使用不同的视图来
		展现处理结果，添加新的视图时，并不影响模型；
		反过来，如果有的新的模型来计算bmi指数，也并不会影响
		视图。
	b.方便测试:
		将业务逻辑写在java类里面，可以直接测试，如果将业务逻辑写
		在servlet里面，需要部署整个应用才能测试。
	c.方便分工协作:

## (4)MVC缺点
	使用MVC,会增加代码量，也会增加软件设计的难度，相应会增加软件开发的成本。所以，对于相对比较简单的应用，不需要使用MVC。
	
# 练习：
	将day12-lab中的所有jsp文件移到WEB-INF下，修改代码，保证程	序正常运行。

# 2.实现一个MVC框架
## (1)java反射基础
		//动态加载类
		Class cls = Class.forName("reflect.B");
		
		//动态创建对象
		Object obj = cls.newInstance();
		
		//获取类的方法
		Method[] methods = cls.getDeclaredMethods();
		
		//遍历方法数组
		for (Method mh : methods) {
			//获取方法名
			String methodName = mh.getName();
			//调用test开头的方法
			if(methodName.startsWith("test")) {
				//获取方法参数类型,无参返回长度为0的数组
				Class[] types = mh.getParameterTypes();
				//判断有无参数
				if(types.length>0) {//有参
					//创建参数数组
					Object[] params = new Object[types.length];
					//获取每个参数类型
					for(int i=0;i<types.length;i++) {
						//输出每一个参数的类型
						System.out.println("types["+i+"]"+types[i]);
						//匹配参数类型
						if(types[i] == String.class) {
							params[i] = "你好";
						}
						if(types[i] == int.class) {
							params[i] = 798;
						}
					}
					mh.invoke(obj, params);
				}else {//无参
					mh.invoke(obj);
				}
			}
		}
## (2)java注解
java注解默认保留在源代码中,编译时会被抹掉.可以使用@Retention元注解告诉java编译器,该注解在编译时不被抹掉.
		@Retention(RetentionPolicy.RUNTIME)
		public @interface Test {
			/*
			* 注解的属性
			*/
			public String value();
	
		}
		
		
#==============================Servletjsp14_MVC======================================
# 1.实现一个简单的MVC框架(smartmvc)
## (1)设计目标:
	因为MVC中的C,即Controller(控制器)主要负责两件事，一是依据请求路径调用合适的模型来处理请求，另外，依据模型返回的处理结果调用合适的视图来展现处理结果。所以，我们可以实现一个通用的控制器，该控制器可以通过读取配置文件或者java注解中的配置信息，来调用对应的模型或者视图。
## (2)架构
![](a2.png)

## (3)使用smartmvc
	step1.导包　　
		dom4j
	step2.将smartmvc的核心包拷贝过来
		base包
	step3.配置DispatcherServlet
	step4.添加smartmvc.xml配置文件。
	step5.添加处理器（比如LoginController）
		在该处理器里面，方法前添加@RequestMapping注解。
		方法的返回值是视图名。
	step6.添加jsp。
		注意jsp文件名应该符合  "/WEB-INF/" + 视图名 + ".jsp"。
	step7.在smartmvc.xml配置文件中，添加处理器的配置。


#==============================Spring_Mybatis_day01======================================
# Spring
spring -- 春天

##  Java Bean
类的定义,符合如下规则的Java对象称为Java Bean
1. 必须有包
2. 必须有无参数构造器
3. 必须实现 序列化接口
4. 有getXXX setXXX 方法声明的"Bean属性".
	- Bean属性 不是 对象属性
	- boolean类型的 get属性方法,可以声明为 isXXX
> Java Bean就是符合一定规范的Java对象!

## Spring 
Spring 是开源社区提供的软件框架

1. 提供了软件中必须使用的大部分功能
2. 只要按照Spring约定的规则使用, 就可以利用这些功能
3. 利用Spring可以大大简化软件的开发

Spring 两大核心功能: IOC 和 AOP

> 先学 IOC 在项目阶段学习 AOP 

## Spring IOC
Spring IOC 用于管理(创建,修改属性等)Java Bean对象.

1. Spring IOC 可以创建Java Bean对象
2. Spring IOC 可以修改Bean属性
3. Spring IOC 可以作为 Java Bean的工厂使用

> 由于Spring 中存储的是JavaBean 对象, 所以也称Spring是Java Bean容器.

## Spring管理JavaBean
原理:
![](1.png)

步骤:

1. 导入Spring组件

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>4.3.9.RELEASE</version>
		</dependency>
		
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
		</dependency>

	> JUnit 用于进行测试

2. 编写Java Bean 类 Car

		public class Car implements Serializable {
			
			private String name;
			private String type;
			
			public Car() {
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			public String getType() {
				return type;
			}
		
			public void setType(String type) {
				this.type = type;
				System.out.println("Call setType"); 
			}
		
			@Override
			public String toString() {
				return "Car [name=" + name + ", type=" + type + "]";
			}
			
		}

3. 更新Spring配置文件 applicationContext.xml

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans" 
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context" 
			xmlns:jdbc="http://www.springframework.org/schema/jdbc"  
			xmlns:jee="http://www.springframework.org/schema/jee" 
			xmlns:tx="http://www.springframework.org/schema/tx"
			xmlns:aop="http://www.springframework.org/schema/aop" 
			xmlns:mvc="http://www.springframework.org/schema/mvc"
			xmlns:util="http://www.springframework.org/schema/util"
			xmlns:jpa="http://www.springframework.org/schema/data/jpa"
			xsi:schemaLocation="
				http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd
				http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd
				http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd
				http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd
				http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd
				http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd
				http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd">
			<!-- 告诉Spring 帮助创建一个Car对象 -->
			<!-- bean 标签用于创建JavaBean对象 -->		
			<bean id="car" class="spring.day01.Car">
			</bean>
		</beans>

4. 测试:
		
		public class TestCase {
			
			
			@Test
			public void testCar(){
				//初始化 Spring 容器, Spring 会根据xml
				//文件自动创建 Java bean 对象
				ApplicationContext ctx=
					new ClassPathXmlApplicationContext(
					"applicationContext.xml");
				
				//从Spring容器中获取Spring创建的Bean对象
				// "car" 是 在xml中定义的 id 属性值
				Car car=(Car)ctx.getBean("car");
				System.out.println(car); 
				
				Car car1 = (Car) ctx.getBean("car1");
				System.out.println(car1);
				
				//重载的 getBean 方法可以避免类型转换
				Car c = ctx.getBean("car",Car.class);
			}
			
		}

## Spring 可以管理Bean 的属性

Bean属性注入: 修改"Bean属性" 不是对象的属性! 实际上是调用了setXXX方法, 修改了Bean属性.

	<bean id="car" class="spring.day01.Car">
		<!-- property 标签用于注入Bean属性 
			name 是bean属性名, 如果是type则调用
			setType方法! -->
		<property name="type" value="QQ"></property>
	</bean>

## 工厂方法
1. 简单理解就是利用方法创建对象
2. 将对象复杂的创建过程封装到方法中
3. 使用时候调用方法就重用了复杂的对象创建过程, 简洁的得到对象.

静态工厂方法:

	Connection getConnection() 
	Connection conn=DBUtils.getConnection();
	Calendar rightNow = Calendar.getInstance();

动态工厂方法:

	Statement st = conn.createStatement();

	Time time = cal.getTime();

## Spring 创建对象的3种方式
Spring 帮助创建JavaBean对象, Spring 支持3种对象创建方式

1. 利用构造器创建Java Bean
2. 利用静态"工厂方法"创建对象
3. 利用动态工厂方法创建对象

案例:

	<!-- 利用静态工厂方法创建Java Bean对象 -->
	<bean id="cal" class="java.util.Calendar"
		 factory-method="getInstance"></bean>
	
	<!-- 利用bean(对象)的工厂方法创建对象-->
	<!-- Spring会调用cal对象的getTime方法创建对象 -->
	<bean id="time" factory-bean="cal"
		factory-method="getTime"></bean>

测试:

	@Test
	public void testCal(){
		//初始化 Spring 容器
		ApplicationContext ctx=
			new ClassPathXmlApplicationContext(
			"applicationContext.xml");
		
		//获取Java Bean, 进行测试
		Calendar cal=ctx.getBean(
				"cal", Calendar.class);
		System.out.println(cal); 
	}
	
	@Test
	public void testTime(){
		//初始化Spring 容器
		ApplicationContext ctx=
			new ClassPathXmlApplicationContext(
			"applicationContext.xml");
		
		//检查是否成功创建了 time 对象
		Date time=ctx.getBean(
				"time", Date.class);
		System.out.println(time); 
	}

## Bean 的作用域
1. Spring 在默认情况下, 其中Bean都是单例的!
	- 单例:　在软件中一个永远唯一的对象，称为单例！
2. 设置 scope="prototype" 以后就是多例的对象了

案例:

	<!-- 设置 scope="prototype" 
	  scope 范围 prototype 原型 
	  设置 scope="prototype" 属性后, Spring会在
	  每次调用 getBean时候创建对象! Spring会为对象
	  创建多个实例! 也就是多例的!-->
	<bean id="time2" scope="prototype" 
		factory-bean="cal"
		factory-method="getTime"></bean>

## Bean 的生命周期管理
Spring 中的Bean对象, 由Spring控制对象的创建和销毁, 这个过程称为Spring中Bean对象的生命周期管理.

1. 单例对象 singleton(单例)
	- 创建: 在Spring容器初始化时候, 创建单例对象, 如果设置了init-method属性, 则在创建对象以后调用初始化方法.
	- 使用: 每次调用getBean时候, 返回的都是同一个对象
	- 销毁: 在Spring容器关闭时候,Spring会自动销毁单例对象, 如果指定了destroy-method属性, 则会在销毁之前执行 销毁 方法.

2. 多例对象 prototype(原型)
	- 创建: 在调用getBean方法时候, 创建对象, 如果设置了init-method属性, 则在创建对象以后调用初始化方法.
	- 使用: 每次调用getBean时候, 返回的都是新对象
	- 销毁: Spring 不管!!! 也不会调用 destroy-method !!!


#==============================Spring_Mybatis_day02======================================
# Spring
## Bean 生命周期与延迟实例化
问题:
单例对象默认情况下在容器启动时立即初始化, 如果这些对象内存耗用高, 则启动会很慢.

解决办法:
对于内存占用高, 使用少的对象, 可以设置延迟(懒惰,按需)实例化, 
在bean标签上使用懒惰属性设置即可.

设置了懒惰属性为true: 
1. 容器启动时候, bean不实例化
2. 在第一个次getBean时候实例化
3. 是单例bean对象.

> 多例对象没有延迟初始化问题.

## 什么是IOC/DI

IOC:
1. IoC全称是Inversion of Control，被译为控制反转；
2. IoC是指程序中对象的获取方式发生反转，由最初的new方式创建，转变为由第三方框架创建、注入（DI），它降低了对象之间的耦合度。
3. Spring容器是采用DI方式实现了IOC控制，IOC是Spring框架的基础和核心；

DI:
1. DI全称是Dependency Injection ，被译为依赖注入；
2. DI的基本原理就是将一起工作具有关系的对象，通过构造方法参数或方法参数传入建立关联，因此容器的工作就是创建bean时注入那些依赖关系。
3. DI主要有两种注入方式，即Setter注入和构造器注入

Setter注入(Bean属性注入)案例:
![](imgs/1.png)

实现步骤:
1. 创建接口 Tools 
		public interface Tools {
			String getName();
		}

2. 创建 Saw
		/**
		 * 电锯
		 */
		public class Saw 
			implements Tools, Serializable {
		
			private String name;
		
			public Saw() {
				name = "电锯";
			}
			
			public String getName() {
				return name;
			}
			
			public void setName(String name) {
				this.name = name;
			}
		
			@Override
			public String toString() {
				return "Saw [name=" + name + "]";
			}
		}

3. 斧子 Axe
		/**
		 * 斧子 
		 */
		public class Axe 
			implements Tools, Serializable{
			private  String name;
			public Axe() {
				name = "斧子";
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			@Override
			public String toString() {
				return "Axe [name=" + name + "]";
			}
		}

4. 创建类型 Man
		public class Man implements Serializable {
			private Tools tool;
			private String name;
			
			public Man() {
			}
			
			public void work(){
				System.out.println(name+"使用"+
						tool.getName()+"砍树!");
			}
		
			public Tools getTool() {
				return tool;
			}
		
			public void setTool(Tools tool) {
				this.tool = tool;
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			@Override
			public String toString() {
				return "Man [tool=" + tool + ", name=" + name + "]";
			}
		}

5. 编写配置文件 applicationContext.xml:
		<bean id="axe" class="spring.day02.Axe"></bean>
		
		<bean id="saw" class="spring.day02.Saw"></bean>
		
		<!-- ref="axe" 表示将id为axe的bean对象注入
		到 bean属性tool 中! 
		ref 属性用于注入bean对象
		value 属性用于注入基本值, 包括字符串-->
		<bean id="qiang" class="spring.day02.Man">
			<property name="tool" ref="saw"></property>
			<property name="name" value="光头强"></property>
		</bean>

6. 测试:
		@Test
		public void testQiang(){
			//测试: qiang 被注入的工具是什么?
			Man qiang = ctx.getBean("qiang", 
					Man.class);
			qiang.work();
		}

	> 优点: 更换光头强的工具只需要修改配置文件即可,不需要改变任何Java代码

构造器参数注入

Spring 支持构造器参数注入:

案例:
1. 给Man增加有参数构造器:
		public Man(String name) {
			this.name = name;
		}
	
2. 利用配置文件调用有参数构造器
		<!-- 构造器参数注入 -->
		<bean id="miniQiang" 
			class="spring.day02.Man">
			<!-- constructor-arg 标签用于实现构造器参数
			注入, index 用与指定构造器参数序号 -->
			<constructor-arg index="0" value="小强"/>
			<property name="tool" ref="saw"/>
		</bean>
		
3. 测试:
		@Test
		public void testMiniQiang(){
			//测试: 构造器参数注入
			Man qiang = ctx.getBean("miniQiang", 
					Man.class);
			qiang.work();
		}

## 自动注入
Spring 为了简化注入,提供了自动注入功能:

案例:
![](imgs/2.png)

当指定 autowire=byName时候, Spring会按照set方法的名字找到一致的id名一致的Bean, 并实现自动装配.

实现步骤:
1. 定义id为tool的bean
		<bean id="tool" class="spring.day02.Saw"/>

2. 在自动装配的bean上使用  autowire="byName" 
		<!-- 当指定了  autowire="byName" 属性时候,
		Spring会根据 setTool 名字查找 id为tool的
		bean , 然后自动的注入(装配) 执行setTool方法-->
		<bean id="man" class="spring.day02.Man"
			autowire="byName">
			<constructor-arg index="0" value="男人"/>
		</bean>

3. 测试:
		@Test
		public void testMan(){
			//测试: 按照名字自动参数注入
			Man man = ctx.getBean("man", 
					Man.class);
			man.work();
		}
	
## Spring支持各种类型的参数注入
- 注入基本值
- 注入Bean对象
- 注入集合

原理:
![](imgs/3.png)

实现步骤:
1. 编写DemoBean
		/**
		 * 演示多种类型参数的注入 
		 */
		public class DemoBean implements Serializable {
			private int times;
			private String name;
			private double price;
			private Date date;
			private List<String> list;
			private String phone="110";
			
			public int getTimes() {
				return times;
			}
			public void setTimes(int times) {
				this.times = times;
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			public double getPrice() {
				return price;
			}
			public void setPrice(double price) {
				this.price = price;
			}
			public Date getDate() {
				return date;
			}
			public void setDate(Date date) {
				this.date = date;
			}
			public List<String> getList() {
				return list;
			}
			public void setList(List<String> list) {
				this.list = list;
			}
			public String getPhone() {
				return phone;
			}
			public void setPhone(String phone) {
				this.phone = phone;
			}
			@Override
			public String toString() {
				return "DemoBean [times=" + times + ", name=" + name + ", price=" + price + ", date=" + date + ", list=" + list
						+ ", phone=" + phone + "]";
			}
		}

2. 在配置文件中注入属性:
		<!-- 多种类型的参数注入 -->
		<bean id="demo" class="spring.day02.DemoBean">
			<!-- 注入基本值 -->
			<property name="times" value="56"/>
			<property name="name" value="Hello"/>
			<property name="price" value="5.8"/> 
			<!-- 注入一个Bean对象 -->
			<property name="date" ref="dt"/>
			<!-- 注入集合 -->
			<property name="list">
				<list>
					<value>Tom</value>
					<value>Jerry</value>
				</list>
			</property>
			<!-- 注入空值 -->
			<property name="phone">
				<null/>
			</property>
		</bean>
		<bean id="dt" class="java.util.Date"/>

3. 测试:
		@Test
		public void testDemo(){
			//测试: 多种类型属性注入
			DemoBean bean = ctx.getBean(
				"demo", DemoBean.class);
			System.out.println(bean);
		}

## Spring表达式
- Spring 表达式用于读取Bean或者集合的属性
- 读取属性的目的是用于注入到bean属性中
- Spring表达式的语法与 EL 表达式基本一致
- 在实际工作中, 经常用于读取properties中的属性值, 然后注入到bean中

原理:
![](imgs/4.png)

案例:

1. 编写jdbc.properties
		driver=com.mysql.jdbc.Driver
		url=jdbc:mysql://localhost:3306/jsd1802db
		username=root
		password=root
		initSize=3
		maxSize=3

2. 将properties读取到Spring中
		<!-- Spring 提供了标签, 读取Properties文件 
		jdbc.properties文件的位置是 resources 文件夹-->
		<util:properties id="jdbc" 
			location="classpath:jdbc.properties"/>
	
3. 利用表达式读取 properties 
		<!-- 利用jdbc.properties 配置数据库连接池 -->
		<bean id="ds"
			class="org.apache.commons.dbcp.BasicDataSource"
			destroy-method="close"> 
			<property name="driverClassName"
				 value="#{jdbc.driver}"/>
			<property name="url"
				value="#{jdbc.url}"></property>
			<property name="username"
				value="#{jdbc.username}"></property>
			<property name="password"
				value="#{jdbc.password}"></property>
			<property name="initialSize" 
				value="#{jdbc.initSize}"></property>	
		</bean>	

4. 测试:
		@Test
		public void testDataSource()
			throws Exception {
			//测试:利用Spring表达式注入jdbc参数
			DataSource ds=ctx.getBean(
					"ds", DataSource.class);
			Connection conn=ds.getConnection();
			System.out.println(conn);
			conn.close();
		}

## Spring 注解
Spring 提供了注解方式声明bean
1. 注解可以由Java编译器进行语法检查, 这样就可以尽可能减少配置错误.
2. 注解很多功能都是按照默认执行的, 使用更加简洁
3. 一般在项目中, 自己写的源代码中使用注解声明组件

注解的原理:
![](imgs/5.png)
 
测试:
1. 编写声明组件扫描
		<!-- 设置注解组件扫描 
			component: 组件, scan: 扫描	-->
		<context:component-scan 
			base-package="spring.day02"/>
			
2. 编写测试组件
		/*
		 * Spring 会主动扫描 spring.day02包,将标注了
		 * @Component的类Foo自动实例化为Java bean, 并且
		 * 绑定id为 "foo"
		 */
		@Component
		public class Foo implements Serializable{
			private String name;
			private int age;
			
			public Foo() {
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			public int getAge() {
				return age;
			}
		
			public void setAge(int age) {
				this.age = age;
			}
		
			@Override
			public String toString() {
				return "Foo [name=" + name + ", age=" + age + "]";
			}
		}

3. 测试
		@Test
		public void testFoo(){
			//测试: 利用注解 @Component 实例化的bean 
			Foo foo = ctx.getBean("foo",Foo.class);
			System.out.println(foo); 
		}

@Component 与 @Service 功能一样:

1. 编写测试类:

		@Service
		public class Goo implements Serializable {
			String name;
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			@Override
			public String toString() {
				return "Goo [name=" + name + "]";
			}
		}

2. 测试:

		@Test
		public void testGoo(){
			//测试: 利用注解 @Service 实例化的bean 
			Goo goo = ctx.getBean("goo",Goo.class);
			System.out.println(goo); 
		}	

自定义bean组件ID

	@Component("k1")//自定义bean组件的id
	public class Koo implements Serializable{
		
		private String name;
	
		public String getName() {
			return name;
		}
	
		public void setName(String name) {
			this.name = name;
		}
	
		@Override
		public String toString() {
			return "Koo [name=" + name + "]";
		}
	}

> 自行测试

Bean声明周期管理注解

1. 导入 注解包:
		<dependency>
			<groupId>javax.annotation</groupId>
			<artifactId>javax.annotation-api</artifactId>
			<version>1.3.2</version>
		</dependency>

2. 编程测试案例
		@Component
		public class Wolf implements Serializable{
			public Wolf() {
				System.out.println("创建大灰狼");
			}
			@PostConstruct
			public void init(){
				System.out.println("我要吃羊");
			}
			@PreDestroy
			public void destroy(){
				System.out.println("我还会回来的!"); 
			}
		}

3. 测试
		@Test
		public void testWolf(){
			// 测试: 生命周期管理注解
			Wolf wolf=ctx.getBean("wolf",
					Wolf.class);
			System.out.println(wolf); 
		}
	
## 属性注入

利用属性注入注解可以注入属性

1. @Resource可以注入Bean组件
2. @Value 可以注入基本值

原理:
![](imgs/6.png)

步骤:
1. 编写 Pen 和 Book
		@Component
		public class Pen implements Serializable{
			public String toString() {
				return "钢笔";
			}
		}

		@Component
		public class Book implements Serializable{
			public String toString() {
				return "书本";
			}
		}

2. 编写Student
		@Component
		public class Student {
			@Resource//对象属性注入
			private Pen pen;
			private Book book;
			
			@Value("#{jdbc.driver}")
			private String driver;
			
			@Resource//Bean属性注入
			public void setBook(Book book) {
				this.book = book;
			}
		
			@Override
			public String toString() {
				return "Student [pen=" + pen + ", book=" + book + ", driver=" + driver + "]";
			}
		}

3. 测试:
		@Test
		public void testStudent(){
			Student st = ctx.getBean("student", 
					Student.class);
			System.out.println(st);
		}

## 作业
1. 重新编写全部课堂案例


#==============================Spring_Mybatis_day03======================================
# Spring MVC

Web - MVC:

![](imgs/mvc.png)

- M-Model 模型
	-模型（Model）的职责是负责业务逻辑。包含两层：业务数据和业务处理逻辑。比如实体类、DAO、Service都属于模型层。
- V-View 视图
	-视图（View）的职责是负责显示界面和用户交互（收集用户信息）。属于视图的组件是不包含业务逻辑和控制逻辑的JSP。 
- C-Controller 控制器
	-控制器是模型层M和视图层V之间的桥梁，用于控制流程比如：在Servlet项目中的单一控制器ActionServlet。


Spring MVC 是在Spring之上实现的 WEB MVC 编程编程框架, Spring MVC封装了大部分WEB编程中必须的功能, 只需要按照Spring MVC 定义的使用规则编程, 就可以快速的开发Web应用程序.

## Spring MVC 5大组件（面试题）

1. DispatcherServlet 单一前端控制器 
2. HandlerMapping 请求处理映射器 
3. Controller 控制器组件, 需要用户编写，处理业务功能
4. ModelAndView(视图和模型对象),是控制器方法返回值, 用于封装视图和在视图上显示的数据
5. ViewResolver 视图处理器, 用于处理视图和视图上的数据.

请求流程是:

![](imgs/spring.jpg)

1. 用户请求被前端控制器DispatcherServlet接收
2. 前端控制器将用户请求委托给 HandlerMapping 进行处理, HandlerMapping根据用户请求的URL找到对应的控制器. 并且执行控制器方法.
3. 控制器方法被执行, 执行后将结果封装到 ModelAndView 对象返回
4. 视图处理器 根据 ModelAndView 找到视图并且处理视图.

> 使用Spring MVC的好处是, Spring MVC 封装的常用的WEB编程功能, 使用了Spring MVC以后, 只需要写很少的代码就实现WEB编程. 

## 使用Spring MVC

1. 导入spring-mvc包
2. 在 web.xml 中配置"前端控制器"
3. 为前端控制器提供 spring 配置文件
4. 在Spring配置文件中 配置 Spring MVC 的组件

具体步骤是:

1. 创建 Maven Web项目(略).
2. 导入Spring MVC包:

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>4.3.9.RELEASE</version>
		</dependency>

3. 更新web.xml, 配置前端控制器

		<servlet>
			<description></description>
			<display-name>DispatcherServlet</display-name>
			<servlet-name>DispatcherServlet</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<init-param>
				<description></description>
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath:spring-mvc.xml</param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping>
			<servlet-name>DispatcherServlet</servlet-name>
			<url-pattern>*.do</url-pattern>
		</servlet-mapping>
	
	> 注意: 需要设置load-on-startup, 使前端控制器在Web容器启动时候实例化.

4. 添加spring-mvc.xml

		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans" 
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context" 
			xmlns:jdbc="http://www.springframework.org/schema/jdbc"  
			xmlns:jee="http://www.springframework.org/schema/jee" 
			xmlns:tx="http://www.springframework.org/schema/tx"
			xmlns:aop="http://www.springframework.org/schema/aop" 
			xmlns:mvc="http://www.springframework.org/schema/mvc"
			xmlns:util="http://www.springframework.org/schema/util"
			xmlns:jpa="http://www.springframework.org/schema/data/jpa"
			xsi:schemaLocation="
				http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd
				http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd
				http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd
				http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd
				http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd
				http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd
				http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd">
		
			<!-- annotation:注解, driven: 驱动的 -->
			<mvc:annotation-driven/>

			<!-- 视图处理器 -->
			<bean id="jspViewResolver" 
				class="org.springframework.web.servlet.view.InternalResourceViewResolver">
				<property name="prefix" 
					value="/WEB-INF/jsp/"/>
				<property name="suffix" 
					value=".jsp"/>
			</bean>

		</beans>


	> annotation-driven	标签配置了 HandlerMapping 对象

	> bean id="jspViewResolver"  配置了视图处理器

4. 部署并且启动Web容器, 测试基本环境, 出现如下信息就表示成功了!
		FrameworkServlet 'DispatcherServlet': initialization completed ...

## Hello World

Spring MVC Hello World 原理:

![](imgs/hello.png)

实现步骤:
1. 编写控制器:
		@Controller
		public class DemoController {
			/*
			 * 控制器方法, 在请求 "/demo.do" 时候
			 * 执行 hello() 方法, 执行成功后返回
			 * 视图 "hello" 作为显示界面
			 * "hello" 经过视图处理器添加前后缀以后映射到 
			 * /WEB-INF/jsp/hello.jsp 文件
			 */
			@RequestMapping("/demo.do")
			public ModelAndView hello(){
				System.out.println("hello()");
				//返回视图 "hello" 给用户
				return new ModelAndView("hello");
			}
		}

2. 编写/WEB-INF/jsp/hello.jsp 视图
		<%@ page contentType="text/html; charset=utf-8"
		    pageEncoding="utf-8"%>
		<html>
		<head>
		<title>Insert title here</title>
		</head>
		<body style="font-size:30px;">
			<h1>Hello World!</h1>
		</body>
		</html>

3. 测试:
		http://localhost:8088/spring-mvc-d1/demo.do

> 提示: 这个案例说明, Spring MVC 可以简化WEB 应用程序的开发.

## @RequestMapping

@RequestMapping 注解用于映射URL路径与控制器的关系. 

1. 在类上使用 @RequestMapping 可以映射第一层访问路径
2. 在方法上使用 @RequestMapping 可以映射具体的访问路径
	- 方法上的 映射路径不能重复.

原理:

![](imgs/3.png)

案例:
1. 编写控制器类
		@Controller
		@RequestMapping("/test")
		//标注在类上的RequestMapping 用于映射第一层路径
		public class TestController {
		
			@RequestMapping("/demo.do")
			public ModelAndView demo(){
				System.out.println("demo()");
				return new ModelAndView("hello"); 
			}
		}

2. 部署测试
		http://localhost:8088/spring-mvc-d1/test/demo.do

## ModelAndView

什么是ModelAndView:

Spring MVC 认为web控制器处理结果后,需要将数据(Model)发送到视图(View)显示, ModelAndView 就是一个封装显示数据和视图的Java Bean对象

ModelAndView: 构造器

	new ModelAndView(view, model)
	new ModelAndView(view)

利用 ModelAndView 向视图传递数据:

![](imgs/4.png)

步骤:
1. 编写控制器方法 TestController
		/**
		 * 利用 ModelAndView 向视图传递数据
		 */
		@RequestMapping("/model.do")
		public ModelAndView model(){
			//model 代表需要在JSP界面上显示的数据
			Map<String, Object> model=
					new HashMap<String, Object>();
			model.put("msg", "Hello");
			model.put("str", "World!");
			return new ModelAndView("msg", model);
		}

2. 编写 msg.jsp 显示ModelAndView中的数据
		<%@ page contentType="text/html; charset=utf-8"
		    pageEncoding="utf-8"%>
		<html>
		<head>
		<title></title>
		</head>
		<body style="font-size:30px;">
			<h1>显示从控制器传递的数据</h1>
			<p>${msg} ${str}</p>
		</body>
		</html>

3. 测试:
		http://localhost:8088/spring-mvc-d1/test/model-demo.do

Spring MVC 提供了简化 ModelAndView 方法: 控制器返回字符串

![](imgs/5.png)

案例:

1. 编写控制器方法:
		/**
		 * 返回 简化的 视图名, 就可以找到相应的JSP视图
		 */
		@RequestMapping("/view-demo.do")
		public String viewDemo(){
			System.out.println("view-demo");
			//返回 "hello" 由Spring MVC封装为 
			//ModelAndView对象, 并转给视图解析器
			return "hello";
		}

2. 测试:
		http://localhost:8088/spring-mvc-d1/test/view-demo.do

简化的 ModelMap 封装数据:

![](imgs/6.png)

案例:

1. 编写控制器方法
		/**
		 * 利用ModelMap向视图传递数据
		 */
		@RequestMapping("/model-demo.do")
		public String modelDemo(ModelMap model){
			model.put("msg", "Hello");
			model.put("str", "World!");
			return "msg";
		}

2. 测试:
		http://localhost:8088/spring-mvc-d1/test/model-demo.do

## Spring MVC 控制器接收表单参数

Spring MVC 封装了控制器接收表单参数的算法, 只需要按照Spring MVC的规则编写控制器就可以接收到参数.

利用控制器参数接收表单参数: 将表单参数name属性值与控制器参数名设为一样, 就可以接收参数

![](imgs/7.png)

案例:

1. 编写表单:
		<h1>从网页向控制器提交数据</h1>
		<form action="test/form-demo.do" 
			method="post">
			<div>
				<label>用户名</label>
				<input name="user" type="text">
			</div>
			<div>
				<label>密码</label>
				<input name="pwd" type="password">
			</div>
			<div>
				<input type="submit" value="提交">
			</div>
		</form>

2. 编写控制器方法
		/**
		 * 测试: 从表单接收参数
		 * Spring MVC 会自动的将表单中 name属性为user
		 * 的数据注入到 user 变量中, pwd 也是雷同的处理
		 */
		@RequestMapping("/form-demo.do")
		public String formDemo(
				String user, String pwd){
			System.out.println(user);
			System.out.println(pwd);
			return "hello";
		}

3. 测试: 
	1. 先显示表单, 
	2. 在表单中添加数据并且提交到服务器, 
	3. 服务器控制器上显示接收到的数据

特殊情形可以利用 @RequestParam 接收表单参数:

1. 编写表单
		<h1> @RequestParam 接收表单参数</h1>
		<form action="test/form-demo2.do" 
			method="post">
			<div>
				<label>用户名</label>
				<input name="8user" type="text">
			</div>
			<div>
				<label>密码</label>
				<input name="pwd" type="password">
			</div>
			<div>
				<input type="submit" value="提交">
			</div>
		</form>

	> 这里name="8user" 是非常特殊情形

2. 控制器方法
		/**
		 * 接收表单中的特殊情况 name=8user
		 * required: 必须的
		 * @RequestParam 默认情况下要求属性是必须的
		 * 如果需要设置为可选的, 则设置 required=false
		 * 
		 * 如下代码中: 如果客户端不提供8user用户名控制器会
		 *  报400错误, 但是如果不提供密码, 则控制器能够
		 *  继续处理, pwd的值是null
		 */
		@RequestMapping("/form-demo2.do")
		public String formDemo2(
				@RequestParam("8user") String user, 
				@RequestParam(name="pwd",
				required=false) String pwd){
			System.out.println(user);
			System.out.println(pwd);
			return "hello";
		}

3. 测试

Spring MVC 为了简化控制器编码, 提供了将表单打包到Java Bean的参数传递方式:

![](imgs/8.png)

步骤:

1. 编写表单
		<h1>打包到Java Bean的参数传递</h1>
		<form action="test/login.do" 
			method="post">
			<div>
				<label>用户名</label>
				<input name="user" type="text">
			</div>
			<div>
				<label>密码</label>
				<input name="pwd" type="password">
			</div>
			<div>
				<input type="submit" value="提交">
			</div>
		</form>

2. 编写JavaBean
		public class UserBean implements Serializable {
			private String user;
			private String pwd;
			
			public String getUser() {
				return user;
			}
			public void setUser(String user) {
				this.user = user;
			}
			public String getPwd() {
				return pwd;
			}
			public void setPwd(String pwd) {
				this.pwd = pwd;
			}
			@Override
			public String toString() {
				return "UserBean [user=" + user + ", pwd=" + pwd + "]";
			}
		}
	
3. 编写控制器
		/**
		 * 利用Java Bean封装表单参数
		 */
		@RequestMapping("/login.do")
		public String login(UserBean bean){
			System.out.println(bean);
			return "hello";
		}

4. 测试...

## 中文编码过滤器

Spring MVC提供了文字编码过滤器, 可以很简单的处理中文编码问题:

在web.xml中配置:
	<filter>
		<display-name>CharacterEncodingFilter</display-name>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<description></description>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>*.do</url-pattern>
	</filter-mapping>

## 作业

1. 搭建 Spring MVC项目
2. 重写编写全部课堂案例

#==============================Spring_Mybatis_day04======================================
# Spring MVC

Web 应用程序框架, 封装Web应用中常用功能, 只需要按照Spring MVC的约定编写代码, 就可以快速实现Web 应用.

Servlet/JSP MVC:

![](imgs/1.png)

Spring MVC:

![](imgs/2.png)

## Spring MVC 项目

1. 搭建 Spring MVC 项目(略)
2. 导入 jdbc dbcp jstl 包 
3. 复制dao层到项目中
	- dao/UserDAO.java
	- entity/User.java
	- util/DBUtil.java
	- jdbc.properties
4. UserDAO.java 添加注解 @Repository
	- 目的: UserDAO 对象由Spring 容器管理
5. 添加applicationContext.xml 用于扫描dao包中注解
	
		<context:component-scan base-package="dao"/>	

6. 导入 JUnit
7. 创建测试案例, 测试UserDAO 对象

8. 复制视图JSP到webapp
	- css/*
	- img/*
	- /WEB-INF/*.jsp
9. 删除 header.jsp 中的自定义标签
10. 开发控制器UserController

		@Controller
		public class UserController {
			
			@Resource
			private UserDAO userDAO;
			
			@RequestMapping("/list.do")
			public String listUser(ModelMap model){
				List<User> list=userDAO.findAll();
				//向listUser.jsp页面传输users集合
				model.put("users", list);
				//转发到 listUser.jsp
				return "listUser";
			}
		}
	
	> 利用@Resource注解, 注入了userDAO, 解决了控制依赖DAO的问题, @Resource注解必须在Spring容器才能使用

	![](imgs/3.png)

11. 添加Spring容器的初始化监听器 web.xml:
		<!-- ContextLoaderListener 是由Spring MVC提供
		用于在Web环境中初始化 Spring 容器, 是Spring MVC
		推荐的Spring 容器初始化方式. 一般利用这个监听器
		初始化软件的业务层和数据层. 需要利用context-param
		来设定配置文件位置! -->  
		  <listener>
		    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
		  </listener>
		  <context-param>
		  	 <param-name>contextConfigLocation</param-name>
		  	 <param-value>classpath:applicationContext.xml</param-value>
		  </context-param>

12. 更新了 spring-mvc.xml

		<!-- 视图解析器 -->
		<bean id="jspViewResolver" 
			class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="prefix" 
				value="/WEB-INF/"/><!-- 删除 jsp/ -->
			<property name="suffix" 
				value=".jsp"/>
		</bean>
		
		<context:component-scan 
			base-package="controller"/>

	> 更新内容:视图的位置和控制器组件扫描的位置.

12. 测试:

		http://localhost:8088/spring-mvc-d2/list.do

## 添加用户功能

重用了项目的jsp界面, 所以实现添加功能非常简单:

![](imgs/add.png)

1. 在控制器UserController中添加显示添加界面的控制器方法

		/**
		 * UserController 添加控制器方法, 处理toAdd.do
		 * 请求, 显示 添加用户的addUser.jsp页面
		 */
		@RequestMapping("/toAdd.do")
		public String toAdd(){
			return "addUser";
		}

2. 在控制器UserController中添加保存用户信息的控制器方法
		
		/**
		 * 处理添加用户请求 add.do
		 * 获取表单中的信息, 
		 * 保存到数据库,
		 * 重定向到 list.do
		 */
		@RequestMapping("/add.do")
		public String add(
				String username, 
				String pwd,
				String phone, 
				String email){
			
			User user = new User();
			user.setUsername(username);
			user.setPwd(pwd);
			user.setPhone(phone);
			user.setEmail(email);
			userDAO.save(user);
			//返回redirect前缀的返回值时候,Spring MVC
			//会发起重定向响应, 重定向到 list.do
			return "redirect:list.do";
		}

3. 测试..

		http://localhost:8088/spring-mvc-d2/toAdd.do

## 为用户界面添加表单检验功能

软件开发中用户表单中的数据填写的随意性, 所以一定要在保存之前进行数据合法性检验:

1. 客户端JS表单数据检验, 其好处是用户体验好, 但是安全性差可以被绕过.
2. 服务器端一定要对数据进行重复检验, 这样就可以避免客户端脚本被绕过, 进而更加安全了.

实现服务器端数据检验:

1. 在控制器方法参数注入 ModelMap 用于在出现错误情况下向JSP界面发送错误信息.
2. 在出现数据异常情况下, 转发到输入界面, 让用户继续输入:

		@RequestMapping("/add.do")
		public String add(
				String username, 
				String pwd,
				String phone, 
				String email,
				ModelMap model){
			
			//检验添加用户的表单功能
			if(username==null ||
					username.trim().isEmpty()){
				model.put("usernameErr",
						"必须填写用户名");
				return "addUser";
			}
		...

3. 更新 addUser.jsp 在出现错误时候显示错误消息:

		<td valign="middle" align="right">
			用户名:
		</td>
		<td valign="middle" align="left">
			<input type="text" 
			class="inputgri" 
			name="username"/>
			<span>${usernameErr}</span>
		</td>

## 表单数据保持问题

上述添加用户时候, 一旦用户输入信息有异常, 在重新转发到addUser.jsp 表单后, 表单中填写的数据项目会消失, 用户体验很差. 

为了解决上述问题 Spring MVC 提供了 @ModelAttirbute 用来将控制器方法中的数据保存到传递到JSP界面的ModelMap中. 这样在JSP中利用EL表达式就可以再表单中重新显示表单数据.

原理:

![](imgs/4.png)

实现步骤:

1. 重构控制器方法, 添加@ModelAttribute注解
		/**
		 * 处理添加用户请求 add.do
		 * 获取表单中的信息, 
		 * 保存到数据库,
		 * 重定向到 list.do
		 */
		@RequestMapping("/add.do")
		public String add(
				@ModelAttribute(name="username") 
				String username, 
				String pwd,
				@ModelAttribute(name="phone") 
				String phone, 
				@ModelAttribute(name="email")
				String email,
				ModelMap model){
		...

	> 其中 name="username" 是指定保存到ModelMap中的key

2. 更新addUser.jsp, 使用value="${username}"等回显表单数据

		<tr>
			<td valign="middle" align="right">
				用户名:
			</td>
			<td valign="middle" align="left">
				<input type="text" 
				class="inputgri" 
				name="username" 
				value="${username}"/>
				<span>${usernameErr}</span>
			</td>
		</tr>

3. 测试: 在表单出现错误的情况下, 会回显输入的数据.

## 实现登录功能
登录功能和添加功能非常类似, 也是两次请求

1. 第一次显示登录表单界面
2. 第二次接收表单数据验证登录是否成功

实现步骤:
1. 添加控制器方法显示登录界面
		/**
		 * 显示登录界面
		 */
		@RequestMapping("/toLogin.do")
		public String toLogin(){
			return "login";
		}

2. 添加控制器方法处理器登录表单请求
		/**
		 * 处理登录请求的控制器方法
		 */
		@RequestMapping("/login.do")
		public String login(
				@ModelAttribute(name="username")
				String username, 
				String pwd, 
				ModelMap model){
			if(username==null||
					username.trim().isEmpty()){
				model.put("login_failed", 
						"用户名不能为空");
				return "login";
			}
			if(pwd==null || pwd.trim().isEmpty()){
				model.put("login_failed", 
						"密码不能为空");
				return "login";
			}
			User user = userDAO.find(username);
			if(user==null){
				model.put("login_failed", 
						"用户名或密码错误");
				return "login";
			}
			if(user.getPwd().equals(pwd)){
				System.out.println("Success");
				return "redirect:list.do";
			}
			model.put("login_failed", 
					"用户名或密码错误");
			return "login";
		}

3. 更新登录界面与控制器配合处理登录错误情况 login.jsp
		<td valign="middle" align="left">
			<input type="text" 
			class="inputgri" 
			name="username" 
			value="${username}"/>
			<span style="color:red;font-size:24px;">
				${login_failed}
			</span>
		</td>

4. 测试

## Spring MVC 访问Session

在软件开发中经常需要访问Session, Spring MVC也提供了优化, 只需要在控制器方法中添加 HttpSession参数即可, Spring MVC在工作时候会自动的将session对象

> 不仅可以在控制器方法中注入 HttpSession 对象, 还可以注入 HttpServletRequest对象和HttpServletResponse对象.

将登录信息保存到 Session 中

1. 重构 登录验证方法, 添加HttpSession参数, 并且更新登录逻辑, 在登录成功时候, 将用户信息保存到 session中:
		/**
		 * 处理登录请求的控制器方法
		 */
		@RequestMapping("/login.do")
		public String login(
				@ModelAttribute(name="username")
				String username, 
				String pwd, 
				ModelMap model, 
				HttpSession session,
				HttpServletRequest request,
				HttpServletResponse response){
			if(username==null||
					username.trim().isEmpty()){
				model.put("login_failed", 
						"用户名不能为空");
				return "login";
			}
			if(pwd==null || pwd.trim().isEmpty()){
				model.put("login_failed", 
						"密码不能为空");
				return "login";
			}
			User user = userDAO.find(username);
			if(user==null){
				model.put("login_failed", 
						"用户名或密码错误");
				return "login";
			}
			if(user.getPwd().equals(pwd)){
				System.out.println("Success");
				session.setAttribute(
						"loginUser", user);
				return "redirect:list.do";
			}
			model.put("login_failed", 
					"用户名或密码错误");
			return "login";
		}

2. 重构 header.jsp 显示session中的用户信息, 用于验证session信息.
		<span>${loginUser.username}</span>

3. 测试

## 删除功能

添加控制器方法即可:
	@RequestMapping("/del.do")
	public String del(Integer id){
		userDAO.delete(id);		
		return "redirect:list.do";
	}


#==============================Spring_Mybatis_day05======================================
# Spring

## Spring MVC 重定向参数传递

Spring MVC 控制器向视图界面传递参数时候, 不仅能够向转发视图传递参数, 而且还能向重定向视图传递数据:

![](imgs/1.png)

## Spring MVC 数据类型转换

Spring MVC 在接收浏览器参数时候, 可以进行自动数据类型转换, 为了更加方便的接收参数, 建议使用包装类接收参数:

![](imgs/2.png)

## Spring MVC 拦截器(Interceptor)

Spring MVC 提供了与 Servlet Filter 类似的拦截器功能, 其执行原理为:

![](imgs/3.png)

演示案例:

1. 编写拦截器类:
		@Component 
		public class DemoInterceptor implements HandlerInterceptor {
			
			/**
			 * 在控制器之前执行
			 */
			public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
					throws Exception {
				System.out.println("preHandle");
				return true;
			}
			/**
			 * 在控制器之后执行
			 */
			public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
					ModelAndView modelAndView) throws Exception {
				System.out.println("postHandle");
			}
			/**
			 * 视图处理以后执行
			 */
			public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
					throws Exception {
				System.out.println("afterCompletion");
			}
		
		}
		
2. 在spring-mvc.xml 配置拦截器
		<!-- interceptor 拦截器
		在 spring-mvc中配置拦截器的拦截位置 -->
		<mvc:interceptors>
			<mvc:interceptor>
				<!-- mapping 用于设定拦截器的拦截位置 -->
				<mvc:mapping path="/test.do"/>
				<!-- 引用@Component注解声明的Bean demoInterceptor -->
				<ref bean="demoInterceptor"/>		
			</mvc:interceptor>
		</mvc:interceptors>	

3. 添加控制器方法:
		@RequestMapping("/test.do")
		public String test(){
			System.out.println("test()");
			return "test";
		}

4. 测试
		http://localhost:8088/spring-mvc-d2/test.do

利用拦截器可以解决权限管理问题:

![](imgs/4.png)

步骤:

1. 编写拦截器:
		/**
		 * 继承HandlerInterceptorAdapter的好处是
		 * 可以减少实现HandlerInterceptor接口时候的空方法.
		 * 称为: 适配器(Adapter)模式! 
		 */
		@Component
		public class AccessInterceptor 
			extends HandlerInterceptorAdapter{
		
			@Override
			public boolean preHandle(
					HttpServletRequest request, 
					HttpServletResponse response, 
					Object handler)
					throws Exception {
				//检查用户是否登录
				User user=(User)request.getSession()
						.getAttribute("loginUser");
				if(user==null){
					System.out.println("没有登录");
					String path="toLogin.do";
					response.sendRedirect(path);
					return false;
				}
				return true; 
			}
		}

2. 配置拦截器 spring-mvc.xml
		<!-- 配置权限拦截器 -->
		<mvc:interceptor>
			<mvc:mapping path="/*.do"/>
			<!-- exclude-mapping配置放过的请求 -->
			<mvc:exclude-mapping path="/toLogin.do"/>
			<mvc:exclude-mapping path="/login.do"/>
			<ref bean="accessInterceptor"/> 
		</mvc:interceptor>

3. 部署测试, 没有登录就会转到登录页

## Servlet Filter 与 拦截器

Servlet Filter 是工作在Web容器中, 其拦截范围非常宽, 任何HTTP请求都可以被拦截处理

Spring MVC 拦截器, 工作在Spring MVC容器中, 只能拦截Spring MVC的请求.

![](imgs/5.png)

拦截*.css *.js的案例:

1. 编写过滤器
		public class DemoFilter implements Filter{
			public void init(FilterConfig config) 
					throws ServletException {
			}
			public void doFilter(ServletRequest request,
					ServletResponse response, 
					FilterChain chain)
				throws IOException, ServletException {
				HttpServletRequest req=
						(HttpServletRequest)request;
				StringBuffer url=req.getRequestURL();
				System.out.println(url); 
				chain.doFilter(request, response); 
			}
			public void destroy() {
			}
		}
		
2. 配置:
		<filter>
			<display-name>DemoFilter</display-name>
			<filter-name>DemoFilter</filter-name>
			<filter-class>controller.DemoFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>DemoFilter</filter-name>
			<url-pattern>*.css</url-pattern>
		</filter-mapping>
		<filter-mapping>
			<filter-name>DemoFilter</filter-name>
			<url-pattern>*.js</url-pattern>
		</filter-mapping>

3. 测试, 需要清理浏览器缓存.

## Spring MVC 异常处理

软件在运行过程中很有可能出现异常, 而在控制器中进行大量的try catch编码显然是非常繁琐的, Spring MVC提供了异常方案, 可以大大简化异常的处理.

Spring MVC 中可以使用多种异常处理
1. 在控制器中直接使用try ... catch 语句进行处理.
2. 在控制器中使用 @ExceptionHandler 注解进行异常处理. 
3. 在Spring MVC 配置文件中进行异常处理.

> 目前最常用的方式是使用 @ExceptionHandler 注解进行异常处理

![](imgs/6.png)

案例步骤:

1. 在控制器中添加异常处理方法
		/**
		 * 当控制器出现 Exception 类型异常时候
		 * 会执行 handleException 方法
		 * 利用 @ExceptionHandler 注解处理异常的
		 * 好处是可以避免每个控制器方法中都写 
		 * try...catch 来处理异常.
		 * 在 异常处理方法中不能使用 ModelMap 参数!
		 * @param e 控制器方法中出现的异常
		 * @return 视图名
		 */ 
		@ExceptionHandler(Exception.class)
		public String handleException(
				Exception e, 
				HttpServletRequest request){
			e.printStackTrace();
			request.setAttribute(
					"msg", "异常:"+e.getMessage());
			return "error";
		}

	> 注意: 在异常处理方法中不能注入 ModelMap 对象!

2. 为软件添加测试异常:
		/**
		 * 删除用户
		 */
		public void delete(int id){
			Connection conn = null;
			PreparedStatement ps = null;
			try {
				String s = null;
				s.length(); //引起异常
				conn = DBUtils.getConn();
				String sql = "DELETE FROM t_user "
						+ "WHERE id=?";
				ps = conn.prepareStatement(sql);
				ps.setInt(1, id);
				ps.executeUpdate();
			} catch (Exception e) {
				e.printStackTrace();
				throw new RuntimeException(e);
			}finally{
				DBUtils.close(conn, ps, null);
			}
		}
		
	> String s = null; s.length(); 会引发空指针异常

3. 测试, 在执行删除功能时候, 会跳转到异常处理页面.

## 文件上载(上传 upload)

HTTP协议支持文件上载功能, 具体内容请参看 [http://doc.tedu.cn/rfc/rfc1867.txt](http://doc.tedu.cn/rfc/rfc1867.txt "RFC1867")

原理:

![](imgs/upload.png)

浏览器和Spring MVC按照这个 RFC1867 标准实现文件上载, 具体步骤

1. 客户端 
	- 使用form 标签并且使用 method="post" 和 enctype="multipart/form-data"
	- 使用 input type=file 选择文件
2. 服务器端
	- 导入 commons-fileupload
	- 在Spring中配置 multipartResolver 组件
	- 在控制器利用 MultipartFile 接收文件

案例步骤:

1. 编写客户端 upload.html
		<h1>文件上载</h1>
		<!-- 文件上载表单必须有 method="post"
		 和 enctype="multipart/form-data" -->
		<form  action="upload.do" method="post"
			enctype="multipart/form-data">
			<div>
				<label>选择文件</label>
				<!-- input type="file" 用于选择上载文件 -->
				<input type="file" name="image"> 
			</div>
			<div>
				<label>说明</label>
				<input type="text" name="memo">
			</div>
			<input type="submit" value="上传">  
		</form>	
	
	> 提示: 利用浏览器的F12可以检查文件上载的http消息

2. 在项目中导入 commons-fileupload 组件
		<dependency>
			<groupId>commons-fileupload</groupId>
			<artifactId>commons-fileupload</artifactId>
			<version>1.3.3</version>
		</dependency>

3. 在spring-mvc.xml 中配置上载解析器
		<!-- 配置文件上载解析器 -->
		<bean id="multipartResolver"
		    class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<!-- 设置上载编码, 否则中文文件名会乱码 -->
			<property name="defaultEncoding" 
				value="utf-8"/>
		   <!-- one of the properties available; the maximum file size in bytes -->
		   <!-- 最大上载总字节数 -->
		   <property name="maxUploadSize" 
		    	value="10000000"/>
		</bean>

4. 编写控制器方法:
		//method=RequestMethod.POST 限定
		//用户提交的请求必须是 post 请求,
		//如果不是post请求, 则会出现500错误
		@RequestMapping(value="/upload.do",
				method=RequestMethod.POST)
		public String upload(
				MultipartFile image,
				String memo, 
				HttpServletRequest request)
			throws Exception {
			//文件相关信息从image对象中获取
			//获取文件名
			String filename = 
					image.getOriginalFilename();
			//获取文件长度
			long length=image.getSize();
			//获取文件中全部的数据
			//byte[] data=image.getBytes();
			//获取<input name="?"> name 属性值
			String name=image.getName();
			
			System.out.println(filename);
			System.out.println(name);
			System.out.println(length);
			System.out.println(memo);
			
			//保存到文件 Linux: /home/soft01/files
			//File dir = new File("D:/files");
			
			//获取Tomcat中实际的路径: 
			//servletContext.getRealPath()
			String path="/files";
			path=request.getServletContext()
					.getRealPath(path);
			System.out.println(path);
			
			//将文件保存到Tomcat的实际路径中:
			File dir=new File(path);
			if(!dir.exists()) dir.mkdir();
			File file = new File(dir, filename);
			//保存到文件
			//image.transferTo(file); 
			
			//利用流保存文件
			InputStream in=image.getInputStream();
			FileOutputStream out=
					new FileOutputStream(file);
			int b;
			while((b=in.read())!=-1){
				out.write(b);
			}
			in.close();
			out.close();
			return "ok";
		}
		
5. 测试....


#==============================Spring_Mybatis_day06======================================
# Spring 

## Spring MVC 文件下载

### 直接下载图片

Spring MVC 对文件下载做了支持, 原理为:

![](imgs/1.png)

使用步骤:

1. 编写控制器:
	
		/**
		 * 利用Spring 下载显示一张照片
		 */
		@RequestMapping("/image.do")
		public void image(
				HttpServletResponse response)
			throws Exception{
			//读取照片数据 到 bytes数组中
			String path="D:/1.png";
			byte[] bytes = readFile(path);
			//设置响应头
			response.setContentType("image/png");
			response.setContentLength(
					bytes.length);
			//设置响应正文(Message Body)
			OutputStream out=
					response.getOutputStream();
			out.write(bytes);
			out.close();
		}

		private byte[] readFile(String path) throws FileNotFoundException, IOException {
			File file=new File(path);
			byte[] bytes=
					new byte[(int)file.length()];
			FileInputStream in=
					new FileInputStream(file);
			in.read(bytes);
			in.close();
			return bytes;
		}
	
	> 配置拦截器, 放过image.do请求

2. 利用浏览器测试:

		http://localhost:8088/spring-mvc-d2/image.do

### @ResponseBody注解

Spring MVC 提供了@ResponseBody注解, 这个是一个自动处理响应Body的注解:

1. 当返回值是 byte[] 时候会自动设置ContentLength, 自动填充到 响应body中.
2. 当返回值是Java Bean 时候自动转换为 JSON 字符串(后面讲解)
3. 还有其他功能 ...

原理:

![](imgs/2.png)

案例:

1. 编写控制器:

		/**
		 * 利用Spring 下载显示一张照片
		 */
		@RequestMapping(value="/image2.do",
				produces="image/png")
		@ResponseBody
		public byte[] image2() throws Exception{
			//读取照片数据 到 bytes数组中
			String path="D:/1.png";
			byte[] bytes = readFile(path);
			//自动设置响应头
			//自动设置响应正文(Message Body)
			return bytes;
		}
	
	> 配置拦截器, 放过image2.do请求

2. 编写网页 download.html:

		<!DOCTYPE html>
		<html>
		<head>
		<meta charset="UTF-8">
		<title>Insert title here</title>
		<style type="text/css">
		.png{width: 200px}
		</style>
		</head>
		<body>
			<h1>下载演示</h1>
			<h2>显示照片</h2>
			<p>
				<img class="png" alt="" src="image.do">
				<img class="png" alt="" src="image2.do">
			</p>
		</body>

3. 测试图片的显示

## 验证码功能

网站经常利用验证码功能, 避免网站被机器自动访问. 其原理为:

![](imgs/code.png)

实现步骤:

1. 利用控制器生成验证码图片, 并且将验证码保存到Session中.
2. 更新login.jsp 显示验证码
3. 更新登录控制器, 验证处理验证码.

案例:

1. 添加生成验证码的控制器 

		@RequestMapping(value="/code.do",
				produces="image/png")
		@ResponseBody
		public byte[] code(
				HttpSession session) 
				throws IOException {
			String code=code(4);
			//将验证码保存到Session中
			session.setAttribute("testCode",code);
			byte[] bytes=createPng(code);
			return bytes;
		}

		/**
		 * 生成验证码字符串 
		 * @param n 验证码位数
		 * @return 随机的验证码
		 */
		static String c = "abcdefhjkpqrdsyx345678ABCDEFGHJKLMNPQRSTUV";
		public String code(int n){
			char[] code=new char[n];
			Random r = new Random();
			for(int i=0; i<n; i++){
				code[i]=c.charAt(
					r.nextInt(c.length()));
			}
			return new String(code);
		}

	> 验证码算法原理:
	![](imgs/4.png)
		
		/**
		 * 生成验证码图片
		 * @throws IOException 
		 */
		private byte[] createPng(String code) throws IOException {
			BufferedImage img=
					new BufferedImage(100, 40, 
					BufferedImage.TYPE_3BYTE_BGR);
			img.setRGB(0, 0, 0xff0000); 
			img.setRGB(50, 20, 0xffff00); 
			Random r = new Random();
			for(int i=0; i<100; i++){
				int x = r.nextInt(100);
				int y = r.nextInt(40);
				int color=r.nextInt(0xffffff);
				img.setRGB(x, y, color); 
			}
			Graphics2D g = img.createGraphics();
			//设置字体
			Font font=new Font(Font.SANS_SERIF,
					Font.PLAIN, 30);
			g.setFont(font); 
			//设置颜色
			g.setColor(new Color(
					r.nextInt(0xffffff)));
			g.drawString(code, 10, 30);
			//创建 "酱油瓶"
			ByteArrayOutputStream out=
					new ByteArrayOutputStream();
			//将图片数据(酱油)倒入 "酱油瓶"
			ImageIO.write(img, "png", out);
			//盖上盖子
			out.close();
			//将"酱油瓶"中的数据(酱油)倒出来 
			byte[] bytes = out.toByteArray();
			return bytes;
		}

	> 绘图原理:
	![](imgs/3.png)

2. 更新login.jsp页面显示验证码:

		<tr>
			<td valign="middle" align="right">
				验证码:
			</td>
			<td valign="middle" align="left">
				<input type="text"
				 class="inputgri" name="code" />
				<img onclick="this.src='code.do?'+new Date().getTime();" 
				  src="code.do">
			</td>
		</tr>

3. 更新登录控制器, 处理验证码:

		/**
		 * 处理登录请求的控制器方法
		 */
		@RequestMapping("/login.do")
		public String login(
				@ModelAttribute(name="username")
				String username, 
				String pwd, 
				String code,
				ModelMap model, 
				HttpSession session,
				HttpServletRequest request,
				HttpServletResponse response){
			String testCode=(String)session
					.getAttribute("testCode");
			//Ignore 忽略  Case 大小写
			if(code==null || 
				!code.equalsIgnoreCase(testCode)){
				model.put("login_failed", 
						"验证码错误");
				return "login";
			}
		...

4. 在拦截器中放过验证码的 url

		<mvc:exclude-mapping path="/code.do"/>

5. 测试...

## 下载保存图片

图片默认情况下, 浏览器进行内联(inline)显示, 如果需要实现下载功能, 则需要设置一个响应头 Content-Disposition 

具体请参看: http://doc.tedu.cn/rfc/rfc2616.txt 的 19.5.1 章节

下载图片的原理是:

![](imgs/download.png)

案例:

1. 编写控制器:

		@RequestMapping(value="/download.do",
				produces="image/png")
		@ResponseBody
		public byte[] download(
				HttpServletResponse response)
			throws IOException {
			String file = URLEncoder.encode(
					"实例1.png", "UTF-8");
			response.setHeader(
					"Content-Disposition", 
					"attachment; filename=\""
					+file+"\"");
			byte[] bytes=readFile("D:/1.png");
			return bytes;
		}

2. 编写客户端

		<h2>下载</h2>
		<p>
			<a href="download.do">下载图片</a> 
		</p>

3. 测试

不仅能够下载图片而且能够下载Excel:

![](imgs/excel.png)

步骤:

1. 导入Excel API
		<!-- POI 是Apache组织提供的开源 Office API -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>3.17</version>
		</dependency>

2. 编写控制器
		@RequestMapping(value="/excel.do",
				produces="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
		@ResponseBody
		public byte[] excel(
				HttpServletResponse response)
			throws IOException {
			String file = URLEncoder.encode(
					"实例1.xlsx", "UTF-8");
			response.setHeader(
					"Content-Disposition", 
					"attachment; filename=\""
					+file+"\"");
			byte[] bytes=createExcel();
			return bytes;
		}
	
		private byte[] createExcel()
			throws IOException{
			//创建工作簿(就是Excel文件)
			XSSFWorkbook workbook =
					new XSSFWorkbook();
			//在工作簿中创建工作表
			XSSFSheet sheet=
					workbook.createSheet("演示");
			//在工作表中创建行, 参数是行号 0 1 2 3...
			XSSFRow row = sheet.createRow(0);
			//在行中创建格子, 参数列号 0 1 2 3...
			XSSFCell cell=row.createCell(0);
			//在格子中添加数据
			cell.setCellValue("Hello  World!");
			ByteArrayOutputStream out=
					new ByteArrayOutputStream();
			workbook.write(out);
			workbook.close();
			out.close();
			byte[] bytes=out.toByteArray();
			return bytes;
		}

3. 编写客户端:
		<h2>下载</h2>
		<p>
			<a href="download.do">下载图片</a> 
			<a href="excel.do">下载Excel</a> 
		</p>

4. 测试

## 添加用户列表导出功能

导出原理:

![](imgs/export.png)

步骤:

1. 编写控制器:
		@RequestMapping(value="/export.do",
				produces="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
		@ResponseBody
		public byte[] export(
				HttpServletResponse response)
			throws IOException {
			String file = URLEncoder.encode(
					"用户列表.xlsx", "UTF-8");
			response.setHeader(
					"Content-Disposition", 
					"attachment; filename=\""
					+file+"\"");
			byte[] bytes=usersExcel();
			return bytes;
		}
	
		private byte[] usersExcel() 
			throws IOException {
			XSSFWorkbook workbook = 
					new XSSFWorkbook();
			XSSFSheet sheet = 
					workbook.createSheet("用户列表");
			//创建表头
			XSSFRow header=sheet.createRow(0);
			header.createCell(0).setCellValue("编号");
			header.createCell(1).setCellValue("姓名");
			header.createCell(2).setCellValue("电话");
			header.createCell(3).setCellValue("邮箱");
			//将用户信息填充到excel表格中
			List<User> list=userDAO.findAll();
			int n = 1;
			for(User user:list){
				XSSFRow row=sheet.createRow(n++);
				row.createCell(0).setCellValue(
						user.getId());
				row.createCell(1).setCellValue(
						user.getUsername());
				row.createCell(2).setCellValue(
						user.getPhone());
				row.createCell(3).setCellValue(
						user.getEmail());
			}
			//将Excel数据保存到 byte[] 数组中
			ByteArrayOutputStream out=
					new ByteArrayOutputStream();
			workbook.write(out);
			workbook.close();
			out.close();
			byte[] bytes=out.toByteArray();
			return bytes; 
		}

2. 更新客户端listUser.jsp添加导出按钮
		<input type="button" class="button" 
		value="导出到Excel" 
		onclick="location='export.do'"/> 

3. 测试


#==============================Spring_Mybatis_day07======================================
# 王影

# wangying@tedu.cn

#ssm

##Mybatis
1.持久层的框架,支持普通的sql语句,存储过程(项目)
2.封装了底层的jdbc
3.提高开发效率
4.sql语句可以配置到xml文件中,注解

## 框架的使用
建库
	create database mydb;

1.建表
		create table t_user(
			id int auto_increment primary key,
			name  varchar(50),
			pwd  varchar(32),
			email varchar(50),
			phone varchar(32)
		);

2.新建工程
	1)新建maven工程
	2)添加web.xml
	3)添加tomcat运行环境
	4)添加依赖jar包:mybatis.jar,mysql.jar,junit.jar

3.编写实体类User
		public class User {
			private Integer id;
			private String name;
			private String pwd;
			private String email;
			private String phone;
			....
		}

4.配置mybatis框架

1)配置文件
		<?xml version="1.0" encoding="UTF-8"?> 
		<!DOCTYPE configuration PUBLIC "-//ibatis.apache.org//DTD Config 3.0//EN" 
			"http://ibatis.apache.org/dtd/ibatis-3-config.dtd">
		<configuration>
			<environments default="environment">
				<environment id="environment">
					<transactionManager type="JDBC" />
					<dataSource type="POOLED">
						<property name="driver" value="com.mysql.jdbc.Driver" />
						<property name="url"
							value="jdbc:mysql://localhost:3306/db" />
						<property name="username" value="root" />
						<property name="password" value="root" />
					</dataSource>
				</environment>
			</environments>
			<!-- <mappers>
				<mapper resource="StudentMapper.xml" />
			</mappers> -->
		</configuration>

2)映射文件
	<!-- namespace表示命名空间,值不能重复 -->
	<mapper namespace="userDao">
		<!-- id属性, 给节点定义名字,不能重复-->
		<!-- void insertUser(User user); 
		parameterType表示方法的参数列表-->
		<insert id="addUser" 
			parameterType="cn.tedu.mybatis.bean.User">
			insert into t_user(
				name,pwd,email,phone
			)values(
				#{name},#{pwd},#{email},#{phone}
			)
			
		</insert>
		<!-- 修改t_user表信息 -->
		<!-- void updateUser(User user); -->
		<!-- update用来实现修改功能的节点 
			id属性给update节点起名,名字唯一
			parameterType表示参数的类型
		-->
		<update id="updateUser" 
		parameterType="cn.tedu.mybatis.bean.User">
			update  
				t_user
			set
				name = #{name},pwd = #{pwd},
				email = #{email},phone = #{phone}
		
			where
				id = #{id}
		</update>
		<!-- 根据id删除一条记录 -->
		<!-- void deleteUser(Integer id) -->
		<!-- 1.delete表示删除功能的节点 ;
			2.如果参数列表是基本数据类型(封装类类型),或者String类型,可以省略parameterType;
			3.如果不省略,可以写成parameterType="java.lang.Integer"
		-->
		<delete id="delUser">
			delete from t_user
			where
				id=#{id}
		</delete>
		<!-- 根据id查询用户信息 -->
		<!-- User selectUserById(Integer id) -->
		<!-- select用来实现查询功能
		resultType表示记录封装的实体类类型
		封装的规则:默认把表的字段名作为类的属性名
		-->
		<select id="getUserById" 
			resultType="cn.tedu.mybatis.bean.User">
			select *
			from 
				t_user
			where
				id=#{id}
		</select>
		<!-- 查询表中的所有数据 -->
		<!-- List<User> selectAll() -->
		<select id="selectAll" 
			resultType="cn.tedu.mybatis.bean.User">
				select * 
				from t_user
		</select>
	</mapper>

5.编写持久层(使用mybatis提供的api实现对数据库表的操作)
	
	1）定义接口
		public interface UserDao {
		/**
		 * 插入t_user表的数据
		 * @param user
		 */
		void insertUser(User user);
		/**
		 * 修改t_user表的数据
		 * @param user
		 */
		void updateUser(User user);
		/**
		 * 根据id删除t_user表的数据
		 * @param id
		 */
		void deleteUser(Integer id);
		/**
		 * 根据id查询用户信息
		 * @param id
		 * @return 如果id存在,返回user,否则返回null
		 */
		User selectUserById(Integer id);
		/**
		 * 返回表中的所有数据
		 * @return
		 */
		List<User> selectAll();
		}

	2) 定义接口的实现类
		public class UserDaoImpl implements UserDao{
			public void insertUser(User user) {
				//通过mybatis提供的api方法,实现插入
		
				//3.SqlSession session=? //Connection
				SqlSession session = SessionUtil.getSession();
				
				//第一个参数表示:namespace+id
				session.insert("userDao.addUser", user);
				//提交事务
				session.commit();
				//关闭session
				session.close();
			}

			public void updateUser(User user) {
				//获取session对象
				SqlSession session = 
					SessionUtil.getSession();
				//调用update方法
				session.update("userDao.updateUser",user);
				//提交事务
				session.commit();
				//关闭session
				session.close();
			}

			public void deleteUser(Integer id) {
				//获取session对象
				SqlSession session = 
						SessionUtil.getSession();
				//调用delete
				session.delete("userDao.delUser",id);
				//提交事务
				session.commit();
				//关闭session
				session.close();
			}

			public User selectUserById(Integer id) {
				SqlSession session =
						SessionUtil.getSession();
				User user = 
						session.selectOne("userDao.getUserById", id);
				session.close();
				return user;
			}

			public List<User> selectAll() {
				SqlSession session =
						SessionUtil.getSession();
				List<User> list = session.selectList("userDao.selectAll");
				session.close();
				return list;
			}
		}

测试:
		public class TestUser {
			@Test
			public void testSelectAll(){
				UserDao dao = new UserDaoImpl();
				List<User> list = 
						dao.selectAll();
				for(User user : list){
					System.out.println(user.getEmail()+user.getName());
				}
			}
			@Test
			public void testSelectById(){
				UserDao dao = new UserDaoImpl();
				User user = 
						dao.selectUserById(2);
				System.out.println(user.getEmail()+user.getName());
			}
			@Test
			public void testDelUser(){
				UserDao dao = new UserDaoImpl();
				dao.deleteUser(1);
			}
			@Test
			public void testUpdateUser(){
				UserDao dao = new UserDaoImpl();
				User user = new User();
				user.setId(1);
				user.setName("王影");
				user.setPwd("111111");
				user.setEmail("wangying@tedu.cn");
				user.setPhone("13800138009");
				dao.updateUser(user);
			}
			@Test
			public void testInsertUser(){
				UserDao dao = new UserDaoImpl();
				User user = new User();
				user.setName("admin");
				user.setPwd("123456");
				user.setEmail("admin@tedu.cn");
				user.setPhone("13800138000");
				dao.insertUser(user);
			}
		}

##小结:

持久层:
1.定义接口
2.定义接口的实现类
3.sql语句设置到映射文件中.
SqlSession提供的方法:insert update delete selectOne selectList

# 基于Mapper映射器的mybatis框架的使用(重点)

##建表
		create table t_address(
			id int auto_increment primary key,
			province varchar(50),
			city varchar(50),
			area varchar(50),
			user_address varchar(50)
		)

##创建工程
	1)创建maven工程
	2)添加web.xml文件
	3)添加tomcat运行环境
	4)添加依赖jar包 mysql  mybatis junit

##添加mybatis的配置文件
1.把SqlConfig.xml放到resources文件夹下;此文件配置的信息用来实现数据库连接的配置信息
2.在resources文件中,创建新的文件夹mappers,在mappers文件夹中,放置映射文件AddressMapper.xml;

##对表完成crud的操作
1.创建实体类
		public class Address {
			private Integer id;
			private String province;
			private String city;
			private String area;
			private String userAddress;
			....
		}

2.持久层

1)定义接口
		public interface AddressDao {
			void insertAddress(Address address);
			void updateAddress(Address address);
			void deleteAddress(Integer id);
			Address selectById(Integer id);
			List<Address> selectAll();
		}

2)映射文件
	<!-- namespace的值必须是接口名 -->
	<mapper namespace="cn.tedu.mybatis.dao.AddressDao">
		<!-- 插入数据 -->
		<!-- void insertAddress(Address address); -->
		<!-- 
			id的值必须为方法的名称
			parameterType表示方法的参数类表
		-->
		<insert id="insertAddress" 
			parameterType="cn.tedu.mybatis.bean.Address">
				insert into t_address(
					province,city,area,user_address
				)values(
					#{province},#{city},#{area},
					#{userAddress}
				)
		</insert>
		<!-- 修改地址信息 -->
		<!-- void updateAddress(Address address); -->
	
		<update id="updateAddress"
			parameterType="cn.tedu.mybatis.bean.Address">
			update 
				t_address
			set
				province = #{province},
				city = #{city},
				area = #{area},
				user_address = #{userAddress}	
			where
				id = #{id}
		</update>
		<!-- 删除地址信息 -->
		<!-- void deleteAddress(Integer id); -->
		<delete id="deleteAddress">
			delete from t_address
			where
				id=#{id}
		</delete>
		<!-- 根据id查询地址信息 -->
		<!-- Address selectById(Integer id); -->
		<!-- 如果字段名和属性不相同;那么给字段起别名,别名要和属性吗相同 -->
		<select id="selectById" 
		resultType="cn.tedu.mybatis.bean.Address">
			select
				id,province,city,area,
				user_address userAddress
			from
				t_address
			where
				id = #{id}
		</select>
	</mapper>

测试:
		public class TestAddress {
			@Test
			public void testGetById(){
				SqlSession session = 
						SessionUtil.getSession();
				AddressDao ad = session.getMapper(AddressDao.class);
				System.out.println(
						ad.selectById(2));
			}
			@Test
			public void testDeleteAddress(){
				SqlSession session = 
						SessionUtil.getSession();
				AddressDao ad = session.getMapper(AddressDao.class);
				ad.deleteAddress(1);
				session.commit();
				session.close();
			}
			@Test
			public void testUpdateAddress(){
				SqlSession session = 
						SessionUtil.getSession();
				AddressDao ad = session.getMapper(AddressDao.class);
				Address address = new Address();
				address.setId(1);
				address.setProvince("河北省");
				address.setCity("石家庄");
				address.setArea("新华区");
				address.setUserAddress("万达广场");
		
				ad.updateAddress(address);
				session.commit();
				session.close();
			}
			@Test
			public void testInsertAddress(){
				SqlSession session = SessionUtil.getSession();
				AddressDao ad = session.getMapper(AddressDao.class);
				//session.insert("namespace+id",address);
				Address address = new Address();
				address.setProvince("北京市");
				address.setCity("市辖区");
				address.setArea("海淀区");
				address.setUserAddress("中鼎大厦8层");
		
				ad.insertAddress(address);
				session.commit();
				session.close();
		
			}
		}

	


create table t_dept(
	id int auto_increment primary key,
	dept_name varchar(50),
	dept_loc varchar(50)
	);


#==============================Spring_Mybatis_day08======================================
#[回顾]

1.mybatis:持久层;封装了jdbc底层的api;映射文件(核心)编写sql语句.

2.mapper节点中,namespace="接口的名称";

3.insert、update、delete、select、

4.以上4个节点中,id属性值="方法的名称"

5.都可以有parameterType属性:如果属性是基本数据类型或者String类型,可省略;如果是实体类类型必须写上

6.只有<selete>有resultType;如果查询的方法返回类型为实体类类型或者List<实体类类型>类型,resultType的值表示记录封装的实体类类型

7.在查询时候,如果字段名和属性名不相同,有两种解决方案:
	(1).给字段起别名:别名必须和属性名相同
	(2).字段和属性之间做个映射

#ssm整合:部门管理

##新建工程

1.新建maven工程

2.添加web.xml

3.添加tomcat运行环境

4.添加依赖jar包

	spring-webmvc 

	mybatis
	mybatis-spring

	mysql
	commons-dbcp
	spring-jdbc
	
	junit
	jstl

5.规范包名

	cn.tedu.ssm.bean:实体类
	cn.tedu.ssm.mapper:持久层接口
	cn.tedu.ssm.service:业务层包含接口和类
	cn.tedu.ssm.controller:控制器层

6.配置文件

	1)spring-mvc.xml(spring-mvc的配置文件)

	<!-- annotation:注解, driven: 驱动的 -->
	<mvc:annotation-driven/>
	<!-- 视图解析器 -->
	<bean id="jspViewResolver" 
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" 
			value="/web/"/><!-- 删除 jsp/ -->
		<property name="suffix" 
			value=".jsp"/>
	</bean>
	
	<context:component-scan base-package="cn.tedu.ssm.controller"/>
	

	2)spring-mybatis.xml(applicationContext.xml)
	
	<!-- 配置jdbc.properties -->
		<util:properties id="jdbc" 
			location="classpath:jdbc.properties"/>
			
	<!-- 配置数据库的连接池 -->
		<bean id="dataSource" 
		class="org.apache.commons.dbcp.BasicDataSource">
			<property name="driverClassName" value="#{jdbc.driver}"/>
			<property name="url" value="#{jdbc.url}"/>
			<property name="username" value="#{jdbc.username}"/>
			<property name="password" value="#{jdbc.password}"></property>
			<property name="initialSize" value="#{jdbc.initSize}"></property>
			<property name="maxActive" value="#{jdbc.maxSize}"></property>
		</bean>
		
	<!-- spring和mybatis整合 重点 -->
		<!-- SqlSessionFactoryBean实例化sessionFactory
			dataSource依赖注入数据源 mapperLocations配置映射文件的位置
		-->
		<bean id="factoryBean" 
			class="org.mybatis.spring.SqlSessionFactoryBean">
			<property name="dataSource" ref="dataSource"/>	
			<property name="mapperLocations" value="classpath:mappers/*.xml"/>
		</bean>
		
	<!-- MapperScannerConfigurer 定义持久层接口的包名 -->
		<bean id="scannerConfigurer" 
			class="org.mybatis.spring.mapper.MapperScannerConfigurer">
			<property name="basePackage" value="cn.tedu.ssm.mapper"/>
		</bean>

	3)jdbc.properties(数据库配置的属性文件)

	driver=com.mysql.jdbc.Driver
	url=jdbc:mysql://localhost:3306/mydb
	username=root
	password=root
	initSize=3
	maxSize=3

	4)在resources文件夹下新建mappers文件夹,把DeptMapper.xml拷贝到mappers文件夹中.

	DeptMapper.xml(映射文件)

	<!-- namespace的值必须是接口名 -->
	<mapper namespace="cn.tedu.ssm.mapper.DeptMapper">
		<!-- 这里写sql语句 -->
	</mapper>

7.web.xml

	1)ContextLoaderListener---spring容器中

	2)DispatcherServlet-------spring-mvc容器中

	3)设置编码格式Filter 

	  <!-- spring上下文的监听器 -->
	  <listener>
	  	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	  </listener>
	  <!-- 设置web应用的上下文 -->
	  <context-param>
	  	<param-name>contextConfigLocation</param-name>
	  	<param-value>classpath:spring-mybatis.xml</param-value>
	  </context-param>

	  <!-- 配置前端控制器 -->
	  <servlet>
	  	<servlet-name>dispatcherServlet</servlet-name>
	  	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	  	<init-param>
	  		<param-name>contextConfigLocation</param-name>
	  		<param-value>classpath:spring-mvc.xml</param-value>
	  	</init-param>
	  	<load-on-startup>1</load-on-startup>
	  </servlet>
	  <servlet-mapping>
	  	<servlet-name>dispatcherServlet</servlet-name>
	  	<url-pattern>*.do</url-pattern>
	  </servlet-mapping>

	  <!-- 设置编码格式Filter -->
	  <filter>
	  	<filter-name>encodingFilter</filter-name>
	  	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	  	<init-param>
	  		<param-name>encoding</param-name>
	  		<param-value>utf-8</param-value>
	  	</init-param>
	  </filter>
	  <filter-mapping>
	  	<filter-name>encodingFilter</filter-name>
	  	<url-pattern>/*</url-pattern>
	  </filter-mapping>

	
##设计表t_dept

	create table t_dept(
		id int auto_increment primary key,
		dept_name varchar(50),
		dept_loc varchar(50)
	)

## 部门管理
### 1.添加部门

###1.添加部门-持久层

新建类 Dept


1.接口中定义方法

	public interface DeptMapper{
		void insertDept(Dept dept);
	}

2.映射文件中编写sql语句
	
	在DeptMapper.xml文件中,定义`insert`节点,编写insert语句

	<insert id="insertDept" parameterType="cn.tedu.ssm.Dept">
		insert into t_dept(
			dept_name,dept_loc
		)values(
			#{deptName},#{deptLoc}
		)
	</insert>
	
测试:

###2.添加部门-业务层

1.定义接口

	public interface DeptService{
		void addDept(Dept dept);
	}

2.编写实现类:实现接口中方法

	@Service
	public class DeptServiceImpl implements DeptService{
		@Resource
		private DeptMapper deptMapper;
		public void addDept(Dept dept){
			//调用持久层的方法
			deptMapper.insertDept(dept);
		}
	}
	
测试:

### 3.添加部门-控制器层

1.显示页面

	/showAdd.do
	请求参数 : 无
	请求方式 : get/post
	响应方式 : 转发
	
	@Controller
	@ReqeustMapping("/dept")
	public class DeptController{
		@RequestMapping("/showAdd.do")
		public String showAdd(){
			return "add";
		}
	}

定义add.jsp,在web文件夹中定义add.jsp

	<form action="" method="post">
	部门名称:<input type="text" name="name" ><br>
	部门地址:<input type="text" name="loc"><br>
	<input type="submit" value="添加">
	</form>

2.定义url处理添加按钮功能

	/addDept.do
	请求参数:name,loc
	请求方式:post
	响应方式:转发       ---ok.jsp
	
	@RequestMapping("/addDept.do")
	public String addDept(String name,String loc){
		//1.调用业务层方法
		//2.return "ok"
	}

在web文件夹中定义ok.jsp


##小结

1.spring-mybatis整合

2.ssm环境的搭建

3.分析问题:页面----数据库

  解决问题:数据库----页面

4.开发步骤:1)db table 2)持久层 3)业务层   4)控制器  5)页面 
	 


#=======================================ajax_day01================================
#[回顾]

1.spring-mybaits整合

	<!-- 扫描持久层包 -->
	<bean id="" class=".....MapperScannerConfigurer">

		<property name="basePackage" value="xx.xx.mapper"/>

	</bean>

	<bean id="" class="......SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource">
		<property name="mapperLocations" value="classpath:mappers/*.xml"/>

	</bean>

2.整合的环境

3.开发步骤:页面-控制器-业务层-持久层

##2.部门管理-显示部门信息

###1.显示部门信息-持久层

1.接口中定义方法

	List<Dept> selectAll();

2.映射文件中编写sql语句

	<select id="selectAll" resultType="xx.xx.Dept">
		select
			id,
			dept_name deptName,
			dept_loc deptLoc
		from
			t_dept
	</select>

测试:\

###2.显示部门信息-业务层

1.接口定义方法

	List<Dept> getDeptAll();

2.在实现类中实现接口中的方法

	方法的功能:调用持久的方法,返回list

测试:

###3.显示部门信息-控制器层
请求url

	/getAll.do
	参数列表:ModelMap (request)----把list传递到页面
	请求方式:get
	响应方式:转发

	@RequestMapping("/getAll.do")
	public String getAll(ModelMap map){
		//1.调用业务层方法,返回list
		//2.把list添加到map

		//3.return "showDept";
	}

###4.显示部门信息-页面

	<%@ page contentType="text/html; charset=utf-8"
    pageEncoding="utf-8"%>
	<%@ taglib prefix="c" 
		 uri="http://java.sun.com/jsp/jstl/core" %>
	<html>
	<head>
	<title>Insert title here</title>
	</head>
	<body style="font-size:30px;">
	<table style="width: 60%" border="1">
	<tr>
		<th>部门编号</th>
		<th>部门名称</th>
		<th>部门地址</th>
		<th>操作</th>
	</tr>
	<c:forEach items="${requestScope.list}" 
				  var="dept">
		<tr>
			<td>${dept.id}</td>
			<td>${dept.deptName}</td>
			<td>${dept.deptLoc}</td>
			<td>修改 删除</td>
		</tr>
	</c:forEach>
	
	</table>
	</body>
	</html>

##3.部门管理-删除
###1.删除部门-持久层

1.在接口中定义方法

	void deleteById(Integer id);

2.在映射文件中,定义delete语句

	<delete id="deleteById" >
		delete from t_dept
		where
			id=#{id}
	</delete>

测试：

###2.删除部门-业务层

1.接口定义方法

	void removeById(Integer id);

2.在实现类中,实现方法:

	方法功能:调用持久层方法

测试：

###3.删除部门-控制层
url 

	/removeDept.do
	参数列表:id
	请求方式:get
	响应方式:重定向 --------- getAll.do

	@RequestMapping("/removeDept.do")
	public String removeDept(Integer id){
		//1.调用业务层方法
		
		return "redirect:/dept/getAll.do";
	}

###4.删除部门-页面

	<a href="${}/dept/removeDept.do?id=${dept.id}">删除</a>

# 学子商城

1.用户管理

	1)注册
	2)登录
	3)修改个人信息(基本信息,密码)

2.地址管理
	1)添加地址
	2)显示地址
	3)管理地址(修改,删除)

3.商品管理
	1)商品分类
	2)商品展示
	3)商品详情

4.购物车

	1)添加购物车
	2)管理购物车商品

# 开发流程

1.项目需求---需求说明书(项目原型)

2.概要设计

3.详细设计

4.编码

5.测试

6.上线(产品交付)

7.维护

# ajax

##1.定义

1.ajax不是新的技术,是javascript,xml,XMLHttpRequest(xhr)的结合体,完成异步提交功能.

2.同步提交:用户提交数据后,当前页面不可以操作;页面响应成功,才可以操作页面.

3.异步提交:用户提交数据后,还可以在当前页面上操作;和服务器响应是否成功,没有太大影响.

4.特点:从服务器端获取一小部分数据.

##2.原理

用户请求交给xhr处理,然后xhr把请求提交给服务器,服务器响应数据给xhr,由xhr把数据接收回来,通过javascript设置数据到页面


##3.xhr的创建和函数属性

1.创建xhr对象

	function getXHR(){
		//1.定义变量
			var xhr;
		
		//2.判断
		if(window.XMLHttpRequest){
			//现阶段所有的浏览器都支持的对象
			xhr = new XMLHttpRequest();
		}else{
			//兼容IE5 IE6
			xhr = new ActiveXObject("Microsoft.XMLHttp");
		}
		return xhr;
	}

2.open()打开连接

	open("get/post","url",true);

3.send();发送请求

4.onreadystatechange:从创建xhr到响应数据成功,监听5中状态变化

5.readyState:获取状态
	
	0.未初始化
	1.初始化成功,发送请求
	2.接收数据
	3.解析数据
	4.响应成功

6.status:获取响应状态码:200  404  405 500

7.responseText:接收服务器 响应的数据


## 使用ajax-异步验证用户名
开发步骤

1.创建工程

	创建maven
	添加web.xml
	添加tomcat运行环境
	依赖jar  spring-webmvc  junit
	配置文件  spring-mvc.xml
	在web.xml中,配置前端控制器和Filter

2.页面register.jsp

	<html>
	<head>
	<title>Insert title here</title>
	</head>
	<body style="font-size:30px;">
	<form action="" >
	用户姓名:<input type="text" 
				name="name" id="name" 
				onblur="checkNameFun()"/>
	用户密码:<input type="password" name="pwd" id="pwd"/>
	<input type="submit" value="注册"/>
	</form>
	</body>
	<script type="text/javascript">
	//返回xhr对象
	function getXHR(){
		//1.定义变量
			var xhr;
		
		//2.判断
		if(window.XMLHttpRequest){
			//现阶段所有的浏览器都支持的对象
			xhr = new XMLHttpRequest();
		}else{
			//兼容IE5 IE6
			xhr = new ActiveXObject("Microsoft.XMLHttp");
		}
		return xhr;
	}

	//name文本框失去焦点事件处理函数
	function checkNameFun(){
		//1.创建xhr对象
		var xhr = getXHR();
		//2.监听事件,处理事件
		xhr.onreadystatechange=function(){
			//判断状态是第五种,并且响应的状态码是200
			if(xhr.readyState==4&&xhr.status==200){
				alert(xhr.responseText);
			}
		};
		//3.打开连接
		var nameValue = document.getElementById("name").value;
		xhr.open("get","${pageContext.request.contextPath}/user/checkName.do?name="+nameValue,true);
		//4.发送请求
		xhr.send();
	}
	</script>
	</html>


3.控制器

	/showRegister.do
	参数类表:无
	请求方式:get
	响应方式:转发

	//显示页面
	@RequestMapping("/showRegister.do")
	public String showRegister(){
		return "register";
	}

	//验证用户名
	//@ResponseBody表示不响应视图组件
	@RequestMapping("/checkName.do")
	@ResponseBody
	public String checkName(String name){
		System.out.println(name);
		if("admin".equals(name)){
			//0表示失败的状态码
			return "0";
		}else{
			//1表示成功的状态码
			return "1";
		}
	}


#===============================ajax_day02================================
#[回顾]

1.ajax:由javascript,xml,XMLHttpRequest,和在一起,叫ajax.实现请求异步提交

2.异步请求:在页面发送请求时,当前页面还可以继续使用,响应的数据什么时候回来,显示到页面,不影响操作页面.

3.原理:发送请求,交给ajax的xhr对象,由xhr对象发送请求给服务器;服务器响应的数据给xhr,由xhr结合javascript,把数据设置到页面上.

4.xhr对象的创建和函数和属性

	1) var xhr = new XMLHttpRequest();

	2) xhr.open("get/post","url",true);

	3) xhr.send();

	4) xhr.onreadystatechange=function(){

	5) xhr.readyState:0-4

	6) xhr.status
		if(xhr.readyState==4&&xhr.status==200){
		
	7) xhr.responseText
			alert(xhr.responseText);

		}
	}

## 二级联动菜单-post请求

1. 页面

	省:<select name="province" id="province" 
			  onchange="getCityFun(this.value)">
	<option>...请选择...</option>
	<option value="1">河北省</option>
	<option value="2">辽宁省</option>
	</select>
	城市:<select name="city" id="city">
		<option>...请选择...</option>
	</select>

2. 异步请求的函数定义


	//获取城市列表
	
	function getCityFun(provinceCode){
		//1.获取xhr对象
		var xhr = getXHR();
		//2.定义处理事件的函数
		xhr.onreadystatechange=function(){
			if(xhr.readyState==4&&xhr.status==200){
				var cityValue = xhr.responseText;
				//11,石家庄市;12,廊坊市
				var city = cityValue.split(";");
				//["11,石家庄市","12,廊坊市"]
				//获取city节点
				var cityNode = document.getElementById("city");
				cityNode.innerHTML="<option>..请选择..</option>";
				for(i=0;i<city.length;i++){
					var cv = city[i];//11,石家庄市
					var vf = cv.split(",");
					var code = vf[0];//11
					var value = vf[1]//石家庄市
					//创建Option对象;
					//第一个参数表示显示的城市名称
					//第二个参数表示value的值,城市编号
					var op = new Option(value,code);
					//追加子节点
					cityNode.appendChild(op);
				}
			}
			
		}
		//3.打开连接(创建url)
		xhr.open("post","${pageContext.request.contextPath}/user/getCity.do",true);
		//post请求必须要设置一个请求头,
		//位置send()之前
		xhr.setRequestHeader("content-type","application/x-www-form-urlencoded");
		//4.发送请求
		xhr.send("provinceCode="+provinceCode);
	}

3. 控制器的方法

	//获取城市列表
	@RequestMapping("/getCity.do")
	@ResponseBody
	public String getCity(String provinceCode){
		if(provinceCode.equals("1")){
			return "11,石家庄市;12,廊坊市";
		}else{
			return "21,沈阳市;22,大连市";
		}
	}


# Json

1. 客户端和服务器端传递数据的一种解决方案

2. 语法:key-value

	var jsonObject = {
						"state":0,
						"message":"失败"
					};

	alert(jsonObject.state);

3. 好处:易于编写,易于阅读,易于解析

## 定义和使用json对象-客户端

1. 一个k-v的json对象

	var obj = {"state":1};

	alert(obj.state);

2. 多个k-v的json对象的定义和访问

	var obj = {
				"state":0,
				"message":"失败"
	};
		
	alert(obj.state+","+obj.message);

3. 多个k-v的json对象的定义和访问(value的值是对象)

	var obj = {
				"state":1,
				"message":"成功",
				"data":{
					"name":"王影",
					"age":16
				}
		};
		alert(obj.data.name+","+obj.data.age);

4. json数组的定义和访问

	var obj = [
		           {"code":11,"name":"石家庄市"},
		           {"code":12,"name":"廊坊市"}
		           ];
		for(i = 0;i<obj.length;i++){
			alert(obj[i].code+","+obj[i].name);
		}

5. 多个k-v的json对象的定义和访问(value的值是数组)

	var obj = { 
				"state":1,
   			    "message":"成功",
				"data":[
							{"code":11,"name":"石家庄市"},
							{"code":12,"name":"廊坊市"}		        
				        ]
		};
		for(i=0;i<obj.data.length;i++){
			alert(obj.data[i].code+","+obj.data[i].name);
		}


## java对象转换为json字符串-服务器端

1. 通用的工具类的定义

	public class ResponseResult<T> {
	private  Integer state;
	private String message;
	private T data;
	public ResponseResult() {
		
	}
	public ResponseResult(Integer state,
						  String message) {
		super();
		this.state = state;
		this.message = message;
	}
	public ResponseResult(Integer state, String message, T data) {
		super();
		this.state = state;
		this.message = message;
		this.data = data;
	}
	public Integer getState() {
		return state;
	}
	public void setState(Integer state) {
		this.state = state;
	}
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public T getData() {
		return data;
	}
	public void setData(T data) {
		this.data = data;
	}
	

	}

2. 依赖jar包

	jackson*3

		<!-- java对象转换为json字符串 -->
		<dependency>
		  <groupId>com.fasterxml.jackson.core</groupId>
		  <artifactId>jackson-databind</artifactId>
		  <version>2.8.3</version>
		</dependency>
		<dependency>
		  <groupId>com.fasterxml.jackson.core</groupId>
		  <artifactId>jackson-core</artifactId>
		  <version>2.8.3</version>
		</dependency>
		<dependency>
		  <groupId>com.fasterxml.jackson.core</groupId>
		  <artifactId>jackson-annotations</artifactId>
		  <version>2.8.3</version>
		</dependency>


3. 定义控制器类
	
	@Controller
	@RequestMapping("/user")
	public class UserController {
	
	//返回状态码和信息内容
	@RequestMapping("/test1.do")
	@ResponseBody
	public ResponseResult<Void> test1(){
		ResponseResult<Void> rr =
			new ResponseResult<Void>(1,"成功");
		return rr;
	}
	//返回包含实体类对象的ResponseResult对象
	@RequestMapping("/test2.do")
	@ResponseBody
	public ResponseResult<User> test2(){
		ResponseResult<User> rr = 
			new ResponseResult<User>(1,"成功");
		User user = new User();
		user.setName("王影");
		user.setEmail("wangying@tedu.cn");
		user.setPhone("13800138000");
		
		rr.setData(user);
		
		return rr;
	}
	//响应ResponseResult对象中包含集合类型的数据
	@RequestMapping("/test3.do")
	@ResponseBody
	public ResponseResult<List<User>> test3(){
		ResponseResult<List<User>> rr = 
			new ResponseResult<List<User>>(1,"成功");
		User u1 = new User();
		u1.setName("admin");
		u1.setEmail("admin@tedu.cn");
		u1.setPhone("10086");
		
		User u2 = new User();
		u2.setName("manager");
		u2.setEmail("manager@tedu.cn");
		u2.setPhone("10086");
		
		List<User> list = new ArrayList<User>();
		list.add(u1);
		list.add(u2);
		
		rr.setData(list);
		
		return rr;
		
		}
	}
	

## 练习 -显示用户的信息到页面上

## 练习 -二级联动菜单

1. 定义City类
	
	public class City{
		private String code;
		private String name;

	}

2. 在控制器中定义方法

	@
	@
	public ResponseResult<List<City>> getCity(String provicneCode){
		//1.创建rr对象
		//2.判断provinceCode
		//3.创建City对象,把对象添加到list
		//4.把list设置到rr对象中
		//5.return rr;
	}

3. 页面-异步请求的for循环

	var obj = JSON.parse(xhr.responseText);
	for(i = 0;i<obj.data.length;i++){
		var op = new Option(obj.data[i].name,obj.data[i].code);
	}
	
#===============================TeduStore_day01================================
	
create table t_user(
id int auto_increment primary key,
username varchar(50) not null unique,
password varchar(50) not null,
email varchar(50) not null,
phone varchar(50) not null,
image varchar(200),
gender int(1),
created_uer varchar(50),
created_time date,
modified_user varchar(50),
modified_time date
)default charset=utf8;

