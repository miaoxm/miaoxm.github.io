1.JAVA开发环境:
  1)java编译运行过程:-------------常见面试题
    1.1)编译期:.java源文件，经过编译，生成.class字节码文件
	1.2)运行期:JVM加载.class并运行.class
	特点:跨平台、一次编程到处使用
  2)名词解释:-----------------常见面试题
    2.1)JVM:java虚拟机
	        加载.class并运行.class
	2.2)JRE:java运行环境
	        除了包含JVM以外还包含了运行java程序所必须的环境
			JRE=JVM+java系统类库(小零件)
	2.3)JDK:java开发工具包
	        除了包含JRE以外还包含了开发java程序所必须的命令工具
			JDK=JRE+编译、运行等命令工具
	说明:
	  2.1)运行java程序的最小环境为JRE
	  2.2)开发java程序的最小环境为JDK
Eclipse:
  1)IBM、开源的、免费的、不需要安装仅需要解压即可                                                                   1
——————————————————————————————————————————————————————————
基本数据类型:
    byte：整型，1个字节 -128～127
    short:整型，2个字节
  1)int:整型，4个字节，0
  2)long:长整型，8个字节，0L
     float：浮点型 4个字节
  3)double:浮点型，8个字节，0.0d
  4)boolean:布尔型，1个字节，true,false
  5)char:字符型，2个字节
3.基本数据类型间的转换:
    数据类型从小到大依次为:
	  byte,short,int,long,float,double
	        char
  1)两种方式:
    1.1)自动类型转换:从小类型到大类型
	1.2)强制类型转换:从大类型到小类型
	      语法: (要转换成为的数据类型)变量
		  强转有可能会溢出或丢失精度
  2)两点规则:
    2.1)整数直接量可以直接赋值给byte,short,char，但不能超出范围
	2.2)byte,short,char型数据参与运算时，先一律转换为int再运算                                           2
————————————————————————————————————————————————————————
1.运算符:
  1)算术:+-*/%,++,--
  2)关系:>,<,>=,<=,==,!= boolean
  3)逻辑:&&,||,! boolean
  4)赋值:=,+=,-=,*=,/=,%=
  5)字符串连接:+
  6)条件/三目:boolean?数1:数2
2.分支结构:
  1)if:1条路
  2)if...else:2条路                                                                                             3
——————————————————————————————————————————————————————————
1.分支结构:
  3)if...else if结构:多条路
  4)switch...case结构:多条路
    优点:效率高、结构清晰
	缺点:整数、相等
	break:跳出switch
  1）作用域范围：从变量的声明开始，到包含他最近的大括号。
2.循环:反复执行一段相同或相似的代码
3.循环三要素:
  1)循环变量的初始化
  2)循环的条件(以循环变量为基础)
  3)循环变量的改变(向着循环的结束变)
  循环变量:在整个循环过程中所反复改变的那个数
4.循环结构:
  1)while:先判断后执行，有可能一次都不执行
  2)do...while:先执行后判断，至少执行一次
               要素1与要素3相同时，首选do...while									4
———————————————————————————————————————————————————————————
1.for:固定次数
2.break:跳出循环
  continue:跳过循环体中剩余语句而进入下一次循环
3.嵌套循环:
    循环中套循环，外层走一次，内层走所有次
	层数越少越好，break只能跳出一层循环
4.数组:
    引用类型，相同数据类型元素的集合
	int[] arr = new int[10];
	int[] arr = {1,4,6};
	int[] arr = new int[]{1,4,6};
	System.out.println(arr.length); //10
    arr[0] = 100;
	arr[10] = 100; //数组下标越界
	System.out.println(arr[arr.length-1]);
    for(int i=0;i<arr.length;i++){
	  arr[i] = 100;
	  System.out.println(arr[i]);
	}                                                                                                              5
________________________________________________________________________
1.数组:
  1)复制:
    1.1)System.arraycopy(a,1,a1,0,4);
	1.2)int[] a1 = Arrays.copyOf(a,6);
	    a = Arrays.copyOf(a,a.length+1);
  2)排序:
    2.1)Arrays.sort(arr);
	2.2)冒泡:
	    2.2.1)四个数冒三轮
		2.2.2)每一轮都是从第1个元素开始，
		      每一次都是和它相邻的两个元素比
		2.2.3)冒出来了就不带它玩了
2.方法:
    封装特定的业务逻辑功能，一个方法只干一件事
	多次调用，减少重复，便于维护、便于团队协作开发
3.方法的定义:
    修饰词 返回值类型 方法名(参数列表){
	  方法体
	}
4.方法的调用:                      方法重载必须是相同的方法名
  1)无返回值: 方法名(有参传参);
  2)有返回值: 数据类型 变量 = 方法名(有参传参);
              方法名(有参传参);----------不建议
5.return:
  1)return 值; //1.1)结束方法 1.2)返回结果给调用方
  2)return;    //2.1)结束方法                                                    				6
—————————————————————————————————————————————————————————
猜字母游戏
                                                                                       7（3.16～3.18）
—————————————————————————————————————————————————————————
OOP
1.什么是类？什么是对象？
  1)现实世界是由很多对象组成的
    基于对象抽出了类
  2)对象:真实存在的单个个体
    类:类型/类别，代表一类个体
  3)类中可以包含:
    3.1)所有对象所共有的属性/特征----------------成员变量
	3.2)所有对象所共有的行为---------------------方法
  4)一个类可以创建多个对象
    同一类型所创建出来的对象，结构相同，数据不同
  5)类是对象的模板，对象是类具体的实例
2.如何创建类？如何创建对象？如何访问成员？
 class 类名     new XX()     引用。XXXXX
高质量的代码:
  复用性好、扩展性好、维护性好、
  可移植性好、健壮性好、可读性好、效率好...
                                                                                       9
——————————————————————————————————————————————————————
0.方法的签名:方法名+参数列表
1.方法的重载(Overload):
  1)发生在一个类中，方法名称相同，参数列表不同
  2)编译器在编译时会根据方法的签名自动绑定调用的方法
2.构造方法:
  1)常常给成员变量赋初值
  2)与类同名，没有返回值类型
  3)在创建(new)对象时被自动调用
  4)若自己不写构造方法，则编译器默认一个无参构造方法，
    若自己写了构造方法，则不再默认提供
  5)构造方法可以重载
3.this:指代当前对象，哪个对象调用方法指的就是哪个对象
       只能用在方法中，方法中访问成员变量之前默认有个this.
  this的用法:
    1)this.成员变量名-----------------访问成员变量
	2)this.方法名()-------------------调用方法(一般不用)
	3)this()--------------------------调用构造方法
4.null:空，没有指向任何对象
       若引用的值为null，则该引用不能再进行任何操作了，
	   若操作则发生NullPointerException空指针异常
5.引用类型变量之间画等号:
  1)指向同一个对象
  2)通过一个引用对数据的修改会影响另一个引用对数据的访问
    eg: 房子钥匙
  基本类型变量之间画等号:
  1)赋值
  2)对一个变量的修改不会影响另一个变量的值
    eg: 身份证复印件

内存管理:由JVM来管理的
1)堆:所有new出来的对象(包括成员变量)
2)栈:所有的局部变量
3)方法区:.class字节码文件(包括方法)

成员变量和局部变量是可以同名的，用时采用就近原则
成员变量和局部变量同名时，this不能省略
                                                                                       10
——————————————————————————————————————————————————————
1.引用类型数组:
  1)Student[] stus = new Student[3];
    stus[0] = new Student();
  2)Student[] stus = new Student[]{
    new Student("zhangsan",25,"LF")}
  3)int[][] arr = new int[3][];----------数组的数组
    arr[0] = new int[2];
	arr[1] = new int[3];
	arr[2] = new int[2];
	arr[1][0] = 100; 
  4)int[][] arr = new int[3][4];
    for(int i=0;i<arr.length;i++){
	  for(int j=0;j<arr[i].length;j++){
	    arr[i][j] = 100;
	  }  }
2.继承:
  1)作用:代码复用                                        局部变量若是基本类型，存值 
  2)通过extends来实现继承                                        引用类型，存地址
  3)超类:所有派生类所共有的属性和行为                            
    派生类:派生类所特有的属性和行为
  4)派生类继承超类后，派生类具有:超类的+派生类的
  5)一个超类可以有多个派生类
    一个派生类只能有一个超类-------单一继承
  6)继承具有传递性
  7)java规定:构造派生类之前必须先构造超类
    在派生类的构造方法中若没有调用超类的构造方法
	----------则默认super()调用超类的无参构造方法
	在派生类的构造方法中若调用了超类的构造方法
	----------则不再默认提供
	super()调用超类构造方法，必须位于派生类构造的第1句
3.super:指代当前对象的超类对象
  super的用法:
    1)super.成员变量名-----------------访问超类的成员变量
	2)super.方法名()-------------------调用超类的方法(明天下午讲)
	3)super()--------------------------调用超类的构造方法
                                                                                       11
——————————————————————————————————————————————————————
1.向上造型:
  1)超类型的引用指向派生类对象
  2)能点出来什么，看引用的类型
2.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
  3)重写遵循"两同两小一大"原则:
    3.1)两同:
	    3.1.1)方法名相同
		3.1.2)参数列表相同
	3.2)两小:
	    3.2.1)派生类方法的返回值类型小于或等于超类方法的
		      3.2.1.1)void时，必须相等
			  3.2.1.2)基本类型时，必须相等
			  3.2.1.3)引用类型时，小于或等于
		3.2.2)派生类方法抛出的异常小于或等于超类方法的------API讲异常时
	3.3)一大:
	    3.3.1)派生类方法的访问权限大于或等于超类方法的------明天讲
2.重写与重载的区别:-----------常见面试题
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)遵循"运行期"绑定，看对象的类型调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)遵循"编译期"绑定，看引用/参数的类型绑定方法
                                                                                       12
——————————————————————————————————————————————————————
1.package和import:
2.访问控制修饰符:
  1)public:任何类
  2)protected:本类、子类、同包类
  3)默认的:什么也不写，本类、同包类
  4)private:本类
3.final:不能变
   变量不能被改变，方法不能被重写，类不能被继承
4.static:静态的
    static，类，方法区，一份，类名点，
	  所有对象所共享的数据(图片、音频、视频等)
    static，类，方法区，一份，类名点，
	  静态方法没有隐式this，不能直接访问实例成员
	  方法的操作仅与参数相关而与对象无关
	static，类，在类被加载期间自动执行，一次
	  加载/初始化静态资源(图片、音频、视频等)
                                                                                       13
——————————————————————————————————————————————————————
1.static final常量:
   必须声明同时初始化，类名点，不能改变
   编译时直接被替换为具体的值，效率高
   数据永远不变，经常使用
2.抽象方法:
   abstract，只有方法的定义，没有具体的实现
3.抽象类:
   abstract，包含抽象方法的类必须是抽象类
   不能被实例化
   是需要被继承的，派生类:
     1)重写抽象类中的所有抽象方法
	 2)也声明为抽象类
   意义:代码复用、向上造型、
        可以包含抽象方法，为所有派生类提供统一的入口
		派生类中重写的实现不同，但入口是一致的
                                                                                       14
——————————————————————————————————————————————————————
1.成员内部类: 应用率低
  1)类中套类，里面的称为Inner内部类，外面的称为Outer外部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类通常是在外部类中创建的
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有一个隐式的引用指向了创建它的外部类对象
      eg: 外部类名.this.
2.匿名内部类:
  1)若想创建一个类的对象，并且对象只被创建一次，
    此时该类不必命名，称之为匿名内部类
  2)jdk1.7(含)版本之前，匿名内部类中想访问外面的变量，
    要求该变量必须是final的
                                                                                       15
——————————————————————————————————————————————————————
1.接口:
  1)是一种数据类型(引用类型)
  2)由interface定义的
  3)只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现/继承的，实现类/派生类:
       必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，应先继承后实现
  7)接口可以继承接口
                                                                                       16
——————————————————————————————————————————————————————
1.多态:
  1)意义:
    1.1)同一类型的引用指向不同的对象时，有不同的实现
	    --------行为的多态:cut()、run()、step()...
	1.2)同一个对象被造型为不同的类型时，有不同的功能
	    --------对象的多态:我、你、水...
  2)向上造型/自动类型转换:
    2.1)超类型的引用指向派生类的对象
	2.2)能造型成为的类型有:超类+所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件只有如下两种:
    3.1)引用所指向的对象就是该类型
	3.2)引用所指向的对象实现了该接口/继承了该类
  4)强转若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议:强转之前先通过instanceof来判断引用所指向的对象是否是该类型
                                                                                       17
——————————————————————————————————————————————————————
1.内存管理:由JVM来管理的
  1)堆:
    1.1)存储new出来的对象(包括实例变量)
	1.2)垃圾:没有任何引用所指向的对象
	    垃圾回收器(GC)不定时到内存中去清扫垃圾
		GC的回收过程是透明的(看不到)，不一定一发现垃圾就立刻回收
		可以调用System.gc()建议虚拟机尽快调度GC来回收垃圾
	1.3)实例变量的生命周期:
	      创建对象时存储在堆中，对象被回收时一并被回收
	1.4)内存泄漏:不再使用的内存还没有被及时的回收
	    建议:若对象不再使用时应及时将其引用设置为null
  2)栈:
    2.1)存储正在调用的方法中的所有局部变量(包括方法的参数)
	2.2)调用方法时会为该方法在栈中分配一块对应的栈帧，
	    栈帧中包含方法中的局部变量(包括参数)，
		当方法调用结束时，栈帧被清除，局部变量一并被清除
	2.3)局部变量的生命周期:
	      调用方法时存储在栈中，方法结束时与栈帧一并消失
  3)方法区:
    3.1)存储.class字节码文件(包括方法、静态变量)
	3.2)方法只有一份，通过this来区分具体的访问对象

面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性和行为
  2)方法:封装的是具体的业务逻辑实现
  3)访问控制修饰符:封装的是具体的访问权限
2.继承:
  1)作用:代码复用
  2)超类:所有派生类所共有的属性和行为
    接口:部分派生类所共有的行为
    派生类:派生类所特有的属性和行为
  3)传递性，单一继承，多接口实现
3.多态:
  1)意义: 
    1.1)行为多态(抽象方法都是多态的)
    1.2)对象多态(所有对象都是多态的)
  2)向上造型、强制类型转换、instanceof
  3)多态的表现形式:
    3.1)重写:根据对象的不同来表现多态
	3.2)重载:根据参数的不同来表现多态


如果程序的运行结果与你预期不同时，需要调试:
1)打桩: System.out.println(数据);
2)Debug调试工具: 先添加断点
  2.1)掌握4个键
      2.1.1)F5:单步调试(会进入到方法中)
	  2.1.2)F6:逐过程调试(不会进入到方法中)
	  2.1.3)F7:结束方法的调试
	  2.1.4)F8:跳到下一个断点位置，若后面没有断点了，则调试结束
  2.2)会看2个东西
      2.2.1)看变量
	  2.2.2)添加监视
                                                                                       18
——————————————————————————————————————————————————————
实例方法可以访问类变量；
 类方法只能访问类变量；
 类方法可以通过对象调用。
                                                                                       19
——————————————————————————————————————————————————————



